<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>cutezhangq</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cutezhangq.github.io/favicon.ico?v=1597067700218">
<link rel="stylesheet" href="https://cutezhangq.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="温故知新">
    
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cutezhangq.github.io">
        <img src="https://cutezhangq.github.io/images/avatar.png?v=1597067700218" class="site-logo">
        <h1 class="site-title">cutezhangq</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/cutezhangq" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cutezhangq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/thisapplycallbind/">
                  <h2 class="post-title">this、apply、call、bind</h2>
                </a>
                <div class="post-date">
                  2020-08-09
                </div>
                <div class="post-abstract">
                  <h1 id="面试题-区别bind与call和apply">面试题: 区别bind()与call()和apply()?</h1>
<ul>
<li>都能指定函数中的this</li>
<li>call()/apply()是 立即调用函数</li>
<li>bind()是 将函数返回</li>
</ul>
<pre><code class="language-js">//在不传参的形式下： .call同.apply  可以强制this的指向
  var obj0 = {username:'gaga'};
  function foo(){
    console.log(this);
  }
  foo.call(obj0)        //{username:'gaga'}
  foo.apply(obj0)       //{username:'gaga'}

//传参时： call直接传   apply放到数组中传
  function foo1(data){
      console.log(this,data);
  }
  foo1.call(obj0,33)      //{username:'gaga'} 33    直接从第二个参数开始，依次传入
  foo1.apply(obj0,[33])   //{username:'gaga'} 33  第二个参数必须是数组，传入的数据放在数组里
  foo.bind(obj0)   //没有输出
</code></pre>
<p><strong>bind的特点：</strong><br>
绑定完this不会立即调用当前的函数，而是将函数返回</p>
<pre><code class="language-js">//bind的特点：
    //绑定完this不会立即调用当前的函数，而是将函数返回
      //写法1.
    var bar = foo.bind(obj0)
    console.log('bar',bar)      //foo(){  console.log(this);  }
    bar();                     //{username:'gaga'}
      //写法2.
    foo.bind(obj0)();         //{username:'gaga'}

//bind的用法：用来指定回调函数的this      vue中常用
    setTimeout(function(){
      console.log('---',this)   //不绑定bind,this是window；bind后this指向为obj0     --- {username: &quot;gaga&quot;}
    }.bind(obj0),1000)

//bind传参的方式：
    function fun(age) {
        this.name = 'kobe';
        this.age = age;
        console.log('dd');
    }
    var obj = {};
    fun.bind(obj, 12)();
    console.log(obj.name, obj.age);      //kobe 12
</code></pre>
<h1 id="this">this</h1>
<ul>
<li>this可以用在构造函数之中，表示实例对象。<br>
除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。<br>
简单说，<code>this就是属性或方法“当前”所在的 对象。</code><br>
下面是一个实际的例子。</li>
</ul>
<pre><code class="language-js">var person = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

person.describe()       // &quot;姓名：张三&quot;
</code></pre>
<p>上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。<br>
由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，<br>
<strong>即this的指向是可变的。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var B = {
    name: '李四'
};

B.describe = A.describe;
B.describe()    // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。<br>
稍稍重构这个例子，this的动态指向就能看得更清楚。</p>
<pre><code class="language-js">function f() {
    return '姓名：'+ this.name;
}

var A = {
    name: '张三',
    describe: f
};

var B = {
    name: '李四',
    describe: f
};

A.describe() // &quot;姓名：张三&quot;
B.describe() // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。<br>
<strong>只要函数被赋给另一个变量，this的指向就会变。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var name = '李四';
var f = A.describe;
f()     // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。</p>
<h1 id="2-this-的使用场景">2. this 的使用场景</h1>
<h2 id="1全局环境">（1）全局环境</h2>
<pre><code class="language-js">this === window // true

function f() {
    console.log(this === window);
}
f() // true
</code></pre>
<h2 id="2构造函数">（2）构造函数</h2>
<p>构造函数中的this，指的是实例对象。</p>
<pre><code class="language-js">var Obj = function (p) {
    this.p = p;
};
</code></pre>
<h2 id="3对象的方法">（3）对象的方法</h2>
<p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。<br>
但是，这条规则很不容易把握。请看下面的代码。</p>
<pre><code class="language-js">var obj ={
    foo: function () {
        console.log(this);
    }
};

obj.foo() // obj
</code></pre>
<p>上面代码中，obj.foo方法执行时，它内部的this指向obj。<br>
但是，下面这几种用法，都会改变this的指向。</p>
<pre><code class="language-js">// 情况一
(obj.foo = obj.foo)() // window
// 情况二
(false || obj.foo)() // window
// 情况三
(1, obj.foo)() // window

</code></pre>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。</p>
<pre><code class="language-js">var a = {
    b: {
        m: function() {
            console.log(this.p);
        },
        p: 'Hello'
    }
};

var hello = a.b.m;
hello() // undefined
</code></pre>
<p><strong>即：当有赋值情况时，先将值替换，然后再看this的指向</strong></p>
<h1 id="使用注意点">使用注意点</h1>
<h2 id="countersection-避免多层-this">counter(section) &quot;　&quot;避免多层 this</h2>
<p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。</p>
<pre><code class="language-js">var o = {
    f1: function () {
        console.log(this);
        var f2 = function () {
            console.log(this);
        }();
    }
}

o.f1()
// Object
</code></pre>
<p>上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<pre><code class="language-js">var temp = function () {
    console.log(this);
};

var o = {
    f1: function () {
        console.log(this);
        var f2 = temp();
    }
}
</code></pre>
<p>一个解决方法是在第二层改用一个指向外层this的变量。</p>
<pre><code class="language-js">var o = {
    f1: function() {
        console.log(this);
        var that = this;
        var f2 = function() {
            console.log(that);    //然后在内层使用that，就不会发生this指向的改变
        }();
    }
}

o.f1()
// Object
// Object
</code></pre>
<p><strong>上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</strong><br>
事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。<br>
JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。</p>
<h2 id="2-countersection-避免数组处理方法中的-this">2 &quot;.&quot; counter(section) &quot;　&quot;避免数组处理方法中的 this</h2>
<p>数组的<code>map</code>和<code>forEach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用this。<br>
——<strong>使用中间变量固定this。</strong><br>
或者<strong>是将this当作forEach方法的第二个参数，固定它的运行环境。</strong></p>
<h3 id="一种方法就是前面提到的使用中间变量固定this">一种方法，就是前面提到的，使用中间变量固定this。</h3>
<p>应用：</p>
<pre><code class="language-js"> //下单
      async orderDown() {
        var _this = this;
        //获取选择的商品数组信息
        this.listData.forEach(function(item,index){
          goodsIdArr.forEach(function(item2,index2){
            if(item.productId == item2){
              _this.chooseProductList.push(_this.listData[index]);
            }
          })
        });
      },
</code></pre>
<h3 id="另一种方法是将this当作foreach方法的第二个参数固定它的运行环境">另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</h3>
<pre><code class="language-js">var o = {
    v: 'hello',
    p: [ 'a1', 'a2' ],
    f: function f() {
        this.p.forEach(function (item) {
            console.log(this.v + ' ' + item);
        }, this);
    }
}

o.f()
// hello a1
// hello a2
</code></pre>
<h2 id="3-countersection-避免回调函数中的-this">3 &quot;.&quot; counter(section) &quot;　&quot;避免回调函数中的 this</h2>
<p><strong>回调函数中的this往往会改变指向，最好避免使用。</strong></p>
<h2 id="4-绑定-this-的方法">4 &quot;. &quot;绑定 this 的方法</h2>
<p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call、apply、bind</code>这三个方法，来切换/固定this的指向。</p>
<h1 id="call">.call()</h1>
<p>函数实例的call方法，<strong>可以指定函数内部this的指向（即函数执行时所在的作用域）</strong>，然后在所指定的作用域中，调用该函数。</p>
<pre><code class="language-js">var obj = {};

var f = function () {
    return  this;
};

f() === window // true
f.call(obj) === obj // true
</code></pre>
<p>上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；<br>
call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。<br>
call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p>
<pre><code class="language-js">var n = 123;
var obj = { n: 456 };

function a() {
    console.log(this.n);
}

a.call() // 123
a.call(null) // 123
a.call(undefined) // 123
a.call(window) // 123
a.call(obj) // 456
</code></pre>
<p>如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。</p>
<pre><code class="language-js">var f = function () {
    return  this;
};

f.call(5)    // Number {[[PrimitiveValue]]: 5}
</code></pre>
<p>上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。<br>
call方法还可以接受多个参数。</p>
<p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<pre><code class="language-js">function add(a, b) {
    return a + b;
}

add.call(this, 1, 2) // 3
</code></pre>
<p>上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。<br>
call方法的一个应用是调用对象的原生方法。</p>
<pre><code class="language-js">var obj = {};
obj.hasOwnProperty('toString') // false

// 覆盖掉继承的 hasOwnProperty 方法
obj.hasOwnProperty = function () {
    return true;
};
obj.hasOwnProperty('toString') // true

Object.prototype.hasOwnProperty.call(obj, 'toString') // false
</code></pre>
<p>上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。</p>

                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/thisapplycallbind/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/thisapplycallbind.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/slot-cha-cao/">
                  <h2 class="post-title">slot插槽</h2>
                </a>
                <div class="post-date">
                  2020-08-07
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/slot-cha-cao/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/slot-cha-cao.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/xiao-xi-ding-yue-yu-fa-bu/">
                  <h2 class="post-title"> 消息订阅与发布</h2>
                </a>
                <div class="post-date">
                  2020-08-07
                </div>
                <div class="post-abstract">
                  <p>结合 Vue 源码谈谈发布-订阅模式</p>
<h1 id="发布订阅模式主要包含哪些内容呢">发布订阅模式主要包含哪些内容呢?</h1>
<ul>
<li>发布函数，发布的时候执行相应的回调</li>
<li>订阅函数，添加订阅者,传入发布时要执行的函数,可能会携额外参数</li>
<li>一个缓存订阅者以及订阅者的回调函数的列表</li>
<li>取消订阅(需要分情况讨论)</li>
</ul>
<p>这么看下来,其实就像 JavaScript 中的事件模型,我们在DOM节点上绑定事件函数,触发的时候执行就是应用了发布-订阅模式.</p>
<h1 id="我们先按照上面的内容自己实现一个-observer-对象如下">我们先按照上面的内容自己实现一个 Observer 对象如下:</h1>
<pre><code class="language-js">//用于存储订阅的事件名称以及回调函数列表的键值对
function Observer() {
    this.cache = {}  
}

//key:订阅消息的类型的标识（名称），fn收到消息之后执行的回调函数
Observer.prototype.on = function (key,fn) {
    if(!this.cache[key]){
        this.cache[key]=[]
    }
    this.cache[key].push(fn)
}


//arguments 是发布消息时候携带的参数数组
Observer.prototype.emit = function (key) {
    if(this.cache[key]&amp;&amp;this.cache[key].length&gt;0){
        var fns = this.cache[key]
    }
    for(let i=0;i&lt;fns.length;i++){
        Array.prototype.shift.call(arguments)
        fns[i].apply(this,arguments)
    }
}
// remove 的时候需要注意，如果你直接传入一个匿名函数fn，那么你在remove的时候是无法找到这个函数并且把它移除的，变通方式是传入一个
//指向该函数的指针，而 订阅的时候存入的也是这个指针
Observer.prototype.remove = function (key,fn) {
    let fns = this.cache[key]
    if(!fns||fns.length===0){
        return
    }
    //如果没有传入fn，那么就是取消所有该事件的订阅
    if(!fn){
        fns=[]
    }else {
        fns.forEach((item,index)=&gt;{
            if(item===fn){
                fns.splice(index,1)
            }
        })
    }
}


//example


var obj = new Observer()
obj.on('hello',function (a,b) {
    console.log(a,b)
})
obj.emit('hello',1,2)
//取消订阅事件的回调必须是具名函数
obj.on('test',fn1 =function () {
    console.log('fn1')
})
obj.on('test',fn2 = function () {
    console.log('fn2')
})
obj.remove('test',fn1)
obj.emit('test')
</code></pre>
<p>为什么会使用发布订阅模式呢? 它的优点在于:</p>
<ul>
<li>实现<strong>时间上的解耦</strong>(组件,模块之间的异步通讯)</li>
<li><strong>对象之间的解耦</strong>,交由发布订阅的对象管理对象之间的耦合关系.</li>
</ul>
<h1 id="发布-订阅模式在-vue中的应用">发布-订阅模式在 Vue中的应用</h1>
<p>发布-订阅模式又叫<code>观察者模式</code>,它定义对象间的一种<code>一对多</code>的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。JavaScript开发中我们一般用事件模型来代替传统的发布-订阅模式</p>
<h1 id="案例介绍1">案例介绍1</h1>
<p>卖烧饼的店主可以把小明、小龙的电话记录下来,等店里有烧饼了在通知小龙小明来拿这就是所谓的发布-订阅模式，代码如下：</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:[],//缓存列表
    addlisten:function(fn){//增加订阅者
        this.clienlist.push(fn);
    },
    trigger:function(){//发布消息
        for(var i=0,fn;fn=this.clienlist[i++];){
            fn.apply(this,arguments);
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(10,&quot;椒盐&quot;);
</code></pre>
<p>从代码中可以看出，只有小明，小龙预定了烧饼，烧饼店就可以发布消息告诉小龙与小明。但是有个问题不知道大家发现了没有。小明只喜欢椒盐味道的。而小龙只喜欢焦糖味道的。上面的代码就满足不了客户的需求，给客户一种感觉就是，不管我喜欢不喜欢，你都会发给我。如果发布比较多，客户就会感到厌烦，甚至会想删除订阅。下边是对代码进行改良大家可以看看。</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    },
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove:function(key,fn){
        var fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(&quot;焦糖&quot;,fn1=function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(&quot;椒盐&quot;,function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(&quot;椒盐&quot;,10,&quot;椒盐&quot;);

Sesamecakeshop.remove(&quot;焦糖&quot;,fn1);//注意这里是按照地址引用的。如果传入匿名函数则删除不了        

Sesamecakeshop.trigger(&quot;焦糖&quot;,40,&quot;焦糖&quot;);

</code></pre>
<p>删除的时候需要注意的是，如果订阅的时候传递的是匿名函数，删除的时候如果传入的也是匿名函数。则删除不了。因为删除时候是按照地址引用删除的。传进去的两个匿名函数，对应的地址引用是不同的。</p>
<h1 id="案例介绍2">案例介绍2</h1>
<p>比如咱们常见的用户身份分别有不同的功能，超级管理员拥有最高权限，可以删除修改任意用户。而普通用户则只能修改自己的账户信息。首先是用户身份验证，验证通过之后对应功能才可以显示。</p>
<pre><code class="language-js">//登录发布-订阅模式
login={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    }
}
//超级管理员修改所有用户
var editall=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editall.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;超级管理员修改所有用户&quot;);
        }
    }
})();

//仅仅修改自己
var editOwn=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editOwn.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;仅仅修改自己&quot;);
        }
    }
})();
</code></pre>
<p>发布-订阅模式简单封装</p>
<pre><code class="language-js">var _Event=(function(){
    var clienlist={},
    addlisten,trigger,remove;
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten=function(key,fn){
        if(!clienlist[key]){
            clienlist[key]=[];
        }
        clienlist[key].push(fn);
    };
    /**
     * 发布消息
     * */
    trigger=function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    };
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove=function(key,fn){
        var fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    };
    return{
        addlisten:addlisten,
        trigger:trigger,
        remove:remove
    }
})();


_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
});
_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
})
_Event.trigger(&quot;yyyy&quot;,&quot;xxx&quot;,&quot;前端工程师&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596872061540.png" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>发布-订阅模式就是常说的观察者模式，在实际开发中非常有用。它的优点是为时间是解耦，为对象之间解构，它的应用非常广泛，既可以在异步编程中也可以帮助我们完成更松的解耦。发布-订阅模式还可以帮助我们实现设计模式，从架构上来看，无论MVC还是MVVC都少不了发布-订阅模式的参与。然而发布-订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。</p>

                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/xiao-xi-ding-yue-yu-fa-bu/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/xiao-xi-ding-yue-yu-fa-bu.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/shuang-xiang-shu-ju-bang-ding-dan-xiang-shu-ju-liu/">
                  <h2 class="post-title">双向数据绑定、单向数据流</h2>
                </a>
                <div class="post-date">
                  2020-08-07
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/shuang-xiang-shu-ju-bang-ding-dan-xiang-shu-ju-liu/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/shuang-xiang-shu-ju-bang-ding-dan-xiang-shu-ju-liu.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/">
                  <h2 class="post-title">computed，watch，method执行的先后顺序</h2>
                </a>
                <div class="post-date">
                  2020-08-06
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/shu-ju-tong-xin-fang-an-zu-jian-jian-chuan-zhi/">
                  <h2 class="post-title">数据通信方案、组件间传值</h2>
                </a>
                <div class="post-date">
                  2020-08-06
                </div>
                <div class="post-abstract">
                  <h1 id="组件间通信的特点">组件间通信的特点</h1>
<pre><code>1. 不要在子组件中直接修改父组件的状态数据
2. 数据在哪, 更新数据的行为(函数)就应该定义在哪
</code></pre>
<h1 id="vue-组件数据通信方案总结">Vue 组件数据通信方案总结</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596720130251.png" alt="" loading="lazy"><br>
组件 A 与组件 B 、C 之间是父子组件，组件 B 、C 之间是兄弟组件，而组件 A 、D 之间是隔代的关系。<br>
那么对于这些不同的关系，本文主要分享了他们之间可以采用的几种数据通信方式，<br>
例如 Props 、$emit / $on 、Vuex 等，大家可以根据自己的使用场景可以选择适合的使用方式。</p>
<h1 id="一-prop-emit-父子-子父">一、 Prop / $emit    （父——&gt;子        子——&gt;父）</h1>
<h2 id="prop-通过绑定属性的方式">Prop  通过绑定属性的方式</h2>
<pre><code class="language-html">// 父组件   &lt;child :title=&quot;title1&quot;&gt;&lt;/child&gt;
// 子组件   props: { title:Object }
</code></pre>
<p>其中，props的用法：<br>
props 是<strong>单向绑定</strong>的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改父组件的状态。<br>
所以<code>不应该在子组件中修改 props 中的值，Vue 会报出警告</code>。</p>
<h2 id="修改-props-数据">修改 props 数据</h2>
<p>通常有两种原因：</p>
<ul>
<li>prop 作为初始值传入后，子组件想把它当做局部数据来用</li>
<li>prop 作为初始值传入后，由子组件处理成其他数据输出</li>
</ul>
<h2 id="应对办法是">应对办法是</h2>
<ul>
<li>定义一个<code>局部变量</code>，并用 prop 的值初始化它<br>
但是由于定义的 ownChildMsg 只能接受 forChildMsg <code>的初始值</code>，当父组件要传递的值变化发生时，ownChildMsg <code>无法收到更新</code>。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return { ownChildMsg: this.forChildMsg };
  }
};
</code></pre>
<p>这里我们加了一个<p>用于查看 ownChildMsg 数据是否变化，结果发现只有默认值传递给了 ownChildMsg，父组件改变只会变化到 forChildMsg，不会修改 ownChildMsg。</p>
<ul>
<li>定义一个<code>计算属性</code>，处理 prop 的值并返回<br>
由于是计算属性，所以只能显示值，不能设置值。我们这里设置的是一旦从父组件修改了 forChildMsg 数据，我们就把 forChildMsg 加上一个字符串&quot;---ownChildMsg&quot;，然后显示在屏幕上。这时是可以每当父组件修改了新数据，<code>都会更新</code> ownChildMsg 数据的。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  computed: {
    ownChildMsg() {
      return this.forChildMsg + &quot;---ownChildMsg&quot;;
    }
  }
};
</code></pre>
<ul>
<li>更加妥帖的方式是<code>使用变量存储</code> prop 的初始值，并用<code>watch</code>来观察 prop 值得<code>变化</code>。发生变化时，更新变量的值。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return {
      ownChildMsg: this.forChildMsg
    };
  },
  watch: {
    forChildMsg() {
      this.ownChildMsg = this.forChildMsg;
    }
  }
};
</code></pre>

                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/shu-ju-tong-xin-fang-an-zu-jian-jian-chuan-zhi/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/shu-ju-tong-xin-fang-an-zu-jian-jian-chuan-zhi.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/new-yun-suan-fu-de-zhi-xing-guo-cheng/">
                  <h2 class="post-title"> new运算符的执行过程</h2>
                </a>
                <div class="post-date">
                  2020-08-06
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/new-yun-suan-fu-de-zhi-xing-guo-cheng/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/new-yun-suan-fu-de-zhi-xing-guo-cheng.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/">
                  <h2 class="post-title">JSON.stringify与&#34;环&#34;问题</h2>
                </a>
                <div class="post-date">
                  2020-08-06
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/jsonstringify-yu-huan-wen-ti.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/vuex-zhong-mutations-he-actions-de-qu-bie/">
                  <h2 class="post-title">Vuex中mutations和actions的区别</h2>
                </a>
                <div class="post-date">
                  2020-08-06
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/vuex-zhong-mutations-he-actions-de-qu-bie/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/vuex-zhong-mutations-he-actions-de-qu-bie.jpg')">
                  </div>
                </a>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://cutezhangq.github.io/post/mpvue-xing-neng-you-hua-ji-qiao/">
                  <h2 class="post-title">mpvue性能优化技巧</h2>
                </a>
                <div class="post-date">
                  2020-08-05
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
                <a class="right" href="https://cutezhangq.github.io/post/mpvue-xing-neng-you-hua-ji-qiao/">
                  <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/mpvue-xing-neng-you-hua-ji-qiao.jpg')">
                  </div>
                </a>
              
            </article>
          

          <div class="pagination-container">
  
  
    <a href="https://cutezhangq.github.io/page/2" class="next">下一页 <i class="icon-arrow-ios-forward-outline"></i></a>
  
</div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
