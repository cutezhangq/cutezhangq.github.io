<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>面试题 | cutezhangq</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cutezhangq.github.io/favicon.ico?v=1596272993249">
<link rel="stylesheet" href="https://cutezhangq.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="第 1 题： React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
😅emm..对这个问题有过疑问，但是一直没有探寻原因，现在梳理一下
答案
首先在vue循环遍历生成节点中会使用到key，那么到底要不要使用key，..." />
    <meta name="keywords" content="面试" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cutezhangq.github.io">
        <img src="https://cutezhangq.github.io/images/avatar.png?v=1596272993249" class="site-logo">
        <h1 class="site-title">cutezhangq</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cutezhangq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">面试题</h2>
            <div class="post-date">2020-04-01</div>
            
              <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/interview-question.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <h1 id="第-1-题-react-vue-项目时为什么要在列表组件中写-key其作用是什么">第 1 题： React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h1>
<p>😅emm..对这个问题有过疑问，但是一直没有探寻原因，现在梳理一下</p>
<h2 id="答案"><strong>答案</strong></h2>
<p>首先在vue循环遍历生成节点中会使用到key，那么到底要不要使用key，参考官网上的描述：<br>
📃VUE文档:</p>
<ul>
<li>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</li>
</ul>
<p>得出结论，多数情况最好使用key!</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;i in dataList&quot; :key=&quot;i&quot;&gt;{{ i }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>key是用来<code>绑定</code>虚拟节点的，给每一个vnode<code>唯一</code>id。<br>
当不使用key的时候，也可以通过v-for实现以下的dom节点数组<br>
🌰 案例：</p>
<pre><code class="language-js">var vm = new Vue({
  el: '#app',
  data: {
    dataList: [1, 2, 3, 4, 5]
  }
})
</code></pre>
<p>为了方便，标记上id加以说明节点。当数组为[1, 2, 3, 4, 5]时，加key与不加key都如下：</p>
<pre><code class="language-html"> [
    '&lt;div&gt;1&lt;/div&gt;',     // id:  A
    '&lt;div&gt;2&lt;/div&gt;',     // id:  B
    '&lt;div&gt;3&lt;/div&gt;',     // id:  C
    '&lt;div&gt;4&lt;/div&gt;',     // id:  D
    '&lt;div&gt;5&lt;/div&gt;'      // id:  E
  ]
</code></pre>
<p>但是，当数组有变化时，两者就有区别了。<br>
改变dataList数据，进行数据位置替换，对比改变后的数据如下：</p>
<pre><code class="language-javascript"> vm.dataList = [4, 1, 3, 5, 2] // 数据位置替换
 // 没有key的情况， 节点位置不变，但是节点innerText内容更新了
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： A
    '&lt;div&gt;1&lt;/div&gt;', // id:  B
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  D
    '&lt;div&gt;2&lt;/div&gt;'  // id:  E
  ]

  // 有key的情况，dom节点位置进行了交换，但是内容没有更新
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： D
    '&lt;div&gt;1&lt;/div&gt;', // id:  A
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;2&lt;/div&gt;'  // id:  B
  ]
</code></pre>
<p>原因：<code>没有绑定key的情况下，节点会进行复用</code>，即呈现出id没变，内容变化了（<code>就地更新</code>），这样<code>有利于diff速度</code>，但是这种模式会带来一些隐藏的副作用。可能不会产生过渡的效果，某些节点绑定数据（表单）状态时，会出现状态错位。没办法追踪到每个节点。<br>
使用key可以：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<pre><code class="language-html">&lt;transition&gt;
  &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;
&lt;/transition&gt;
</code></pre>
<p>当 text 发生改变时，span总是会被替换而不是被修改，因此会触发过渡。</p>
<p>📃VUE文档也说明了</p>
<ul>
<li>不加key时，<a href="https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81">这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</a></li>
</ul>
<p>增删dataList列表项，对比改变后的数据如下：</p>
<pre><code class="language-html">vm.dataList = [3, 4, 5, 6, 7] // 数据进行增删
  // 1. 没有key的情况， 节点位置不变，内容也更新了
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： A
    '&lt;div&gt;4&lt;/div&gt;', // id:  B
    '&lt;div&gt;5&lt;/div&gt;', // id:  C
    '&lt;div&gt;6&lt;/div&gt;', // id:  D
    '&lt;div&gt;7&lt;/div&gt;'  // id:  E
  ]

  // 2. 有key的情况， 节点删除了 A, B 节点，新增了 F, G 节点
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： C
    '&lt;div&gt;4&lt;/div&gt;', // id:  D
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;6&lt;/div&gt;', // id:  F
    '&lt;div&gt;7&lt;/div&gt;'  // id:  G
  ]
</code></pre>
<p>key是给每一个vnode的唯一id,可以依靠key,<code>更准确</code>, <code>更快</code>的拿到oldVnode中对应的vnode节点。<br>
更快 体现在：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。</p>
<h2 id="扩展"><strong>扩展</strong>：</h2>
<h3 id="diff算法">diff算法</h3>
<h3 id="vue源码">vue源码</h3>
<h1 id="第-2-题1-2-3mapparseint-what-why">第 2 题：['1', '2', '3'].map(parseInt) what &amp; why ?</h1>
<p>emm..map是es6中涉及到的方法，是指不重复的Key-value形式的数据，parseInt是....返回整数的，然并卵...orz🤒</p>
<h2 id="答案-2"><strong>答案</strong></h2>
<p>真正的答案是[1, NaN, NaN]<br>
这题的主要考察，还是arr.map（）方法，和parseInt，对它们一定要深入理解。下面附上MDN官方解释：<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()</a></li>
</ul>
<pre><code class="language-javascript">    var new_array = arr.map(function callback(currentValue[, index[, array]]) {     }[, thisArg])
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585987454821.png" alt="" width="400" height="300" loading="lazy"></figure>
<h3 id="map方法定义">map方法定义</h3>
<p>将数组中的值按顺序调用callback函数，然后由callback返回的数按顺序组成新数组；没有赋值或删除掉的索引不会调用。</p>
<h3 id="map方法使用">map方法使用</h3>
<p>map方法针对<code>新数组</code>的，<code>不会修改原数组</code>，若是对原数组进行操作则使用for-of或forEach。<br>
callback 函数会被自动传入三个参数：<code>数组元素</code>，<code>元素索引</code>，<code>原数组本身</code>。</p>
<p>🙄其实这里主要难度是parseInt，下面一起来研究下叭~<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a></li>
</ul>
<pre><code class="language-javascript">parseInt(string, radix);
</code></pre>
<p>将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。</p>
<h1 id="3原生js使用vuejs时的闪现问题">[3.]原生js使用vue.js时的闪现问题</h1>
<p>原生js中在使用到vue.js时，如使用<code>{{}}</code>会出现闪现问题，会先变成<code>{{message}}</code>显示在页面上，然后再变成需要显示的值。<br>
闪现问题是如何产生的？<br>
因为代码的执行顺序，先编译（编译template代码），再进行数据绑定。<br>
解决办法（2种）避免FOUC (Flash of Uncompiled Content)</p>
<h2 id="v-cloak">v-cloak</h2>
<p><code>v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。</code></p>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
    [v-cloak] {
      display: none;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;方法一: v-cloak&lt;/p&gt;
  &lt;!-- 页面加载数据时，原始代码会闪现一下
  加入一段css代码，在view上引用css模块 --&gt;
  &lt;!-- v-cloak 这个指令保持在元素上直到关联实例结束编译。 v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。--&gt;
  &lt;div id=&quot;app&quot; v-cloak&gt;    &lt;!-- &lt;div&gt; 不会显示，直到编译结束。--&gt;
    &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
    &lt;!-- 双括号会被编译成textNode的一个v-text指令 --&gt;
  &lt;/div&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
</code></pre>
<h2 id="v-text-取代">v-text 取代 {{}}</h2>
<pre><code class="language-html">&lt;body&gt;
    &lt;p&gt;方法二: v-text&lt;/p&gt;
    &lt;h1 v-text=&quot;message&quot;&gt;&lt;/h1&gt;
    &lt;h1 v-text=&quot;name&quot;&gt;&lt;/h1&gt;
  &lt;/div&gt;
    &lt;!-- vue中我们会将数据包在两个大括号中，然后放到HTML里，但是在vue内部，所有的双括号会被编译成textNode的一个v-text指令。
  而使用v-text的好处就是永远更好的性能，更重要的是可以避免FOUC (Flash of Uncompiled Content) ，也就是上面与遇到的问题。 --&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h1 id="4v-if-与-v-show">[4.]v-if 与 v-show</h1>
<p>区别：v-if 的那段代码为false就不编译了，为true才编译；而 v-show 的代码是一定会编译的<br>
使用场景：v-show用于标签切换更频繁的地方，v-if用于初始进行判断是否编译</p>
<h1 id="5computed-和-watch-的区别和运用的场景">[5.]computed 和 watch 的区别和运用的场景？</h1>
<p><strong>computed</strong> ：主要进行<strong>计算</strong>，依赖于其他属性，并且有缓存。只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。computed中的函数必须要用return返回；</p>
<ul>
<li>使用场景：当一个值受多个属性影响的时候————购物车商品结算<br>
<strong>watch</strong>：更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作，<strong>监听一个值的变化，然后执行对应的回调</strong>；<br>
<strong>运用场景：</strong></li>
<li>使用场景：当一条数据的更改影响到多条数据的时候————搜索框。需要监听属性时<br>
总结：</li>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h1 id="6直接给一个数组项赋值vue-能检测到变化吗">[6.]直接给一个数组项赋值，Vue 能检测到变化吗？</h1>
<p>由于 JavaScript 的限制，Vue <strong>不能</strong>检测到以下数组的变动：</p>
<p>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code><br>
当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></p>
<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<pre><code class="language-js">// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
 this.$set(this.tableData, this.idx, this.form);    //修改数组的值
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
this.item.splice(1,1,'xx')  //给数组中下标是1的位置添加一个新值‘xx’
</code></pre>
<p>为了解决第二个问题（修改数组长度——添加数据、删除数据），Vue 提供了以下操作方法：</p>
<pre><code class="language-js">// Array.prototype.splice
vm.items.splice(newLength)

var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2);         //从第 2 位开始删除所有元素
// 运算后的 myFish: [&quot;angel&quot;, &quot;clown&quot;]
// 被删除的元素: [&quot;mandarin&quot;, &quot;sturgeon&quot;]
</code></pre>
<h1 id="7vue-的父组件和子组件生命周期钩子函数执行顺序">[7.]Vue 的父组件和子组件生命周期钩子函数执行顺序？</h1>
<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><code>加载渲染过程</code>
<ul>
<li>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
</ul>
</li>
<li><code>子组件更新过程</code>
<ul>
<li>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
</ul>
</li>
<li><code>父组件更新过程</code>
<ul>
<li>父 beforeUpdate -&gt; 父 updated</li>
</ul>
</li>
<li><code>销毁过程</code>
<ul>
<li>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
</li>
</ul>
<h1 id="8在哪个生命周期内调用异步请求">[8.]在哪个生命周期内调用异步请求？</h1>
<p>分析：ajax就是异步请求，即相当于在问：在那个生命周期中调用ajax请求？<br>
可以在钩子函数<code>created、beforeMount、mounted</code>中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端返回的数据进行赋值。但是<code>推荐</code>在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h1 id="9在什么阶段才能访问操作dom">[9.]在什么阶段才能访问操作DOM？</h1>
<p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p>
<h1 id="10父组件可以监听到子组件的生命周期吗">[10.]父组件可以监听到子组件的生命周期吗？</h1>
<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<pre><code class="language-js">// Parent.vue
&lt;Child @mounted=&quot;doSomething&quot;/&gt;
    
// Child.vue
mounted() {
  this.$emit(&quot;mounted&quot;);
}
</code></pre>
<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 <code>@hook</code> 来监听即可，如下所示：</p>
<pre><code class="language-js">//  Parent.vue
&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     
</code></pre>
<p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h1 id="11谈谈你对-keep-alive-的了解">[11.]谈谈你对 keep-alive 的了解？</h1>
<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供<code>include</code> 和<code>exclude</code> 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
<ul>
<li><code>&lt;keep-alive :exclude=&quot;&quot;&gt;</code></li>
</ul>
</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h1 id="12组件中-data-为什么是一个函数">[12.]组件中 data 为什么是一个函数？</h1>
<blockquote>
<p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>
<pre><code class="language-js">// data
data() {
  return {
	message: &quot;子组件&quot;,
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '&lt;App/&gt;',
  components: {App}
})
</code></pre>
<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，<br>
如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；<br>
而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h1 id="13v-model-的原理">[13.]v-model 的原理</h1>
<p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input  表单元素为例：</p>
<pre><code class="language-html">&lt;input v-model='something'&gt;
</code></pre>
<p>相当于</p>
<pre><code class="language-html">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;
</code></pre>
<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：<br>
父组件：</p>
<pre><code class="language-html">&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-js">&lt;div&gt;{{value}}&lt;/div&gt;

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
},
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://cutezhangq.github.io/tag/gEYVGztSN/" class="tag">
                    面试
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://cutezhangq.github.io/post/git/">
                  <h3 class="post-title">
                    Git
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
