<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>js重点整理复习 | cutezhangq</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cutezhangq.github.io/favicon.ico?v=1595561180641">
<link rel="stylesheet" href="https://cutezhangq.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="js中的数据类型
js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型
👉基本数据类型：Number、String、Null、Undefined、Boolean
👉引用类型：Function、Array、Object..." />
    <meta name="keywords" content="js" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cutezhangq.github.io">
        <img src="https://cutezhangq.github.io/images/avatar.png?v=1595561180641" class="site-logo">
        <h1 class="site-title">cutezhangq</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cutezhangq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">js重点整理复习</h2>
            <div class="post-date">2020-06-16</div>
            
              <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/js.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
<!-- more -->
<p>当然有些可以合并，引用类型部分也可以归为Object类型一种，故也称7种数据类型（5+1+1）<br>
其中，基本数据类型存储的是实际数据的值；引用数据类型存储的是数据的引用（引用存储在<code>栈</code>里，实际内容存储在<code>堆</code>里）<br>
那么，为啥要分几种不同的数据类型呢？因为我们最终的目的是要使用数据来搞事情~😀，面对庞大的数据必然有许多重复，如果不分类的存储不然会造成混乱。这就需要我们对数据进行分类存储了。</p>
<!-- more -->
<ul>
<li>
<p>有的数据是直接存储起来，用的时候直接使用就行了，不需要对数据进行改变，这种类型的往往比较简单，所以统称为<strong>基本数据类型</strong>。</p>
</li>
<li>
<p>有的数据存储了之后，再进行使用需要对数据进行改动，可以原始数据就进行改动，也可只对引用的数据进行改动，这种情况就比较复杂了，所以对数据的结构就分出来栈和堆，栈中的数据指向堆中最终存储的数据。这种统称为<strong>引用数据类型</strong>。</p>
</li>
</ul>
<p>🔶局部变量存放在<code>栈</code>中(该方法中声明的变量随着栈的销毁而结束，局部变量只能在方法中有效)；<br>
🔷全局变量存放在<code>堆</code>中(不会随着某个方法执行结束而销毁)</p>
<!-- more -->
<p>那么分好了存储，接下来还要👊使用数据，一般是定义变量来使用存储的数据。但是因为存储类型不同，所以在使用<code>变量</code>定义数据是也有不同的特性(变量的类型是根据其内部存储的数据类型来决定的)：</p>
<ul>
<li>基本变量类型：一个变量要复制另一个变量时，采用 <code>深拷贝</code> ，会开辟一块新的内存空间进行存储，所以数据改变不影响原始数据。变量存放的就是数据值。</li>
<li>引用变量类型：给变量添加属性，采用 点 的方式。一个变量复制引用类型时，采用 <code>浅拷贝</code> ，所以数据改变会影响原数据的值。变量存放的是数据的引用（指针）。</li>
</ul>
<h1 id="不同数据类型之间的运算及比较">不同数据类型之间的运算及比较</h1>
<h2 id="和-的区别">=== 和 == 的区别</h2>
<p>===这种先比较数据的类型，再比较数据的值。<strong>类型</strong>和<strong>值</strong>要完全一样才相等。（不转换类型）<br>
==这种比较值，当类型不同，可先进行转换，<strong>转换完</strong>再比较<strong>值</strong>。<br>
注：==中转换情况如下几种情况：</p>
<ul>
<li><strong>String和Number</strong>：将String按照ASCII转换为数字再进行比较。</li>
<li><strong>Undefined和Null</strong>：这两个实际的值都是false，它们==是<strong>相等</strong>的。</li>
<li><strong>NaN</strong>：只能使用isNaN来检测类型。</li>
<li><strong>boolean与其他类型</strong>：boolean先转为 0 或 1 再进行比较。</li>
<li>如果是<strong>对象和数字比较</strong>：会将对象先转换为基础数据类型。js中🙆一般valueof优先于tostring类型，采用valueof内置类进行转换，🤷‍♀但在data中是tostring采用转换。</li>
</ul>
<p>😃注：即基本的数据类型间比较时，都是转为数字进行比较（ASCII码转）；涉及到对象这种引用变量时，则是转换为字符串进行比较。</p>
<h2 id="不同数据类型间运算">不同数据类型间运算</h2>
<ul>
<li>执行<code>- 、*、/、%</code> 运算时，都转换为数字进行运算。</li>
<li>执行<code>+</code>运算时，分为几种情况：
<ul>
<li>number + String --&gt;String</li>
<li>number + object --&gt;String ，优先调用tostring转换了
<ul>
<li>如：[1].toString() === '1'</li>
<li>如：{}.toString() === '[object Object]'</li>
</ul>
</li>
<li>number + null/boolean --&gt; <strong>数字</strong></li>
<li>number + undefined --&gt; <strong>NaN</strong></li>
</ul>
</li>
</ul>
<h2 id="和-和">&amp;&amp;和||、&amp;和|</h2>
<p>&amp;&amp;和||是逻辑运算符。</p>
<ul>
<li>
<p>&amp;&amp;表示逻辑与，当左边为真时，才执行右边；左边为假，不执行右边。（会短路）</p>
</li>
<li>
<p>| | 表示逻辑或，当左边为真时，执行左边；左边为假，执行右边。<br>
&amp;和|是位运算符。</p>
</li>
<li>
<p>&amp;表示与运算，转换为二进制逐位进行比较，相同位为1，不同位为0，最后输出的二进制再转为十进制输出最后结果。</p>
</li>
<li>
<p>| 表示或运算，转换为二进制逐位进行比较，只要位上有1就为1，位上都为0则为0，最后输出的二进制再转为十进制输出最后结果。<br>
注：&amp;还可以用来判断 奇偶:</p>
</li>
</ul>
<pre><code class="language-javascript">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="数据类型的判断">数据类型的判断</h1>
<p>👉基本数据类型中<strong>null</strong>：采用 <code>String（）</code> 判断<br>
👉<strong>基本数据类型</strong>中除了null的：采用 <code>typeof()</code> 判断<br>
👉<strong>引用数据类型</strong> 中如object、array、Data等：采用 <code>toString()</code> 判断<br>
一种很稳的判断数据类型方法：💖</p>
<pre><code class="language-javascript">let class2type = {};
'Array Date RegExp Object Error'.splice('').forEach(e =&gt; class2type['[object'+e+']'] = e.toLowerCase())
function type(obj){
    if(obj == null){
        return String(obj)
    }
    return typeof obj ==='object'?  class2type[Object.prototype.toString.call(obj)] || 'object': typeof(obj)
}
</code></pre>
<h1 id="如何判断一个变量是对象还是数组">如何判断一个变量是对象还是数组</h1>
<p>判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。</p>
<pre><code class="language-javascript">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>ps：千万不能使用typeof来判断对象和数组，因为这两种类型都会返回&quot;object&quot;。</p>
<h2 id="判断对象为空的3中方法">判断对象为空的3中方法</h2>
<ul>
<li>JSON.stringify(obj) == ‘{}’</li>
<li>for(var a in obj) == true</li>
<li>Object.keys(obj).length() == 0<br>
具体如下：</li>
</ul>
<pre><code class="language-javascript"> //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }

  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象

  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
  t = {};
  if(Object.keys(t).length == 0){   //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="不同数据类型的保存">不同数据类型的保存</h1>
<ul>
<li>基本数据类型：保存在 <code>堆</code>中</li>
<li>引用数据类型：保存在<code>栈</code>中</li>
<li>变量：可能是基本数据也可能是地址值。</li>
</ul>
<h1 id="内存-变量的生命周期">内存、变量的生命周期</h1>
<p>内存：是内存条通电后产生的一定的存储空间。<br>
变量的生命周期：当js引擎访问变量的时候，要经历：变量声明===》变量初始化===》变量赋值<br>
经历从 产生 到 销毁 的过程。<br>
🌰举例：<br>
<code>var</code>变量的生命周期：其中<strong>变量声明</strong>和<strong>变量初始化</strong>这2个阶段没有间隙，<br>
<code>函数声明</code>的生命周期：<strong>变量声明</strong>和<strong>变量初始化</strong>和<strong>变量赋值</strong>这3个阶段没有间隙，<br>
<code>let</code>:变量的生命周期：每段都有间隙，其中<strong>变量声明</strong>和<strong>变量初始化</strong>之间还有<strong>暂时性死区</strong></p>
<h2 id="为什么-提升-在let的生命周期里无效">为什么 提升 在let的生命周期里无效？</h2>
<p><code>提升：就是变量在作用域顶部进行 声明和初始化。</code><br>
因为let中每个阶段都有间隙，<strong>变量声明</strong>和<strong>变量初始化</strong>是解耦的（解耦让提升这个术语失效了），还存在暂时性死区，在这里，变量不能被访问。</p>
<h2 id="new的执行过程">new的执行过程</h2>
<p>1.创建一个对象<br>
2.将对象挂载到原型上<code>obj.__proto__ = Con.prototype</code><br>
3.this的指向<br>
4.返回新对象(如果构造函数有自己 retrun 时，则返回该值)</p>
<h1 id="对象">对象</h1>
<h2 id="访问对象内部数据的方法">访问对象内部数据的方法</h2>
<p>当访问json数据内部值时，一般采用 <code>点</code>的形式；当访问数组中数据时，一般采用<code>[ ]</code>的形式。<br>
其中，<strong>必须</strong>采用<code>[ ]</code>形式的情况有：属性中有特殊字符，如 - 空格 等的，有关键字的，是未定义的属性的。其余的都可采用这2中方式。</p>
<h2 id="创建对象的四种方法">创建对象的四种方法</h2>
<pre><code class="language-javascript">//1.采用系统的构造函数
var obj = new Object();
obj.name = 'zq';
obj.age = 20;
console.log(obj.name+','+obj.age);//zq,20

//2.自定义构造函数
function stu(name,age){
  this.name = name;
  this.age = age;
  this.mmm = 'koko';  //都是this.的形式，此处的this指代stu对象
  console.log(this.name+','+this.age);  //pk,22
}
var p1 = new stu('pk',22);  
console.log(p1.mmm);  //koko

//3.字面量形式
var tea = {
  name:'bobo',
  age:50,
  say:function(){
    console.log('hello js');
  }
}
console.log(tea.name);  //bobo
tea.say();  //hello js

//4.工厂模式    类似于封装了 系统的构造函数，批量生产对象
function createObject(name,age){
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  return obj; //别忘了返回
} 
var stu1 = createObject('stu1',12);
var stu2 = createObject('stu2',13);
console.log(stu1.name+','+stu1.age);//stu1,12
console.log(stu2.name+','+stu2.age);//stu2,13
</code></pre>
<h1 id="函数">函数</h1>
<h2 id="几种常见的回调函数">几种常见的回调函数</h2>
<p>👉dom中的回调函数</p>
<pre><code class="language-javascript"> //1.dom中时间回调函数，包括Node.js中的
  document.getElementById('btn').onclick = function(){
    console.log('诶呀，被点了!');
  }//诶呀，被点了!
</code></pre>
<p>👉定时器</p>
<pre><code class="language-javascript"> //2.定时器
  setTimeout(function(){
    console.log('我是一个定时器');
  },2000)
  console.log('——————');  
  //——————
  //我是一个定时器
</code></pre>
<p>👉ajax请求中的回调函数（包括promise）</p>
<pre><code class="language-javascript">  $.ajax({
    url:'xxx',
    type:'get',
    data:data,
    success:function(data){
      console.log(data);
    }
  })
</code></pre>
<p>👉生命周期中的回调函数</p>
<pre><code class="language-javascript">//如vue中的

</code></pre>
<h2 id="钩子函数和回调函数">钩子函数和回调函数</h2>
<p>两者都是事件处理函数，不同的是：<br>
<strong>钩子函数</strong>：函数<code>调用时触发</code>，本质上是监听函数。<br>
<strong>回调函数</strong>：函数调用<code>结束时触发</code>。</p>
<h2 id="iife">IIFE</h2>
<p>立即调用函数<br>
形式：<code>( 匿名函数自调用 )( )</code>        或者       <code>( 匿名函数自调用 )(参数)</code><br>
作用：</p>
<ul>
<li>隐藏内部内容代码</li>
<li>防止污染全局（外部）命名空间</li>
<li>进行js编码</li>
<li>解决闭包问题（闭包中变量一直无法释放，占用内存）</li>
</ul>
<p>其他几种也是立即执行函数</p>
<pre><code class="language-javascript">(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) () //用括号把函数包起来
!function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()
</code></pre>
<h2 id="函数声明与函数表达式">函数声明与函数表达式</h2>
<p>一、所能放置的 **位置 ** 不同<br>
函数声明：由于有<code>函数提升</code>，所以可以在任意地方声明</p>
<pre><code class="language-javascript">  fnName();
  //函数声明
  function fnName() { 
  }
  //正常，因为‘提升’了函数声明，函数调用可在函数声明之前
</code></pre>
<pre><code class="language-javascript">var fnName = function () {     
    alert('11');
  }();
    //函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数
</code></pre>
<p>二、是否 可以<strong>进行函数立即调用</strong></p>
<ul>
<li>函数声明不可以，只能以fnName()形式调用 。</li>
<li>函数表达式后面可以加括号立即调用该函数。</li>
</ul>
<h1 id="原型">原型</h1>
<h1 id="数组">数组</h1>
<h2 id="q如何对一个数组去重">Q：如何对一个数组去重？</h2>
<pre><code class="language-javascript">//1、Set结构去重。
let set = new Set([1,2,3,4,3,2,1,6,'1',NaN,NaN]);
console.log(set);
//Set(6)
// 0: 1
// 1: 2
// 2: 3
// 3: 4
// 4: 6
// 5: &quot;1&quot;
//6: NaN

//2、遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果。
let a = ['1','2','3',1,NaN,NaN,undefined,undefined,null,null, 'a','b','b'];
  let unique = arr =&gt;{
    let newA = [];
    arr.forEach(key =&gt; {
      if(newA.indexOf(key)&lt;0){  //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步
        newA.push(key);
      }
    });
    return newA;
  }
  console.log(unique(a)) ;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;]
  //ps:这个方法不能分辨NaN,会出现两个NaN。是有问题的，下面那个方法好一点。

  //3、遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，
  //以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。
//注意：这个方法会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想想还是Set去重最简单也最有效。
  let b = ['1', '2', '3', 1,NaN,NaN,undefined,undefined,null,null, 'a', 'b', 'b'];
  const unique2 = arr =&gt; {
        var obj = {}
        arr.forEach(value =&gt; {
            obj[value] = 0;//这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去
        })
        return Object.keys(obj);//`Object.keys(对象)`返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组
    }
    console.log(unique2(b));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://cutezhangq.github.io/tag/WVA2bQkO73/" class="tag">
                    js
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/">
                  <h3 class="post-title">
                    vue知识点理解
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
