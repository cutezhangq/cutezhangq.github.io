<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>js常规问题 | cutezhangq</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cutezhangq.github.io/favicon.ico?v=1597653239578">
<link rel="stylesheet" href="https://cutezhangq.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="本文收录了js中的一些常见的问题，涵盖了常见的知识点，一起来看看叭🙆
如：👉js中的数据类型、不同数据类型之间的运算及比较、数据类型的判断、如何判断一个变量是对象还是数组、不同数据类型的保存、内存、变量的生命周期、对象、 函数、原型原理..." />
    <meta name="keywords" content="js" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cutezhangq.github.io">
        <img src="https://cutezhangq.github.io/images/avatar.png?v=1597653239578" class="site-logo">
        <h1 class="site-title">cutezhangq</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/cutezhangq" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cutezhangq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">js常规问题</h2>
            <div class="post-date">2020-06-16</div>
            
              <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/js.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <p>本文收录了js中的一些常见的问题，涵盖了常见的知识点，一起来看看叭🙆<br>
如：👉js中的数据类型、不同数据类型之间的运算及比较、数据类型的判断、如何判断一个变量是对象还是数组、不同数据类型的保存、内存、变量的生命周期、对象、 函数、原型原理、数组、js中 new 操作符干了什么...😃</p>
<!-- more -->
<h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
<!-- more -->
<p>当然有些可以合并，引用类型部分也可以归为Object类型一种，故也称7种数据类型（5+1+1）<br>
其中，基本数据类型存储的是实际数据的值；引用数据类型存储的是数据的引用（引用存储在<code>栈</code>里，实际内容存储在<code>堆</code>里）<br>
那么，为啥要分几种不同的数据类型呢？因为我们最终的目的是要使用数据来搞事情~😀，面对庞大的数据必然有许多重复，如果不分类的存储不然会造成混乱。这就需要我们对数据进行分类存储了。</p>
<!-- more -->
<ul>
<li>
<p>有的数据是直接存储起来，用的时候直接使用就行了，不需要对数据进行改变，这种类型的往往比较简单，所以统称为<strong>基本数据类型</strong>。</p>
</li>
<li>
<p>有的数据存储了之后，再进行使用需要对数据进行改动，可以原始数据就进行改动，也可只对引用的数据进行改动，这种情况就比较复杂了，所以对数据的结构就分出来栈和堆，栈中的数据指向堆中最终存储的数据。这种统称为<strong>引用数据类型</strong>。</p>
</li>
</ul>
<p>🔶局部变量存放在<code>栈</code>中(该方法中声明的变量随着栈的销毁而结束，局部变量只能在方法中有效)；<br>
🔷全局变量存放在<code>堆</code>中(不会随着某个方法执行结束而销毁)</p>
<!-- more -->
<p>那么分好了存储，接下来还要👊使用数据，一般是定义变量来使用存储的数据。但是因为存储类型不同，所以在使用<code>变量</code>定义数据是也有不同的特性(变量的类型是根据其内部存储的数据类型来决定的)：</p>
<ul>
<li>基本变量类型：一个变量要复制另一个变量时，采用 <code>深拷贝</code> ，会开辟一块新的内存空间进行存储，所以数据改变不影响原始数据。变量存放的就是数据值。</li>
<li>引用变量类型：给变量添加属性，采用 点 的方式。一个变量复制引用类型时，采用 <code>浅拷贝</code> ，所以数据改变会影响原数据的值。变量存放的是数据的引用（指针）。</li>
</ul>
<h1 id="不同数据类型之间的运算及比较">不同数据类型之间的运算及比较</h1>
<h2 id="和-的区别">=== 和 == 的区别</h2>
<p>===这种先比较数据的类型，再比较数据的值。<strong>类型</strong>和<strong>值</strong>要完全一样才相等。（不转换类型）<br>
==这种比较值，当类型不同，可先进行转换，<strong>转换完</strong>再比较<strong>值</strong>。<br>
注：==中转换情况如下几种情况：</p>
<ul>
<li><strong>String和Number</strong>：将String按照ASCII转换为数字再进行比较。</li>
<li><strong>Undefined和Null</strong>：这两个实际的值都是false，它们==是<strong>相等</strong>的。</li>
<li><strong>NaN</strong>：只能使用isNaN来检测类型。</li>
<li><strong>boolean与其他类型</strong>：boolean先转为 0 或 1 再进行比较。</li>
<li>如果是<strong>对象和数字比较</strong>：会将对象先转换为基础数据类型。js中🙆一般valueof优先于tostring类型，采用valueof内置类进行转换，🤷‍♀但在data中是tostring采用转换。</li>
</ul>
<p>😃注：即基本的数据类型间比较时，都是转为数字进行比较（ASCII码转）；涉及到对象这种引用变量时，则是转换为字符串进行比较。</p>
<h2 id="不同数据类型间运算">不同数据类型间运算</h2>
<ul>
<li>执行<code>- 、*、/、%</code> 运算时，都转换为数字进行运算。</li>
<li>执行<code>+</code>运算时，分为几种情况：
<ul>
<li>number + String --&gt;String</li>
<li>number + object --&gt;String ，优先调用tostring转换了
<ul>
<li>如：[1].toString() === '1'</li>
<li>如：{}.toString() === '[object Object]'</li>
</ul>
</li>
<li>number + null/boolean --&gt; <strong>数字</strong></li>
<li>number + undefined --&gt; <strong>NaN</strong></li>
</ul>
</li>
</ul>
<h2 id="和-和">&amp;&amp;和||、&amp;和|</h2>
<p>&amp;&amp;和||是逻辑运算符。</p>
<ul>
<li>
<p>&amp;&amp;表示逻辑与，当左边为真时，才执行右边；左边为假，不执行右边。（会短路）</p>
</li>
<li>
<p>| | 表示逻辑或，当左边为真时，执行左边；左边为假，执行右边。<br>
&amp;和|是位运算符。</p>
</li>
<li>
<p>&amp;表示与运算，转换为二进制逐位进行比较，相同位为1，不同位为0，最后输出的二进制再转为十进制输出最后结果。</p>
</li>
<li>
<p>| 表示或运算，转换为二进制逐位进行比较，只要位上有1就为1，位上都为0则为0，最后输出的二进制再转为十进制输出最后结果。<br>
注：&amp;还可以用来判断 奇偶:</p>
</li>
</ul>
<pre><code class="language-javascript">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="数据类型的判断">数据类型的判断</h1>
<p>👉基本数据类型中<strong>null</strong>：采用 <code>String（）</code> 判断<br>
👉<strong>基本数据类型</strong>中除了null的：采用 <code>typeof()</code> 判断<br>
👉<strong>引用数据类型</strong> 中如object、array、Data等：采用 <code>toString()</code> 判断<br>
一种很稳的判断数据类型方法：💖</p>
<pre><code class="language-javascript">let class2type = {};
'Array Date RegExp Object Error'.splice('').forEach(e =&gt; class2type['[object'+e+']'] = e.toLowerCase())
function type(obj){
    if(obj == null){
        return String(obj)
    }
    return typeof obj ==='object'?  class2type[Object.prototype.toString.call(obj)] || 'object': typeof(obj)
}
</code></pre>
<h1 id="如何判断一个变量是对象还是数组">如何判断一个变量是对象还是数组</h1>
<p>判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。</p>
<pre><code class="language-javascript">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>ps：千万不能使用typeof来判断对象和数组，因为这两种类型都会返回&quot;object&quot;。</p>
<h2 id="判断对象为空的3中方法">判断对象为空的3中方法</h2>
<ul>
<li>JSON.stringify(obj) == ‘{}’</li>
<li>for(var a in obj) == true</li>
<li>Object.keys(obj).length() == 0<br>
具体如下：</li>
</ul>
<pre><code class="language-javascript"> //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }

  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象

  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
  t = {};
  if(Object.keys(t).length == 0){   //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="不同数据类型的保存">不同数据类型的保存</h1>
<ul>
<li>基本数据类型：保存在 <code>堆</code>中</li>
<li>引用数据类型：保存在<code>栈</code>中</li>
<li>变量：可能是基本数据也可能是地址值。</li>
</ul>
<h1 id="内存-变量的生命周期">内存、变量的生命周期</h1>
<p>内存：是内存条通电后产生的一定的存储空间。<br>
变量的生命周期：当js引擎访问变量的时候，要经历：变量声明===》变量初始化===》变量赋值<br>
经历从 产生 到 销毁 的过程。<br>
🌰举例：<br>
<code>var</code>变量的生命周期：其中<strong>变量声明</strong>和<strong>变量初始化</strong>这2个阶段没有间隙，<br>
<code>函数声明</code>的生命周期：<strong>变量声明</strong>和<strong>变量初始化</strong>和<strong>变量赋值</strong>这3个阶段没有间隙，<br>
<code>let</code>:变量的生命周期：每段都有间隙，其中<strong>变量声明</strong>和<strong>变量初始化</strong>之间还有<strong>暂时性死区</strong></p>
<h2 id="为什么-提升-在let的生命周期里无效">为什么 提升 在let的生命周期里无效？</h2>
<p><code>提升：就是变量在作用域顶部进行 声明和初始化。</code><br>
因为let中每个阶段都有间隙，<strong>变量声明</strong>和<strong>变量初始化</strong>是解耦的（解耦让提升这个术语失效了），还存在暂时性死区，在这里，变量不能被访问。</p>
<h2 id="new的执行过程">new的执行过程</h2>
<p>1.创建一个对象<br>
2.将对象挂载到原型上<code>obj.__proto__ = Con.prototype</code><br>
3.this的指向<br>
4.返回新对象(如果构造函数有自己 retrun 时，则返回该值)</p>
<h1 id="对象">对象</h1>
<h2 id="访问对象内部数据的方法">访问对象内部数据的方法</h2>
<p>当访问json数据内部值时，一般采用 <code>点</code>的形式；当访问数组中数据时，一般采用<code>[ ]</code>的形式。<br>
其中，<strong>必须</strong>采用<code>[ ]</code>形式的情况有：属性中有特殊字符，如 - 空格 等的，有关键字的，是未定义的属性的。其余的都可采用这2中方式。</p>
<h2 id="创建对象的四种方法">创建对象的四种方法</h2>
<pre><code class="language-javascript">//1.采用系统的构造函数
var obj = new Object();
obj.name = 'zq';
obj.age = 20;
console.log(obj.name+','+obj.age);//zq,20

//2.自定义构造函数
function stu(name,age){
  this.name = name;
  this.age = age;
  this.mmm = 'koko';  //都是this.的形式，此处的this指代stu对象
  console.log(this.name+','+this.age);  //pk,22
}
var p1 = new stu('pk',22);  
console.log(p1.mmm);  //koko

//3.字面量形式
var tea = {
  name:'bobo',
  age:50,
  say:function(){
    console.log('hello js');
  }
}
console.log(tea.name);  //bobo
tea.say();  //hello js

//4.工厂模式    类似于封装了 系统的构造函数，批量生产对象
function createObject(name,age){
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  return obj; //别忘了返回
} 
var stu1 = createObject('stu1',12);
var stu2 = createObject('stu2',13);
console.log(stu1.name+','+stu1.age);//stu1,12
console.log(stu2.name+','+stu2.age);//stu2,13
</code></pre>
<h1 id="函数">函数</h1>
<h2 id="几种常见的回调函数">几种常见的回调函数</h2>
<p>👉dom中的回调函数</p>
<pre><code class="language-javascript"> //1.dom中时间回调函数，包括Node.js中的
  document.getElementById('btn').onclick = function(){
    console.log('诶呀，被点了!');
  }//诶呀，被点了!
</code></pre>
<p>👉定时器</p>
<pre><code class="language-javascript"> //2.定时器
  setTimeout(function(){
    console.log('我是一个定时器');
  },2000)
  console.log('——————');  
  //——————
  //我是一个定时器
</code></pre>
<p>👉ajax请求中的回调函数（包括promise）</p>
<pre><code class="language-javascript">  $.ajax({
    url:'xxx',
    type:'get',
    data:data,
    success:function(data){
      console.log(data);
    }
  })
</code></pre>
<p>👉生命周期中的回调函数</p>
<pre><code class="language-javascript">//如vue中的

</code></pre>
<h2 id="钩子函数和回调函数">钩子函数和回调函数</h2>
<p>两者都是事件处理函数，不同的是：<br>
<strong>钩子函数</strong>：函数<code>调用时触发</code>，本质上是监听函数。<br>
<strong>回调函数</strong>：函数调用<code>结束时触发</code>。</p>
<h2 id="iife">IIFE</h2>
<p>立即调用函数<br>
形式：<code>( 匿名函数自调用 )( )</code>        或者       <code>( 匿名函数自调用 )(参数)</code><br>
作用：</p>
<ul>
<li>隐藏内部内容代码</li>
<li>防止污染全局（外部）命名空间</li>
<li>进行js编码</li>
<li>解决闭包问题（闭包中变量一直无法释放，占用内存）</li>
</ul>
<p>其他几种也是立即执行函数</p>
<pre><code class="language-javascript">(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) () //用括号把函数包起来
!function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()
</code></pre>
<h2 id="函数声明与函数表达式">函数声明与函数表达式</h2>
<p>一、所能放置的 **位置 ** 不同<br>
函数声明：由于有<code>函数提升</code>，所以可以在任意地方声明</p>
<pre><code class="language-javascript">  fnName();
  //函数声明
  function fnName() { 
  }
  //正常，因为‘提升’了函数声明，函数调用可在函数声明之前
</code></pre>
<pre><code class="language-javascript">var fnName = function () {     
    alert('11');
  }();
    //函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数
</code></pre>
<p>二、是否 可以<strong>进行函数立即调用</strong></p>
<ul>
<li>函数声明不可以，只能以fnName()形式调用 。</li>
<li>函数表达式后面可以加括号立即调用该函数。</li>
</ul>
<h1 id="原型原理">原型原理</h1>
<p>1、所有的 引用类型 都有一个_ _ proto_ _ 属性     ( 隐式原型)。<br>
它们的_ _ proto_ <em>属性指向 它的构造函数 的 prototype 属性。<br>
如果对象本身不存在这个属性，那么会去它的</em> _ proto_ _属性 (也就是 它的构造函数的 prototype 属性) 中寻找。<br>
如：girl 的name,sayHello属性，最终是到它的构造函数（Person）的 prototype  属性中寻找</p>
<pre><code class="language-js">function Person(name,age){
      this.name = name;
      this.age = age;
      this.sayHello = function(){
          console.log(this.name + &quot; say hello&quot;);
      }
  }
  var girl = new Person(&quot;bella&quot;,23);
  console.log(girl.name);  //bella
  girl.sayHello(); //bella say hello

</code></pre>
<p>2、所有的 函数 都有一个 prototype 属性    ( 显式原型)。<br>
（prototype既是属性也是对象）这个属性是在 函数创建 的时候添加上的（定义函数的时候）</p>
<p>引用类型： 由类型的实际值引用（类似于指针）表示的数据类型（数组、对象、函数）<br>
构造函数：主要用来在 创建对象时 初始化 对象， 即为 对象成员变量 赋初始值，总与new运算符一起使用在创建对象的语句中。a = new people()<br>
一个类可以有多个构造函数 ，可根据其参数个数的不同 或 参数类型的不同来区分它们----&gt;构造函数的重载。<br>
实例化：用 类 创建对象的过程， 是将一个抽象的概念类，具体到该类实物的过程。<br>
var boy = new Person( );<br>
实例： 通过构造函数和 new 创建出来的对象，便是实例。</p>
<pre><code class="language-js">这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --&gt; true
// o.__proto__ = null;
// o.constructor === Object   --&gt; false
</code></pre>
<p><code>原型、构造函数、实例 关系 图解：</code><br>
<img src="https://cutezhangq.github.io/post-images/1596356775494.png" alt="" loading="lazy"></p>
<p>结论：<br>
1.对象的隐式原型的值__proto__为其 对应 构造函数的显式原型prototype 的值 ——&gt; 实例的__protp__和构造函数的prototype 都是指向原型的</p>
<pre><code class="language-js">function Person(name,height){
     this.name=name;
 }
var boy = new Person('keith');
console.log(boy.__proto__ === Person.prototype);     //true
</code></pre>
<p>通过 调用构造函数 产生的 实例对象，都拥有一个 内部属性，指向了原型对象。<br>
实例对象 能够访问 原型对象上 的所有属性和方法（继承）。(girl 能访问 Person 的所有属性和方法)<br>
如：构造函数：    Person()<br>
原型：         girl 的 <strong>proto</strong>    、Person.prototype<br>
实例对象：   girl<br>
<img src="https://cutezhangq.github.io/post-images/1596356885891.png" alt="" loading="lazy"><br>
<code>原型链 图示：</code></p>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596356873816.png" alt="" loading="lazy"></figure>
<p>使用 原型 自定义方法：</p>
<pre><code class="language-js">
1.prototype属性 指向：
    每个函数 都有一个prototype属性，它默认指向一个object 空对象（原型对象），Object最终是指向 null 空对象的
        如：Date.prototype  返回的是object    
               function.prototype  返回的也是object   
    原型对象 中有一个 属性constructor ,它指向 函数对象（先指向 构造函数，然后 构造函数 最终指向函数对象）
          如：console.log(Person)
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596356964474.png" alt="" loading="lazy"><br>
2.给原型对象添加属性（一般都是方法）<br>
作用：函数的 所有实例对象 自动拥有 原型中的属性（方法）<br>
原型上面的方法是给实例对象使用的<br>
3.prototype与constructor的关系：    相互引用<br>
<img src="https://cutezhangq.github.io/post-images/1596357057951.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1596357062445.png" alt="" loading="lazy"></p>
<p>4.prototype与__proto__的关系：<br>
怎么让两个引用变量指向同一个对象？（如下图）<br>
让一个引用变量 赋值 给另一个引用变量<br>
<img src="https://cutezhangq.github.io/post-images/1596357094861.png" alt="" loading="lazy"><br>
注：new Fn( ) 就是在实例化对象，实例对象的___proto__属性是 js引擎自动添加的</p>
<p>5.原型链 （隐式原型链）<br>
定义：原型链是由原型对象组成，每个对象都有 <strong>proto</strong> 属性，指向了创建该对象的构造函数的原型，<strong>proto</strong> 将对象连接起来组成了原型链。</p>
<p>作用： 共享属性：访问 一个对象的属性<br>
实现继承 ：构造函数的实例对象自动拥有构造函数原型对象的方法（属性）<br>
空Object的原型对象（null） 是原型链的尽头<br>
属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；<br>
属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。<br>
<img src="https://cutezhangq.github.io/post-images/1596357121592.png" alt="" loading="lazy"><br>
原型链的 属性 问题：1.读取对象 的属性值时，会自动到原型链中查找2.设置对象 的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值3.方法 一般定义在原型中，属性一般通过构造函数定义在对象本身上理解：函数的 prototype属性：在定义函数时 自动添加，默认值是一个空object对象对象的 ___proto__属性：创建对象时 自动添加（产生的）,执行语句this.<strong>proto</strong> = Fn.prototype      ,默认值为构造函数的prototype属性值  程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）   :Foo.prototype={ XXX:YYY  }函数大概像抽象的类，是一个高度概括的封装体；                               （抽象的概括）对象则是某个具体的实例，可以使用抽象体的某些特性，通过 对象 点  的方式使用。    （具体的使用）    所以，在使用对象之前要 构造函数 ，即初始化对象   ，相当于创建出一个具体的实例（new 一个对象）              因为：fun = new Function时 自身的显式原型（构造函数）和隐式原型（实例对象）是相等的</p>
<p>判断某个属性是否 属于原型</p>
<pre><code class="language-js">//判断某个属性是否属于原型
function hasPropertyPrototype(object,name){
  return !object.hasOwnProperty(name) &amp;&amp; (name in object);    //不是object原型上的，但是能在原型链上找到
}
</code></pre>
<h1 id="数组">数组</h1>
<h2 id="q如何对一个数组去重">Q：如何对一个数组去重？</h2>
<pre><code class="language-javascript">//1、Set结构去重。
let set = new Set([1,2,3,4,3,2,1,6,'1',NaN,NaN]);
console.log(set);
//Set(6)
// 0: 1
// 1: 2
// 2: 3
// 3: 4
// 4: 6
// 5: &quot;1&quot;
//6: NaN

//2、遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果。
let a = ['1','2','3',1,NaN,NaN,undefined,undefined,null,null, 'a','b','b'];
  let unique = arr =&gt;{
    let newA = [];
    arr.forEach(key =&gt; {
      if(newA.indexOf(key)&lt;0){  //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步
        newA.push(key);
      }
    });
    return newA;
  }
  console.log(unique(a)) ;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;]
  //ps:这个方法不能分辨NaN,会出现两个NaN。是有问题的，下面那个方法好一点。

  //3、遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，
  //以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。
//注意：这个方法会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想想还是Set去重最简单也最有效。
  let b = ['1', '2', '3', 1,NaN,NaN,undefined,undefined,null,null, 'a', 'b', 'b'];
  const unique2 = arr =&gt; {
        var obj = {}
        arr.forEach(value =&gt; {
            obj[value] = 0;//这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去
        })
        return Object.keys(obj);//`Object.keys(对象)`返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组
    }
    console.log(unique2(b));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]
</code></pre>
<h1 id="js中-new-操作符干了什么">js中 new 操作符干了什么？</h1>
<ul>
<li>
<ol>
<li>创建了一个空对象</li>
</ol>
</li>
<li>
<ol start="2">
<li>将空对象赋值给this，并将this的__proto__指向构造方法对象的原型</li>
</ol>
</li>
<li>
<ol start="3">
<li>对this这个对象进行属性的添加，并初始化</li>
</ol>
</li>
<li>
<ol start="4">
<li>将this对象返回</li>
</ol>
</li>
</ul>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://cutezhangq.github.io/tag/WVA2bQkO73/" class="tag">
                    js
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://cutezhangq.github.io/post/js-bian-liang-de-sheng-ming-zhou-qi-letvarconst/">
                  <h3 class="post-title">
                    变量的生命周期 let、var、const
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
