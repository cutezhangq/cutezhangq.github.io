<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>排序算法（上） | cutezhangq</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cutezhangq.github.io/favicon.ico?v=1598754481615">
<link rel="stylesheet" href="https://cutezhangq.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="前端常见的排序算法，共有10种😘



（一）：冒泡排序

冒泡排序（Bubble Sort）是一种简单直观的排序算法。冒泡排序算法的步骤描述如下：（相邻元素 比较 交换位置）

比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对..." />
    <meta name="keywords" content="算法" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cutezhangq.github.io">
        <img src="https://cutezhangq.github.io/images/avatar.png?v=1598754481615" class="site-logo">
        <h1 class="site-title">cutezhangq</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/cutezhangq" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cutezhangq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">排序算法（上）</h2>
            <div class="post-date">2020-08-30</div>
            
            <div class="post-content" v-pre>
              <p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<p><img src="https://cutezhangq.github.io/post-images/1598754120978.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1598754150521.png" alt="" loading="lazy"></p>
<h1 id="一冒泡排序">（一）：冒泡排序</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1598754182443.png" alt="" loading="lazy"></figure>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。冒泡排序算法的步骤描述如下：（<strong>相邻元素 比较 交换位置</strong>）</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="具体实现">具体实现：</h3>
<pre><code class="language-js"> //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}  

</code></pre>
<p>案例：</p>
<pre><code class="language-js">  //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
  var bubbleSort = function(arr){
    var i,j,m;
    var len = arr.length;
    if(len &lt;= 1){
      return arr;
    }

    for(i = 0;i&lt;len - 1;i++){ //循环2层：两两比较
      for(j=0;j&lt;len-1;j++){
        if(arr[j] &gt; arr[j+1]){  //当前一个比后一个大了
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
      console.log(`第${i+1}次循环————`, arr);
    }
    return arr;
  }
const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————冒泡排序——————',bubbleSort(testArr));
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598754314075.png" alt="" loading="lazy"></figure>
<h2 id="优化单向冒泡实现">优化：单向冒泡实现</h2>
<p>如果数组原本的顺序就是冒泡的，又或者仅做完前面寥寥几次就已经达到效果了，那后续的比较工作就显得有些多余了，如何对以上算法进行改进？<br>
我们可以在某一轮的循环比较结束后，<strong>如果没有发生任何的元素交换，则可以认为该数组已经达到预期效果，不必再继续下一轮的比较了</strong>。</p>
<pre><code class="language-js">var bubbleSort2 = function(arr){
  var start = + new Date();
  var i,j,m,noswap; //noswap没有交换
  var len = arr.length;
  if(len &lt;= 1){
    return arr;
  }

  for(i=0;i&lt;len-1;i++){
    noswap = true;  //未交换
    for(j=0;j&lt;len-1;j++){
      if(arr[j] &gt; arr[j+1]){  
          m = arr[j];         
          arr[j] = arr[j+1];
          arr[j+1] = m;
          noswap = false; //交换了
        }
    }
    if(noswap){
      break;
    }
  }
  // 当 arr 的长度越长，时间差越明显
  console.log(+new Date() - start);
  return arr;
}
const testArr2 = [11,4,6,52,3,20,1,9,2,5,19,3,6,21,105,22,33,44,88,22,1,2,0,3,9,4,100,103,98]
console.log('————改进版冒泡排序——————',bubbleSort2(testArr2));
// 0
// ————改进版冒泡排序—————— (29) [0, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 6, 9, 9, 11, 19, 20, 21, 22, 22, 33, 
44, 52, 88, 98, 100, 103, 105]

</code></pre>
<h2 id="优化双向冒泡实现">优化：双向冒泡实现</h2>
<p>普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，双向冒泡排序则是<code>多一轮的筛选</code>，即找出<code>最大值也找出最小值</code>。</p>
<pre><code class="language-js"> //算法改进————————双向冒泡实现
    // 普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，
    // 双向冒泡排序则是多一轮的筛选，即找出最大值也找出最小值。
  let testArr3 = [1, 6, 7, 4, 5, 8, 9, 0, 2, 3];
  let res = bubbleSortTow(testArr3)
  console.log(res);

  function bubbleSortTow(arr) {
    let low = 0;
    let high = arr.length - 1;
    while(low &lt; high){
      let mark = true;
      // 找到最大值放到右边
      for (let i = low; i &lt; high; i++) {
        if (arr[i] &gt; arr[i + 1]) {
          [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
          mark = false;
        }
      }
      high--;
      // 找到最小值放到左边
      for (let j = high; j &gt; low; j--) {
        if (arr[j] &lt; arr[j - 1]) {
          [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
          mark = false;
        }
      }
      low++;
      console.log(mark);
      console.log(`第${low}次循环`, arr);
      if (mark) 
        return arr;
    }
  }
</code></pre>
<h3 id="性能比较">性能比较</h3>
<p>对三种排序的算法进行性能的比较：发现<br>
<code>单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 大于普通冒泡性能。</code>（产生时间具体取决于所使用的系统）</p>
<h3 id="时间度复杂度分析">时间度复杂度分析:</h3>
<figure data-type="image" tabindex="3"><img src="https://cutezhangq.github.io/post-images/1598754429691.png" alt="" loading="lazy"></figure>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://cutezhangq.github.io/tag/KFImbiYP6/" class="tag">
                    算法
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://cutezhangq.github.io/post/luo-ji-ti/">
                  <h3 class="post-title">
                    逻辑题
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
