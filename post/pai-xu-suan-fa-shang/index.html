<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>排序算法（上） | cutezhangq</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cutezhangq.github.io/favicon.ico?v=1600413163897">
<link rel="stylesheet" href="https://cutezhangq.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="前端常见的排序算法，共有10种😘



（一）：冒泡排序

冒泡排序（Bubble Sort）是一种简单直观的排序算法。冒泡排序算法的步骤描述如下：（相邻元素 比较 交换位置）

比较相邻的元素。如果第一个比第二个大，就交换他们两个。
对..." />
    <meta name="keywords" content="算法" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cutezhangq.github.io">
        <img src="https://cutezhangq.github.io/images/avatar.png?v=1600413163897" class="site-logo">
        <h1 class="site-title">cutezhangq</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/cutezhangq" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cutezhangq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">排序算法（上）</h2>
            <div class="post-date">2020-08-27</div>
            
              <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/pai-xu-suan-fa-shang.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<p><img src="https://cutezhangq.github.io/post-images/1598754120978.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1598754150521.png" alt="" loading="lazy"></p>
<h1 id="一冒泡排序">（一）：冒泡排序</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1598754182443.png" alt="" loading="lazy"></figure>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。冒泡排序算法的步骤描述如下：（<strong>相邻元素 比较 交换位置</strong>）</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="具体实现">具体实现：</h3>
<pre><code class="language-js"> //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}  

</code></pre>
<p>案例：</p>
<pre><code class="language-js">  //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
  var bubbleSort = function(arr){
    var i,j,m;
    var len = arr.length;
    if(len &lt;= 1){
      return arr;
    }

    for(i = 0;i&lt;len - 1;i++){ //循环2层：两两比较
      for(j=0;j&lt;len-1;j++){
        if(arr[j] &gt; arr[j+1]){  //当前一个比后一个大了
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
      console.log(`第${i+1}次循环————`, arr);
    }
    return arr;
  }
const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————冒泡排序——————',bubbleSort(testArr));
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598754314075.png" alt="" loading="lazy"></figure>
<h2 id="优化单向冒泡实现">优化：单向冒泡实现</h2>
<p>如果数组原本的顺序就是冒泡的，又或者仅做完前面寥寥几次就已经达到效果了，那后续的比较工作就显得有些多余了，如何对以上算法进行改进？<br>
我们可以在某一轮的循环比较结束后，<strong>如果没有发生任何的元素交换，则可以认为该数组已经达到预期效果，不必再继续下一轮的比较了</strong>。</p>
<pre><code class="language-js">var bubbleSort2 = function(arr){
  var start = + new Date();
  var i,j,m,noswap; //noswap没有交换
  var len = arr.length;
  if(len &lt;= 1){
    return arr;
  }

  for(i=0;i&lt;len-1;i++){
    noswap = true;  //未交换
    for(j=0;j&lt;len-1;j++){
      if(arr[j] &gt; arr[j+1]){  
          m = arr[j];         
          arr[j] = arr[j+1];
          arr[j+1] = m;
          noswap = false; //交换了
        }
    }
    if(noswap){
      break;
    }
  }
  // 当 arr 的长度越长，时间差越明显
  console.log(+new Date() - start);
  return arr;
}
const testArr2 = [11,4,6,52,3,20,1,9,2,5,19,3,6,21,105,22,33,44,88,22,1,2,0,3,9,4,100,103,98]
console.log('————改进版冒泡排序——————',bubbleSort2(testArr2));
// 0
// ————改进版冒泡排序—————— (29) [0, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 6, 9, 9, 11, 19, 20, 21, 22, 22, 33, 
44, 52, 88, 98, 100, 103, 105]

</code></pre>
<h2 id="优化双向冒泡实现">优化：双向冒泡实现</h2>
<p>普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，双向冒泡排序则是<code>多一轮的筛选</code>，即找出<code>最大值也找出最小值</code>。</p>
<pre><code class="language-js"> //算法改进————————双向冒泡实现
    // 普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，
    // 双向冒泡排序则是多一轮的筛选，即找出最大值也找出最小值。
  let testArr3 = [1, 6, 7, 4, 5, 8, 9, 0, 2, 3];
  let res = bubbleSortTow(testArr3)
  console.log(res);

  function bubbleSortTow(arr) {
    let low = 0;
    let high = arr.length - 1;
    while(low &lt; high){
      let mark = true;
      // 找到最大值放到右边
      for (let i = low; i &lt; high; i++) {
        if (arr[i] &gt; arr[i + 1]) {
          [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
          mark = false;
        }
      }
      high--;
      // 找到最小值放到左边
      for (let j = high; j &gt; low; j--) {
        if (arr[j] &lt; arr[j - 1]) {
          [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
          mark = false;
        }
      }
      low++;
      console.log(mark);
      console.log(`第${low}次循环`, arr);
      if (mark) 
        return arr;
    }
  }
</code></pre>
<h3 id="性能比较">性能比较</h3>
<p>对三种排序的算法进行性能的比较：发现<br>
<code>单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 大于普通冒泡性能。</code>（产生时间具体取决于所使用的系统）</p>
<h3 id="时间度复杂度分析">时间度复杂度分析:</h3>
<figure data-type="image" tabindex="3"><img src="https://cutezhangq.github.io/post-images/1598754429691.png" alt="" loading="lazy"></figure>
<!-- more -->
<h1 id="二选择排序">（二）：选择排序</h1>
<h3 id="算法介绍">算法介绍</h3>
<p>打个比方，喜欢短线炒股的朋友，习惯短时间内不断地买进卖出，通过价差来实现盈利。<br>
但是通常如此频繁操作，即使失误不多，也会因为操作的手续费和印花税而获利较少。<br>
另外一种长线炒股的朋友，习惯长时间持有，不断地观察和判断，时机一到便果断买进或卖出，交易次数少，收益颇丰。<br>
上一节说的冒泡排序就类似于短线炒股，不断地比较之后进行交换，完成排序。<br>
而本节所要讲解的简单选择排序，类似于长线炒股，虽然也在不断地观察比较，但是会在合适的时机进行交换，并且只移动一次就完成相应关键字的排序定位工作。这就是选择排序法的初步思想。<br>
<code>依次找到剩余元素的 最小值或者最大值，放置在 末尾或者开头。</code></p>
<h3 id="算法图示">算法图示：</h3>
<ul>
<li>第一趟：如下图，先选择1和9，比较，1&lt;9，所以将1放在前面，9放在后面，然后再拿着9和剩下的数组中比较；</li>
<li>第二趟：在剩下的数组中找到最小值，是2，拿2和9比较，2&lt;9，将2放前面，9放在原来2的位置，然后再拿着9和剩下的数组中比较；</li>
<li>第三趟：在剩下的数组中找到最小值，是3，拿3和9比较，3&lt;9，将3放前面，9放在原来3的位置，然后再拿着3和剩下的数组中比较；</li>
<li>第四趟：在剩下的数组中找到最小值，是4，拿4和3比较，4&gt;3，依旧将3放前面，4放在3的后面位置，然后再拿着4和剩下的数组中比较；</li>
<li>第五趟：在剩下的数组中找到最小值，是5，拿5和4比较，5&gt;4，依旧将4放前面，5放在4的后面位置（与7交互），然后再拿着7和剩下的数组中比较；</li>
<li>第六趟： 在剩下的数组中找到最小值，是5，拿5和7比较，5&lt;7，将5放前面，7放在原来5的位置，然后再拿着5和剩下的数组中比较；</li>
<li>第七趟：在剩下的数组中找到最小值，是6，拿6和5比较，6&gt;5，依旧将5放前面，6放在5的后面位置，然后再拿着6和剩下的数组中比较；</li>
<li>第八趟：在剩下的数组中找到最小值，是7，拿7和6比较，7&gt;6，依旧将6放前面，7放在6的后面位置，然后再拿着8和剩下的数组中比较；</li>
<li>第九趟：在剩下的数组中找到最小值，是9，拿9和8比较，9&gt;8，依旧将8放前面，9放在8的后面位置，剩下数组为空</li>
<li>排序结束.....</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://cutezhangq.github.io/post-images/1598770578518.png" alt="" loading="lazy"></figure>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。选择排序算法的步骤描述如下：</p>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<pre><code class="language-js">//选择排序算法
  function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i; //最小数的索引
        for (var j = i + 1; j &lt; len; j++) {   //依次查找剩余元素
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];    //将选出的元素放到末尾
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}   


const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————选择排序——————',selectionSort(testArr));
 //(14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="复杂度分析">复杂度分析</h3>
<figure data-type="image" tabindex="5"><img src="https://cutezhangq.github.io/post-images/1598770628327.png" alt="" loading="lazy"></figure>
<h3 id="性能比较-2">性能比较</h3>
<p>对于等量的数据进行性能比价，发现单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; <code>选择排序</code> &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="提示">提示</h3>
<p>选择排序是时间复杂度上表现最稳定的算法之一，因为最快、最慢时间复杂度都是O(n²)，用选择排序数据量越小越好</p>
<!-- more -->
<h1 id="三直接插入排序">（三）：直接插入排序</h1>
<h3 id="算法介绍-2">算法介绍</h3>
<p>我们都应该玩过扑克牌了，游戏期间玩家们基本上都是一边摸牌一边理牌，会把牌面值小的牌放到左边，牌面值大的牌放到右边，以升序进行排序（当然也有喜欢降序排序的玩家）。<br>
而理牌期间，我们习惯从左往右看牌面值大小，两两比较，将牌抽出，插入到合理的位置。<br>
这里我们理牌的方法，就是「直接插入排序法」。<br>
直接插入排序法的基本操作是<code>将一个元素插入到已经排好序的数组中，从而得到一个新的、Unicode 值递增的数组。</code></p>
<h3 id="算法图示-2">算法图示：</h3>
<figure data-type="image" tabindex="6"><img src="https://cutezhangq.github.io/post-images/1598770756271.png" alt="" loading="lazy"></figure>
<h3 id="分析">分析：</h3>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>
插入排序算法的步骤描述如下：<br>
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>
从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。<br>
（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<pre><code class="language-js">  //插入排序
  function insertionSort(arr){
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
      preIndex = i - 1;   //前一个元素下标
      current = arr[i];   //当前元素
      while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
        arr[preIndex+1] = arr[preIndex];  //将前一个元素往后挪动一位
        preIndex--;     //继续循环遍历
      }
      arr[preIndex+1] = current;    //之前preIndex--了，所以这里要+1
    }
    return arr;
  }


 const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
 console.log('————选择排序——————',insertionSort(testArr));
 //————选择排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
</code></pre>
<pre><code class="language-js"> var insertSort2 = function(arr){
  var i, j, m, mCnt=0;    //m:更小的元素    mCnt:移动的次数
  var len = arr.length;

  for (i=1; i&lt;len; i++) {
    if (arr[i] &lt; arr[i-1]) {    //后面的元素比前面的更小
      // 将更小的那个元素保存起来
      m = arr[i];
      for (j=i-1; arr[j]&gt;m; j--) {
        //将前一个元素往后挪动一位
        arr[j+1] = arr[j];
        mCnt++;
      }
      // console.log('移动了 '+mCnt+' 次');
      mCnt = 0;
      // 直接插入
      arr[j+1] = m;
    }
  }

  return arr;
};


console.log(insertSort2([5,4,3,2,1])) 
//(5) [1, 2, 3, 4, 5]
console.log(insertSort2([3, 2, 1, 7, 8, 9, 0]))
//(7) [0, 1, 2, 3, 7, 8, 9]
</code></pre>
<h3 id="复杂度分析-2">复杂度分析</h3>
<figure data-type="image" tabindex="7"><img src="https://cutezhangq.github.io/post-images/1598770822597.png" alt="" loading="lazy"></figure>
<h2 id="优化拆半插入排序">优化：拆半插入排序</h2>
<pre><code class="language-js">//优化：拆半插入排序实现
  //在直接插入排序的基础上，在插入的时候运用了折半查找法查找要插入的位置，再进行插入。
  let array = [11,4,6,52,3,20,1,9,2,5,19,3,6,21];
  for (let i = 0; i &lt; 10; i++) {
      let number = Math.floor(Math.random() * 10);
      array.push(number);
  }
  let res = this.binsertSort(array);
  console.log(res);
   /**
     * 拆半插入排序
     */
  function binsertSort(arr) {
      let low, high, j, temp;
      for (let i = 1; i &lt; arr.length; i++) {
          if (arr[i] &lt; arr[i - 1]) {
              temp = arr[i];
              low = 0;
              high = i - 1;
              while (low &lt;= high) {
                  let mid = Math.floor((low + high) / 2);
                  if (temp &gt; arr[mid]) {
                      low = mid + 1;
                  } else {
                      high = mid - 1;
                  }
              }
              for (j = i; j &gt; low; --j) {
                  arr[j] = arr[j - 1];
              }
              arr[j] = temp;
          }
          console.log(`第${i}次循环`, arr);
      }
      return arr;
  }

//(24) [0, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="性能比较表示性能相差不大">性能比较&gt;=表示性能相差不大</h3>
<p>在数据量相当的情况下：发现拆半插入排序 &gt;= 单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; <code>插入排序</code> &gt; 选择排序 &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="提示-2">提示</h3>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了。</p>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://cutezhangq.github.io/tag/KFImbiYP6/" class="tag">
                    算法
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://cutezhangq.github.io/post/luo-ji-ti/">
                  <h3 class="post-title">
                    逻辑题
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
