<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>谈谈深拷贝、浅拷贝 | cutezhangq</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://cutezhangq.github.io/favicon.ico?v=1600160893964">
<link rel="stylesheet" href="https://cutezhangq.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="js对象不像变量那样，简单的赋值就能进行克隆的，对象进行赋值时，只是创建了一个新的指针指向相同的存储空间。👀如果不想改变原数据，那么就要对对象进行深克隆了

var a={a:1}
var b=a;
b.a=2

这时输出a你会发现，a的..." />
    <meta name="keywords" content="ES" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://cutezhangq.github.io">
        <img src="https://cutezhangq.github.io/images/avatar.png?v=1600160893964" class="site-logo">
        <h1 class="site-title">cutezhangq</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/cutezhangq" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://cutezhangq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">谈谈深拷贝、浅拷贝</h2>
            <div class="post-date">2020-01-07</div>
            
              <div class="feature-container" style="background-image: url('https://cutezhangq.github.io/post-images/tan-tan-shen-kao-bei-qian-kao-bei.jpg')">
              </div>
            
            <div class="post-content" v-pre>
              <p>js对象不像变量那样，简单的赋值就能进行克隆的，对象进行赋值时，只是创建了一个新的指针指向相同的存储空间。👀如果不想改变原数据，那么就要对对象进行深克隆了</p>
<!-- more -->
<pre><code class="language-js">var a={a:1}
var b=a;
b.a=2
</code></pre>
<p>这时输出a你会发现，a的值同样发生了改变。<br>
这一点在你进行数据操作时，又想保留原来数据时，你就需要深度克隆了。</p>
<h1 id="怎么深拷贝一个对象深拷贝一个对象的时候应该怎么做">怎么深拷贝一个对象？（深拷贝一个对象的时候应该怎么做？）</h1>
<p>深度克隆的方法:</p>
<h1 id="1-js序列化">1、js序列化</h1>
<p>将js转换成字符串，然后再将字符串转换成js对象。<br>
js字符串的克隆就比对象的克隆简单多了。简单的赋值操作就能完成。<br>
深拷贝,但拷贝的数据里不能有函数，不然处理不了</p>
<pre><code class="language-js">var obj = {a:1};
var str = JSON.stringify(obj); //序列化对象         JSON.stringify() 方法将一个JavaScript 对象或值转换为JSON 字符串
var newobj = JSON.parse(str); //还原
var b = newobj;
b.a = 2;
console.log(obj.a); // 1
console.log(b.a);   // 2 
</code></pre>
<blockquote>
<p>1.他无法实现对函数 、RegExp等特殊对象的克隆</p>
</blockquote>
<blockquote>
<p>2.会抛弃对象的constructor,所有的构造函数会指向Object</p>
</blockquote>
<blockquote>
<p>3.对象有循环引用,会报错</p>
</blockquote>
<pre><code class="language-js">// 构造函数
function person(pname) {
  this.name = pname;
}

const Messi = new person('Messi');

// 函数
function say() {
  console.log('hi');
};

const oldObj = {
  a: say,
  b: new Array(1),
  c: new RegExp('ab+c', 'i'),
  d: Messi
};

const newObj = JSON.parse(JSON.stringify(oldObj));

// 无法复制函数
console.log(newObj.a, oldObj.a); // undefined [Function: say]
// 稀疏数组复制错误
console.log(newObj.b[0], oldObj.b[0]); // null undefined
// 无法复制正则对象
console.log(newObj.c, oldObj.c); // {} /ab+c/i
// 构造函数指向错误
console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: Object] [Function: person]

</code></pre>
<p>我们可以看到在对函数、正则对象、稀疏数组等对象克隆时会发生意外，构造函数指向也会发生错误。</p>
<pre><code class="language-js">const oldObj = {};

oldObj.a = oldObj;

const newObj = JSON.parse(JSON.stringify(oldObj));
console.log(newObj.a, oldObj.a); // TypeError: Converting circular structure to JSON
</code></pre>
<p>对象的循环引用会抛出错误.</p>
<h1 id="2-进行对象的遍历复制">2、进行对象的遍历复制</h1>
<p>进行对象的遍历复制，对对象的每一条属性进行复制，这样就能进行对象的深度克隆<br>
如何实现深拷贝?<br>
浅拷贝里的数据不能有对象/数组，即使有对象/数组可以继续遍历对象/数组，拿到里面的每一项值，<br>
一直到拿到的是基本数据类型，然后再复制，这时就是深拷贝</p>
<pre><code class="language-js">
function newobj(obj) {
  var str, newobj = obj.constructor === Array ? [] : {};//constructor 属性返回对创建此对象的数组函数的引用。创建相同类型的空数据
  if (typeof obj !== 'object') {
    return;
  } else {
    for (var i in obj) {
      if (typeof obj[i] === 'object'){//判断对象的这条属性是否为对象
        newobj[i] = newObj(obj[i]);//若是对象进行嵌套调用
      }else{
        newobj[i] = obj[i];
      }
    }
  }
  return newobj;//返回深度克隆后的对象
};
</code></pre>
<pre><code class="language-js">    var obj = {a:1};
    function newobj(obj) {
      var str, newobj = obj.constructor === Array ? [] : {}; //constructor 属性返回对创建此对象的数组函数的引用。创建相同类型的空数据
      if (typeof obj !== 'object') {
        return;
      } else {
        for (var i in obj) {
          if (typeof obj[i] === 'object') { //判断对象的这条属性是否为对象
            newobj[i] = newObj(obj[i]); //若是对象进行嵌套调用
          } else {
            newobj[i] = obj[i];
          }
        }
      }
      return newobj; //返回深度克隆后的对象
    };

    var b = newobj(obj);
    b.a = 2;
    console.log(obj.a); // 1
    console.log(b.a);   // 2 
</code></pre>
<h1 id="3-应用es6的语法对象展开运算符进行对象的展开赋值">3、应用es6的语法对象展开运算符——进行对象的展开赋值</h1>
<p>应用es6的语法对象展开运算符：进行对象的展开赋值</p>
<pre><code class="language-js">var obj = {a:0}
var b = {...obj}
</code></pre>
<pre><code class="language-js">var obj = {a:0}
var b = {...obj}
b.a = 2;
console.log(obj.a); // 0
console.log(b.a);   // 2 
</code></pre>
<p>或者：</p>
<pre><code class="language-js">const person = [{name: 'Messi'}];
const person1 = person.map(item =&gt;
  ({...item, name: 'Kane'})
)
console.log(person, person1);
// [{name: 'Messi'}] [{name: 'Kane'}]
</code></pre>
<p>的确被成功复制了,但是之所以我们称它为<code>浅复制</code>,是因为这种复制只能复制一层,在多层嵌套的情况下依然会出现副作用。</p>
<pre><code class="language-js">const person = [{name: 'Messi', info: {age: 30}}];
const person1 = person.map(item =&gt;
  ({...item, name: 'Kane'})
)
console.log(person[0].info === person1[0].info); // true
</code></pre>
<p>上述代码表明当利用<code>...</code>浅复制产生新的<code>person1</code>后其中嵌套的<code>info属性</code>依然与原始的<code>person</code>的<code>info属性</code>指向同一个堆内存对象,这种情况依然会产生副作用.<br>
我们可以发现<code>...</code>虽然可以解决浅层嵌套的问题,但是依然对多层嵌套的引用类型无能为力.</p>
<p>基本数据类型：存放的就是 实际的数据，可直接复制<br>
克隆数据：对象/数组</p>
<h1 id="如何深拷贝一个数组">如何深拷贝一个数组？</h1>
<h1 id="concat">concat</h1>
<p>concat() 方法用于合并两个或多个<strong>数组</strong>。此方法不会更改现有数组，而是返回一个新数组。</p>
<pre><code class="language-js">//concat()    深复制
  let arr_0 = [1,3,{name:'hhh'}];
  let arr_1 = arr_0.concat();
  arr_1[1] = 6
  console.log(arr_0)  // [1, 3, {name: &quot;hhh&quot;}]
  console.log(arr_1)  // [1, 6, {name: &quot;hhh&quot;}]
</code></pre>
<h1 id="其他深拷贝的方法">其他深拷贝的方法</h1>
<pre><code class="language-js">/**
* deep clone
* @param  {[type]} parent object 需要进行克隆的对象
* @return {[type]}        深克隆后的对象
*/
const clone = parent =&gt; {
  // 维护两个储存循环引用的数组
  const parents = [];
  const children = [];

  const _clone = parent =&gt; {
    if (parent === null) return null;
    if (typeof parent !== 'object') return parent;

    let child, proto;

    if (isType(parent, 'Array')) {
      // 对数组做特殊处理
      child = [];
    } else if (isType(parent, 'RegExp')) {
      // 对正则对象做特殊处理
      child = new RegExp(parent.source, getRegExp(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (isType(parent, 'Date')) {
      // 对Date对象做特殊处理
      child = new Date(parent.getTime());
    } else {
      // 处理对象原型
      proto = Object.getPrototypeOf(parent);
      // 利用Object.create切断原型链
      child = Object.create(proto);
    }

    // 处理循环引用
    const index = parents.indexOf(parent);

    if (index != -1) {
      // 如果父数组存在本对象,说明之前已经被引用过,直接返回此对象
      return children[index];
    }
    parents.push(parent);
    children.push(child);

    for (let i in parent) {
      // 递归
      child[i] = _clone(parent[i]);
    }

    return child;
  };
  return _clone(parent);
};
</code></pre>
<p>测试</p>
<pre><code class="language-js">function person(pname) {
  this.name = pname;
}

const Messi = new person('Messi');

function say() {
  console.log('hi');
}

const oldObj = {
  a: say,
  c: new RegExp('ab+c', 'i'),
  d: Messi,
};

oldObj.b = oldObj;


const newObj = clone(oldObj);
console.log(newObj.a, oldObj.a); // [Function: say] [Function: say]
console.log(newObj.b, oldObj.b); // { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] } { a: [Function: say], c: /ab+c/i, d: person { name: 'Messi' }, b: [Circular] }
console.log(newObj.c, oldObj.c); // /ab+c/i /ab+c/i
console.log(newObj.d.constructor, oldObj.d.constructor); // [Function: person] [Function: person]

</code></pre>
<p>当然,我们这个深克隆还不算完美,例如Buffer对象、Promise、Set、Map可能都需要我们做特殊处理，另外对于确保没有循环引用的对象，我们可以省去对循环引用的特殊处理，因为这很消耗时间，不过一个基本的深克隆函数我们已经实现了。</p>
<h1 id="总结">总结</h1>
<p>实现一个完整的深克隆是由许多坑要踩的,npm上一些库的实现也不够完整,在生产环境中最好用lodash的深克隆实现.</p>
<h1 id="浅拷贝深拷贝-区别">浅拷贝/深拷贝 区别：</h1>
<ul>
<li>拷贝 产生了新的数据     ：深拷贝</li>
<li>拷贝 数据的引用    ：浅拷贝</li>
</ul>
<h1 id="浅拷贝对象数组特点">浅拷贝（对象/数组）：特点：</h1>
<ul>
<li>拷贝的引用，</li>
<li>修改拷贝后的数据会影响原数据</li>
</ul>
<h1 id="深拷贝特点">深拷贝：特点：</h1>
<ul>
<li>生成新数据，</li>
<li>不影响原数据</li>
</ul>
<h1 id="常用的拷贝技术">常用的拷贝技术</h1>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://cutezhangq.github.io/tag/_vij4ft88/" class="tag">
                    ES
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://cutezhangq.github.io/post/nei-cun-yi-chu-yu-nei-cun-xie-lou/">
                  <h3 class="post-title">
                    内存溢出与内存泄漏
                  </h3>
                </a>
              </div>
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: '',
        clientSecret: '',
        repo: '',
        owner: '',
        admin: [''],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
