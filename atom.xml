<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-09-02T13:27:04.223Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[排序算法（下）]]></title>
        <id>https://cutezhangq.github.io/post/pai-xu-suan-fa-xia/</id>
        <link href="https://cutezhangq.github.io/post/pai-xu-suan-fa-xia/">
        </link>
        <updated>2020-09-01T07:03:26.000Z</updated>
        <summary type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<h1 id="八计数排序算法">（八）：计数排序算法</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法（中）]]></title>
        <id>https://cutezhangq.github.io/post/pai-xu-suan-fa-zhong/</id>
        <link href="https://cutezhangq.github.io/post/pai-xu-suan-fa-zhong/">
        </link>
        <updated>2020-08-30T07:01:58.000Z</updated>
        <summary type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<h1 id="四希尔排序">（四）：希尔排序</h1>
<h3 id="算法介绍">算法介绍</h3>
<p>希尔排序，也称<code>递减增量排序</code>算法，是插入排序的一种更高效的改进版本。<br>
希尔排序算法的步骤描述如下：<br>
选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；按增量序列个数 k，对序列进行 k 趟排序；<br>
每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。<br>
仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h3 id="思路">思路</h3>
<p>通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。</p>
<h3 id="算法阐释">算法阐释</h3>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1598771169898.png" alt="" loading="lazy"></figure>
<h3 id="算法图解">算法图解</h3>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598771176444.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://cutezhangq.github.io/post-images/1598771191151.png" alt="" loading="lazy"></figure>
<pre><code class="language-js"> //希尔排序
    function shellSort(arr) {
      var len = arr.length,
        temp,
        gap = 1; //增量因子——————步长
      while (gap &lt; len / 3) { //动态定义间隔序列
        gap = gap * 3 + 1;
      }
      //逐步缩小增量
      for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) {
        //类直接插入排序算法
        for (var i = gap; i &lt; len; i++) {
          temp = arr[i];
          for (var j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) {
            arr[j + gap] = arr[j];    //记录后裔，查找插入位置
          }
          arr[j + gap] = temp;     //插入
        }
      }
      return arr;
    }

  const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
  console.log('————希尔排序——————',shellSort(testArr));
  //————希尔排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
</code></pre>
<p>第一层循环里面的两层嵌套循环算法，其实就是「直接插入排序」，<br>
不同就在于多了一个变量 gap，但其实当 gap === 1 时，那就跟上一节的算法，是完全一样的。</p>
<h3 id="算法实现总结">算法实现总结</h3>
<p>希尔排序的关键不是简单地按 1 为增量进行分组排序后，再合并整体排序；<br>
而是<code>选好一个初始化增量，不断地递减增量，每次递减之间都需要经过一次直接插入排序，使得排序的效率提高。</code><br>
另外只要最终增量为 1，则任何增量序列都可以工作，因为最终当增量为 1 时，算法就变为「直接插入排序」，这就保证了数据一定会被排序。</p>
<p><img src="https://cutezhangq.github.io/post-images/1598771270434.png" alt="" loading="lazy"><br>
综上所述，希尔排序算法的出现，我们终于突破了慢速排序的时代，也即超越了时间复杂度为 O(n²)。</p>
<h3 id="性能比较">性能比较</h3>
<p>在数据量相当的情况下：发现 拆半插入排序 &gt;= 单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 插入排序 &gt; <code>希尔排序</code> &gt;选择排序 &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h1 id="五归并排序">（五）：归并排序</h1>
<h3 id="算法介绍-2">算法介绍</h3>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。归并排序算法的步骤描述如下：<br>
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>
设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>
重复步骤 3 直到某一指针达到序列尾；<br>
将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<h3 id="思路-2">思路</h3>
<p>递归将数组分为两个序列，有序合并这两个序列。作为一种典型的<code>分而治之（拆分、合并）</code>思想的算法应用，归并排序的实现由两种方法：</p>
<ol>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）。</li>
<li>自下而上的迭代。</li>
</ol>
<p><a href="https://user-gold-cdn.xitu.io/2020/7/19/17364df73ad8a5fc?imageslim">动画演示</a></p>
<p>总结：</p>
<ul>
<li>将两个已排好序的数组合并成一个有序的数组,称之为归并排序</li>
<li>步骤：遍历两个数组，比较它们的值。谁比较小，谁先放入大数组中，直到数组遍历完成</li>
</ul>
<pre><code class="language-js">function mergeSort(arr) { // 采用自上而下的递归方法
  var len = arr.length;
  if(len &lt; 2) {
      return arr;
  }
  var middle = Math.floor(len / 2),
  left = arr.slice(0, middle),
  right = arr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));    //拆分
}

function merge(left, right){
  var result = [];

  while (left.length &amp;&amp; right.length) {
    if (left[0] &lt;= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  while (left.length)
    result.push(left.shift());        //合并
  while (right.length)
    result.push(right.shift());      //合并
  return result;
}


const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————归并排序——————',mergeSort(testArr));

//————归并排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://cutezhangq.github.io/post-images/1598872437803.png" alt="" loading="lazy"></figure>
<h3 id="二-归并排序前提分析分治法">二、归并排序前提分析(分治法)</h3>
<p>归并排序的前提是需要两个已经排好顺序的数组，那往往不会有两个已经排好顺序的数组给我们的呀(一般是杂乱无章的一个数组)，<br>
那这个算法是不是很鸡肋的呢？？<br>
其实并不是的，首先假设题目给出的数组是这样子的：int[] arr = {2, 7, 8, 1, 4, 9};<br>
当我们要做归并的时候就以arr[3]也就元素为1的那个地方分开。是然后用一个指针L指向arr[0]，一个指针M指向arr[3]，用一个指针R指向arr<a href="%E6%95%B0%E7%BB%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D">5</a>。有指针的帮助，我们就可以将这个数组切割成是两个有序的数组了（操作的方式就可以和上面一样了）<br>
可是上面说了，一般给出的是杂乱无章的一个数组，现在还是达不到要求。<br>
比如给出的是这样一个数组：int[] arrays = {9, 2, 5, 1, 3, 2, 9, 5, 2, 1, 8};<br>
此时，我们就得用到分治的思想了：<br>
*<br>
那么我们也可以这样想将int[] arr = {2, 7, 8, 1, 4, 9};数组分隔成一份一份的，arr[0]它是一个有序的&quot;数组&quot;,arr[1]它也是一个有序的&quot;数组&quot;,利用指针(L,M,R)又可以像操作两个数组一样进行排序。最终合成{2,7}.......再不断拆分合并，最后又回到了我们的arr = {1,2,4,7,8,9}，因此归并排序是可以排序杂乱无章的数组的</p>
<p>#（六）：快速排序</p>
<h3 id="算法介绍-3">算法介绍</h3>
<p>它是处理大数据最快的排序算法之一。快速排序是一种分而治之思想在排序算法上的典型应用。<br>
本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序算法的步骤描述如下：<br>
从数列中挑出一个元素，称为 “基准”（pivot）;<br>
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。<br>
在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br>
递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。<br>
虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<figure data-type="image" tabindex="5"><img src="https://cutezhangq.github.io/post-images/1598872508940.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">  //分而治之

    function quickSort(arr, left, right) {
      var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;

      if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
      }
      return arr;
    }

    function partition(arr, left, right) { // 分区操作
      var pivot = left, // 设定基准值（pivot）
        index = pivot + 1;
      for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
          swap(arr, i, index);
          index++;
        }
      }
      swap(arr, pivot, index - 1);
      return index - 1;
    }

    function swap(arr, i, j) {
      var temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    function paritition2(arr, low, high) {
      let pivot = arr[low];
      while (low &lt; high) {
        while (low &lt; high &amp;&amp; arr[high] &gt; pivot) {
          --high;
        }
        arr[low] = arr[high];
        while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) {
          ++low;
        }
        arr[high] = arr[low];
      }
      arr[low] = pivot;
      return low;
    }

    function quickSort2(arr, low, high) {
      if (low &lt; high) {
        let pivot = paritition2(arr, low, high);
        quickSort2(arr, low, pivot - 1);
        quickSort2(arr, pivot + 1, high);
      }
      return arr;
    }


  const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
  console.log('————快速排序算法——————',quickSort(testArr));
  console.log('————快速排序算法2——————',quickSort2(testArr));
  //————快速排序算法—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
  //————快速排序算法2—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="性能比较-2">性能比较</h3>
<p>在数据量相当的情况下：发现拆半插入排序 &gt;= 单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 插入排序 &gt; 希尔排序 &gt; 归并排序 &gt; 选择排序 &gt;= 快速排序1 &gt; 快速排序2 &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="注意">注意</h3>
<p>快排实现方法1，虽然代码相对看起来简单，但是在数据量较大时，会出现溢出问题。</p>
<h1 id="七堆排序算法">（七）：堆排序算法</h1>
<h3 id="算法介绍-4">算法介绍</h3>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。<br>
堆排序算法的步骤描述如下：<br>
创建一个堆 H[0……n-1]；<br>
把堆首（最大值）和堆尾互换；把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br>
重复步骤 2，直到堆的尺寸为 1。<br>
JavaScript实现堆排序算法的代码如下：<br>
var len;      // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</p>
<h3 id="思路-3">思路</h3>
<p>说到堆排序，首先需要了解一种数据结构——堆。堆是一种完全二叉树，这种结构通常可以用数组表示。在实际应用中，堆又可以分为最小堆和最大堆，两者的区别如下：</p>
<ul>
<li>-max-heap property ：对于所有除了根节点（root）的节点 i，A[Parent(i)]≥A[i]</li>
<li>-min-heap property ：对于所有除了根节点（root）的节点 i，A[Parent(i)]≤A[i]</li>
</ul>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://cutezhangq.github.io/post-images/1598872660192.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">    
    // 建立大顶堆
    function buildMaxHeap(arr) {
      len = arr.length;
      for (var i = Math.floor(len / 2); i &gt;= 0; i--) {
        heapify(arr, i);
      }
    }

    // 堆调整
    function heapify(arr, i) {
      var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

      if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
      }

      if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
      }

      if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
      }
    }

    function swap(arr, i, j) {
      var temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    //堆排序
    function heapSort(arr) {
      buildMaxHeap(arr); // 建立大顶堆

      for (var i = arr.length - 1; i &gt; 0; i--) {
        swap(arr, 0, i); //交互
        len--;
        heapify(arr, 0); // 堆调整
      }
      return arr;
    }


    const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
    console.log('————堆排序——————',heapSort(testArr));
    //————堆排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="性能比较-3">性能比较</h3>
<p>在大数量量和小数据量不用的情况下，堆排序的相对性能排序表动比较大。和他本身的特点有关，虽然堆排序在实践中不常用，经常被快速排序的效率打败，但堆排序的优点是与输入的数据无关，时间复杂度稳定在O(N*lgN),不像快排，最坏的情况下时间复杂度为O(N2)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法（上）]]></title>
        <id>https://cutezhangq.github.io/post/pai-xu-suan-fa-shang/</id>
        <link href="https://cutezhangq.github.io/post/pai-xu-suan-fa-shang/">
        </link>
        <updated>2020-08-27T02:18:15.000Z</updated>
        <summary type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<p><img src="https://cutezhangq.github.io/post-images/1598754120978.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1598754150521.png" alt="" loading="lazy"></p>
<h1 id="一冒泡排序">（一）：冒泡排序</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1598754182443.png" alt="" loading="lazy"></figure>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。冒泡排序算法的步骤描述如下：（<strong>相邻元素 比较 交换位置</strong>）</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="具体实现">具体实现：</h3>
<pre><code class="language-js"> //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}  

</code></pre>
<p>案例：</p>
<pre><code class="language-js">  //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
  var bubbleSort = function(arr){
    var i,j,m;
    var len = arr.length;
    if(len &lt;= 1){
      return arr;
    }

    for(i = 0;i&lt;len - 1;i++){ //循环2层：两两比较
      for(j=0;j&lt;len-1;j++){
        if(arr[j] &gt; arr[j+1]){  //当前一个比后一个大了
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
      console.log(`第${i+1}次循环————`, arr);
    }
    return arr;
  }
const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————冒泡排序——————',bubbleSort(testArr));
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598754314075.png" alt="" loading="lazy"></figure>
<h2 id="优化单向冒泡实现">优化：单向冒泡实现</h2>
<p>如果数组原本的顺序就是冒泡的，又或者仅做完前面寥寥几次就已经达到效果了，那后续的比较工作就显得有些多余了，如何对以上算法进行改进？<br>
我们可以在某一轮的循环比较结束后，<strong>如果没有发生任何的元素交换，则可以认为该数组已经达到预期效果，不必再继续下一轮的比较了</strong>。</p>
<pre><code class="language-js">var bubbleSort2 = function(arr){
  var start = + new Date();
  var i,j,m,noswap; //noswap没有交换
  var len = arr.length;
  if(len &lt;= 1){
    return arr;
  }

  for(i=0;i&lt;len-1;i++){
    noswap = true;  //未交换
    for(j=0;j&lt;len-1;j++){
      if(arr[j] &gt; arr[j+1]){  
          m = arr[j];         
          arr[j] = arr[j+1];
          arr[j+1] = m;
          noswap = false; //交换了
        }
    }
    if(noswap){
      break;
    }
  }
  // 当 arr 的长度越长，时间差越明显
  console.log(+new Date() - start);
  return arr;
}
const testArr2 = [11,4,6,52,3,20,1,9,2,5,19,3,6,21,105,22,33,44,88,22,1,2,0,3,9,4,100,103,98]
console.log('————改进版冒泡排序——————',bubbleSort2(testArr2));
// 0
// ————改进版冒泡排序—————— (29) [0, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 6, 9, 9, 11, 19, 20, 21, 22, 22, 33, 
44, 52, 88, 98, 100, 103, 105]

</code></pre>
<h2 id="优化双向冒泡实现">优化：双向冒泡实现</h2>
<p>普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，双向冒泡排序则是<code>多一轮的筛选</code>，即找出<code>最大值也找出最小值</code>。</p>
<pre><code class="language-js"> //算法改进————————双向冒泡实现
    // 普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，
    // 双向冒泡排序则是多一轮的筛选，即找出最大值也找出最小值。
  let testArr3 = [1, 6, 7, 4, 5, 8, 9, 0, 2, 3];
  let res = bubbleSortTow(testArr3)
  console.log(res);

  function bubbleSortTow(arr) {
    let low = 0;
    let high = arr.length - 1;
    while(low &lt; high){
      let mark = true;
      // 找到最大值放到右边
      for (let i = low; i &lt; high; i++) {
        if (arr[i] &gt; arr[i + 1]) {
          [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
          mark = false;
        }
      }
      high--;
      // 找到最小值放到左边
      for (let j = high; j &gt; low; j--) {
        if (arr[j] &lt; arr[j - 1]) {
          [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
          mark = false;
        }
      }
      low++;
      console.log(mark);
      console.log(`第${low}次循环`, arr);
      if (mark) 
        return arr;
    }
  }
</code></pre>
<h3 id="性能比较">性能比较</h3>
<p>对三种排序的算法进行性能的比较：发现<br>
<code>单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 大于普通冒泡性能。</code>（产生时间具体取决于所使用的系统）</p>
<h3 id="时间度复杂度分析">时间度复杂度分析:</h3>
<figure data-type="image" tabindex="3"><img src="https://cutezhangq.github.io/post-images/1598754429691.png" alt="" loading="lazy"></figure>
<!-- more -->
<h1 id="二选择排序">（二）：选择排序</h1>
<h3 id="算法介绍">算法介绍</h3>
<p>打个比方，喜欢短线炒股的朋友，习惯短时间内不断地买进卖出，通过价差来实现盈利。<br>
但是通常如此频繁操作，即使失误不多，也会因为操作的手续费和印花税而获利较少。<br>
另外一种长线炒股的朋友，习惯长时间持有，不断地观察和判断，时机一到便果断买进或卖出，交易次数少，收益颇丰。<br>
上一节说的冒泡排序就类似于短线炒股，不断地比较之后进行交换，完成排序。<br>
而本节所要讲解的简单选择排序，类似于长线炒股，虽然也在不断地观察比较，但是会在合适的时机进行交换，并且只移动一次就完成相应关键字的排序定位工作。这就是选择排序法的初步思想。<br>
<code>依次找到剩余元素的 最小值或者最大值，放置在 末尾或者开头。</code></p>
<h3 id="算法图示">算法图示：</h3>
<ul>
<li>第一趟：如下图，先选择1和9，比较，1&lt;9，所以将1放在前面，9放在后面，然后再拿着9和剩下的数组中比较；</li>
<li>第二趟：在剩下的数组中找到最小值，是2，拿2和9比较，2&lt;9，将2放前面，9放在原来2的位置，然后再拿着9和剩下的数组中比较；</li>
<li>第三趟：在剩下的数组中找到最小值，是3，拿3和9比较，3&lt;9，将3放前面，9放在原来3的位置，然后再拿着3和剩下的数组中比较；</li>
<li>第四趟：在剩下的数组中找到最小值，是4，拿4和3比较，4&gt;3，依旧将3放前面，4放在3的后面位置，然后再拿着4和剩下的数组中比较；</li>
<li>第五趟：在剩下的数组中找到最小值，是5，拿5和4比较，5&gt;4，依旧将4放前面，5放在4的后面位置（与7交互），然后再拿着7和剩下的数组中比较；</li>
<li>第六趟： 在剩下的数组中找到最小值，是5，拿5和7比较，5&lt;7，将5放前面，7放在原来5的位置，然后再拿着5和剩下的数组中比较；</li>
<li>第七趟：在剩下的数组中找到最小值，是6，拿6和5比较，6&gt;5，依旧将5放前面，6放在5的后面位置，然后再拿着6和剩下的数组中比较；</li>
<li>第八趟：在剩下的数组中找到最小值，是7，拿7和6比较，7&gt;6，依旧将6放前面，7放在6的后面位置，然后再拿着8和剩下的数组中比较；</li>
<li>第九趟：在剩下的数组中找到最小值，是9，拿9和8比较，9&gt;8，依旧将8放前面，9放在8的后面位置，剩下数组为空</li>
<li>排序结束.....</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://cutezhangq.github.io/post-images/1598770578518.png" alt="" loading="lazy"></figure>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。选择排序算法的步骤描述如下：</p>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<pre><code class="language-js">//选择排序算法
  function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i; //最小数的索引
        for (var j = i + 1; j &lt; len; j++) {   //依次查找剩余元素
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];    //将选出的元素放到末尾
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}   


const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————选择排序——————',selectionSort(testArr));
 //(14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="复杂度分析">复杂度分析</h3>
<figure data-type="image" tabindex="5"><img src="https://cutezhangq.github.io/post-images/1598770628327.png" alt="" loading="lazy"></figure>
<h3 id="性能比较-2">性能比较</h3>
<p>对于等量的数据进行性能比价，发现单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; <code>选择排序</code> &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="提示">提示</h3>
<p>选择排序是时间复杂度上表现最稳定的算法之一，因为最快、最慢时间复杂度都是O(n²)，用选择排序数据量越小越好</p>
<!-- more -->
<h1 id="三直接插入排序">（三）：直接插入排序</h1>
<h3 id="算法介绍-2">算法介绍</h3>
<p>我们都应该玩过扑克牌了，游戏期间玩家们基本上都是一边摸牌一边理牌，会把牌面值小的牌放到左边，牌面值大的牌放到右边，以升序进行排序（当然也有喜欢降序排序的玩家）。<br>
而理牌期间，我们习惯从左往右看牌面值大小，两两比较，将牌抽出，插入到合理的位置。<br>
这里我们理牌的方法，就是「直接插入排序法」。<br>
直接插入排序法的基本操作是<code>将一个元素插入到已经排好序的数组中，从而得到一个新的、Unicode 值递增的数组。</code></p>
<h3 id="算法图示-2">算法图示：</h3>
<figure data-type="image" tabindex="6"><img src="https://cutezhangq.github.io/post-images/1598770756271.png" alt="" loading="lazy"></figure>
<h3 id="分析">分析：</h3>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>
插入排序算法的步骤描述如下：<br>
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>
从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。<br>
（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<pre><code class="language-js">  //插入排序
  function insertionSort(arr){
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
      preIndex = i - 1;   //前一个元素下标
      current = arr[i];   //当前元素
      while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
        arr[preIndex+1] = arr[preIndex];  //将前一个元素往后挪动一位
        preIndex--;     //继续循环遍历
      }
      arr[preIndex+1] = current;    //之前preIndex--了，所以这里要+1
    }
    return arr;
  }


 const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
 console.log('————选择排序——————',insertionSort(testArr));
 //————选择排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
</code></pre>
<pre><code class="language-js"> var insertSort2 = function(arr){
  var i, j, m, mCnt=0;    //m:更小的元素    mCnt:移动的次数
  var len = arr.length;

  for (i=1; i&lt;len; i++) {
    if (arr[i] &lt; arr[i-1]) {    //后面的元素比前面的更小
      // 将更小的那个元素保存起来
      m = arr[i];
      for (j=i-1; arr[j]&gt;m; j--) {
        //将前一个元素往后挪动一位
        arr[j+1] = arr[j];
        mCnt++;
      }
      // console.log('移动了 '+mCnt+' 次');
      mCnt = 0;
      // 直接插入
      arr[j+1] = m;
    }
  }

  return arr;
};


console.log(insertSort2([5,4,3,2,1])) 
//(5) [1, 2, 3, 4, 5]
console.log(insertSort2([3, 2, 1, 7, 8, 9, 0]))
//(7) [0, 1, 2, 3, 7, 8, 9]
</code></pre>
<h3 id="复杂度分析-2">复杂度分析</h3>
<figure data-type="image" tabindex="7"><img src="https://cutezhangq.github.io/post-images/1598770822597.png" alt="" loading="lazy"></figure>
<h2 id="优化拆半插入排序">优化：拆半插入排序</h2>
<pre><code class="language-js">//优化：拆半插入排序实现
  //在直接插入排序的基础上，在插入的时候运用了折半查找法查找要插入的位置，再进行插入。
  let array = [11,4,6,52,3,20,1,9,2,5,19,3,6,21];
  for (let i = 0; i &lt; 10; i++) {
      let number = Math.floor(Math.random() * 10);
      array.push(number);
  }
  let res = this.binsertSort(array);
  console.log(res);
   /**
     * 拆半插入排序
     */
  function binsertSort(arr) {
      let low, high, j, temp;
      for (let i = 1; i &lt; arr.length; i++) {
          if (arr[i] &lt; arr[i - 1]) {
              temp = arr[i];
              low = 0;
              high = i - 1;
              while (low &lt;= high) {
                  let mid = Math.floor((low + high) / 2);
                  if (temp &gt; arr[mid]) {
                      low = mid + 1;
                  } else {
                      high = mid - 1;
                  }
              }
              for (j = i; j &gt; low; --j) {
                  arr[j] = arr[j - 1];
              }
              arr[j] = temp;
          }
          console.log(`第${i}次循环`, arr);
      }
      return arr;
  }

//(24) [0, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="性能比较表示性能相差不大">性能比较&gt;=表示性能相差不大</h3>
<p>在数据量相当的情况下：发现拆半插入排序 &gt;= 单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; <code>插入排序</code> &gt; 选择排序 &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="提示-2">提示</h3>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逻辑题]]></title>
        <id>https://cutezhangq.github.io/post/luo-ji-ti/</id>
        <link href="https://cutezhangq.github.io/post/luo-ji-ti/">
        </link>
        <updated>2020-08-21T07:37:32.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录一些小的逻辑题或算法题👀，啊啊啊，血的教训😰，思考方式很重要</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录一些小的逻辑题或算法题👀，啊啊啊，血的教训😰，思考方式很重要</p>
<!-- more -->
<h1 id="关于取火柴棒问题取胜方法的一些思考">关于取火柴棒问题取胜方法的一些思考</h1>
<p>取火柴棒游戏的问题叙述:<br>
桌上有<strong>n根</strong>火柴棒,甲乙<strong>两人</strong>按照如下规则轮流取走这些火柴棒:</p>
<ul>
<li>1.<code>每次只允许取走1~2根火柴棒</code>;</li>
<li>2.<code>最后一次取走火柴棒的人获胜</code>;</li>
</ul>
<p>若甲先取,且甲想要取胜,那么可以考虑如下一种策略(我们姑且就称之为<code>策略A</code>吧):</p>
<pre><code class="language-cmd">甲先取,之后乙取,若乙取1个火柴棒,那么之后甲就取2个火柴棒;若乙取2个火柴棒,则甲取1个火柴棒,
总之就是保证甲+乙=3,那么,就产生了如下3种情况:
</code></pre>
<h2 id="1n3k1k是整数">1)n=3k+1,k是整数:</h2>
<p>这种情况下,甲要取胜,方法为:<code>先取1个火柴棒</code>(这是最后一个1),那么还剩下3k个火柴棒,之后采取策略A.这样,就能<code>保证每回合都取走3个</code>,且甲取后一次.以此类推,甲就一定能取胜.</p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
</tr>
<tr>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
</tr>
</tbody>
</table>
<h2 id="2n3k2k是整数">2)n=3k+2,k是整数:</h2>
<p>这种情况下,甲要取胜,方法为:<code>先取2个火柴棒</code>,那么还剩下3k个火柴棒,之后采取策略A.这样,就能<code>保证每回合都取走3个</code>,且甲取后一次.以此类推,甲就一定能取胜.</p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
</tr>
<tr>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
</tr>
</tbody>
</table>
<h2 id="3n3kk是整数">3)n=3k,k是整数;</h2>
<p>这种情况下,<code>甲要么先取1个,要么先取2个</code>.剩下的就是:<code>3k-1或者3k-2</code>;而3k-1=(3k+2)-3; 3k-2=(3k+1)-3 在这种情况下,甲是必输的.因为这个问题可以<code>等价于</code><strong>乙先取3k-1或3k-2个火柴棒</strong>,也就是3k+2或3k+1个火柴棒,这与上述1),2)的情况是一样的.所以,这种情况下,<code>甲必输</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结:</h3>
<p>在甲先取的情况下,胜负如下</p>
<ul>
<li>1)若n=3k+1或者n=3k+2</li>
</ul>
<p>甲采取策略A必胜</p>
<ul>
<li>2)若n=3k</li>
</ul>
<p>乙一定能用策略A取得胜利,亦即乙必胜.</p>
<h2 id="进一步推广取火柴棒问题描述如下">进一步推广取火柴棒问题,描述如下:</h2>
<p>桌上有<code>n个</code>火柴棒,甲乙两人按照如下规则轮流取走这些火柴棒:</p>
<p><code>1)每次只允许取走1~m个火柴棒;</code></p>
<p><code>2)最后一次取走火柴棒的人获胜;</code></p>
<p>我们可以从上面的推理中类推出此问题的解,取胜方法策略为(我们姑且称之为<code>策略B</code>):</p>
<p>若甲先取,且甲想取胜</p>
<p>甲先取若干个火柴棒,之后乙取,若乙取1个火柴棒,那么之后甲就取m个火柴棒;若乙取2个火柴棒,则甲取m-1个火柴棒......总之就是保证<code>甲+乙=m+1</code>,那么,就产生了如下m+1种情况:</p>
<h2 id="1nm1k1k是整数">1)n=(m+1)*k+1,k是整数;</h2>
<p>甲先取1个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<h2 id="2nm1k2k是整数">2)n=(m+1)*k+2,k是整数:</h2>
<p>甲先取2个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<h2 id="">......</h2>
<h2 id="mnm1kmk是整数">m)n=(m+1)*k+m,k是整数:</h2>
<p>甲先取m个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<p>m+1)n=(m+1)*k,k是整数:</p>
<p>这种情况下,甲要么先取1个,要么先取2个,要么先取3个,......要么先取m个,那么分别还剩下:(m+1)*k-1,(m+1)*k-2,(m+1)*k-3,......,(m+1)*k-m个火柴棒,亦即<code>[(m+1)*k+m]-(m+1),......,[(m+1)*k+1]-(m+1)</code>个火柴棒.这相当于上面的1)~m)这m种情况,只不过先取的是乙,这种情况下,乙必胜.</p>
<h3 id="总结-2">总结:</h3>
<p>甲先取,且甲想取胜</p>
<ul>
<li>1)若n=(m+1)*k+1,(m+1)*k+2,......,(m+1)*k+m</li>
</ul>
<p>采取上述策略,甲一定能取得胜利</p>
<ul>
<li>2)若n=(m+1)*k</li>
</ul>
<p>乙采取上述策略,乙一定能取得胜利.</p>
<blockquote>
<p>从上面的结论,我们可以看到,只有一种情况下,乙是必胜的,那就是n=(m+1)*k,其余都是甲必胜,可见,甲必胜的概率随着m的增加而不断变大,同时,我们也可以看出,先手者胜率高.</p>
</blockquote>
<p>👉考察了<code>逆向来思考</code>能力【反向逆推法】，数据之间产生关系（相加）规律，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔试-题目整理2-2020bilibili ]]></title>
        <id>https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/</id>
        <link href="https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/">
        </link>
        <updated>2020-08-14T07:18:46.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
<!-- more -->
<h1 id="1关于domcontentloaded和load事件说法正确的是">【1.】关于DOMContentLoaded和load事件说法正确的是？</h1>
<p>A DOMContentLoaded事件比load事件更早执行<br>
B load事件比DOMContentLoaded事件更早执行<br>
C 按监听代码从上到下先后执行<br>
D dom文档完全加载完后执行load事件</p>
<h2 id="答案a-domcontentloaded事件比load事件更早执行">答案：A DOMContentLoaded事件比load事件更早执行</h2>
<p><strong>DOMContentLoaded</strong>：DOM解析完成之后。<br>
当纯HTML被完全加载以及解析时，DOMContentLoaded事件会被触发，而不必等待样式表，图片或者子框架完成加载。</p>
<pre><code class="language-cmd">MDN
当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。
</code></pre>
<p><strong>load</strong>：页面HTML、CSS、JS..及图片等外链资源加载完成之后，才会执行load。<br>
当一个资源及其依赖资源已完成加载时，将触发load事件。</p>
<h1 id="2如何在-div-容器里展示-divdiv-这几个字符">【2.】如何在 div 容器里展示 <div></div> 这几个字符？</h1>
<h2 id="答案documentqueryselectordivinnertext-divdiv">答案：document.querySelector('div').innerText = &quot;<div></div>&quot;</h2>
<pre><code class="language-html">  &lt;!--  innerHTML：设置或获取标签所包含的HTML与文本信息。（不含标签本身）
        innerText：设置或获取标签所包含的文本信息。（不含标签本身）
        outerHTML：设置或获取标签本身以及所包含的HTML与文本信息。（包含标签本身）
        outerText：设置或获取标签本身以及所包含的文本信息。（包含标签本身） --&gt;

&lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
&lt;/div&gt;
    &lt;script&gt;
        var div=document.getElementsByTagName(&quot;div&quot;);
        console.log(div[0].innerHTML);      //  &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
        console.log(div[0].innerText);         //  this is text
        console.log(div[0].outerHTML);     // &lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;&lt;/div&gt;
        console.log(div[0].outerText);        //  this is text
    &lt;/script&gt;
</code></pre>
<h1 id="3以下不是box-sizing的属性是">【3.】以下不是box-sizing的属性是？</h1>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>content-box</td>
<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>
</tr>
<tr>
<td>border-box</td>
<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应从父元素继承 box-sizing 属性的值。</td>
</tr>
</tbody>
</table>
<h2 id="box-sizing">box-sizing</h2>
<p>box-sizing 最主要的用法是规定容器元素的<strong>最终尺寸计算方式。</strong></p>
<p>如果你创造了一个 <code>&lt;div&gt;</code> 没有设置 <code>box-sizing</code>属性为<code>border-box</code>(不设置的话默认值为 <code>content-box</code>)，同时你设置 <code>width:100px; border:10px solid red; padding:10px;</code>那么最终 div 容器的实际宽度为：</p>
<pre><code class="language-js">100px(width)+2*10px*(padding)+2*10px(border)=140px
</code></pre>
<p>所以你会得到一个比你预期（100px）还要更大的容器，结果就是会破坏网页布局。<br>
注意：容易 margin 的尺寸不会被计算入最终容器宽度，因为对他的定义为对这个容器的留白，但不属于容器本身。</p>
<p>如果当我们定义一个容器的 <code>box-sizing</code>属性为<code>border-box</code>时<br>
（表达式：<code>br{box-sizing:border-box}</code>），那么我们创建一个和上段中相同设置的<code>&lt;div&gt;</code>容器时，那么他的最终宽度即为 100px, 那么它的内容部分（content）的有效宽度变成了</p>
<pre><code class="language-js">100px-2*10px-2*10px =60px; 
</code></pre>
<p>所以你会得到一个你预期大小的盒子容器，但是只是被压缩了内容部分尺寸而已，但是对于整体布局而言益处颇多。</p>
<p>所以要合理利用好这个属性，这个属性十分重要。</p>
<!-- more -->
<h1 id="4-1-32-的值为">【4.】‘-1 &gt;&gt;&gt; 32 的值为(  )’</h1>
<p>emm...知识盲区😳😳😳</p>
<h2 id="答案232-1">答案：2^32-1</h2>
<pre><code class="language-cmd">&gt;&gt;这个是带符号右移
&gt;&gt;&gt; 这个是无符号右移
无符号右移运算符（&gt;&gt;&gt;）
</code></pre>
<p><code>按二进制形式把所有的数字向右移动对应位数，低位移出(舍弃)，高位的空位补零。对于正数来说和带符号右移（&gt;&gt;） 相同，但是对于负数来说不同。</code><br>
<strong>正数</strong><br>
例：20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为0001 0100<br>
2、<code>将二进制数向右移两位，高位补符号位（0）</code>，得到0000 0101<br>
3、最后<code>将二进制数转化成十进制数</code>，0000 0101转化为十进制为5<br>
所以，20 &gt;&gt; 2 = 5</p>
<p><strong>负数</strong><br>
例：-20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为1110 1100   //<code>取反加1</code>  20的二进制为0001 0100 取反得到1110 1011 加1后得到1110 1100<br>
2、将<code>二进制数向右移两位，高位补符号位（1）</code>，得到1111 1011<br>
3、最后<code>将二进制数转化成十进制数</code>，1111 1011转化为十进制为-5  //取反 0000 0100 加1   0000 0101 因为是负数，也就是1000 0101也就是2的2次方加2的零次方 等于-5<br>
所以，-20 &gt;&gt; 2 = -5</p>
<p><code>1</code>的二进制 00000000 00000000 00000000 00000001<br>
<code>-1</code>的二进制 10000000 00000000 00000000 00000001 取反加1得到补码 11111111 11111111 11111111 11111111  //首位不变，其余为取反<br>
右移32位（高位补符号位1） 也就是11111111 11111111 11111111 11111111  //32位<br>
假设该数值加上一也就是变成<br>
1 00000000 00000000 00000000 00000000  //1后面有32个0<br>
那就把刚才加上的1减掉<br>
也就是结果<br>
2^32-1<br>
<img src="https://cutezhangq.github.io/post-images/1597476991984.png" alt="" loading="lazy"></p>
<h1 id="51-2-3mapparseint">【5.】['1', '2', '3'].map(parseInt) ( )</h1>
<h2 id="答案1-nan-nan">答案：[1, NaN, NaN]</h2>
<pre><code class="language-js">['1', '2', '3'].map((item, index) =&gt; {
    return parseInt(item, index)
})
parseInt('1', 0) // 1  默认十进制的1
parseInt('2', 1) // NaN 1进制没有2
parseInt('3', 2) // NaN,2进制逢2进1
</code></pre>
<p>ps 啥是parseInt<br>
parseInt('11',2) //二进制的11 转换成十进制应该是 3</p>
<p>['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4]<br>
意思是0(默认0是十进制)进制的十转换成十进制是多少 1进制的十转换成十进制是多少 二进制的10转换成十进制是多少...</p>
<pre><code class="language-js">['1','2','3'].map((a,b,arr)=&gt;{  //a:循环得到的那一项的值；b:循环时的索引; arr整个数组的值
    parseInt(a,b);  //a代表那一项； b代表进制
})
// parseInt(string, radix)   
// 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。
parseInt('1', 0) // radix 为 0，默认以十进制解析字符串，返回 1 

parseInt('2', 1) // radix 为 1，不在 2 ~ 36 之间，返回 NaN 

parseInt('3', 2) // radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN
//2 进制只有0和1，，，3超出范围了
</code></pre>
<h1 id="6计算结果">【6.】计算结果</h1>
<pre><code class="language-js">console.log(1);
setTimeout(() =&gt; {console.log(2)}, 0);
console.log(3);
Promise.resolve(4).then(b =&gt; {
console.log(b);
});
console.log(5);
</code></pre>
<h2 id="答案1-3-5-4-2">答案：1 3 5 4 2</h2>
<p><code>console.log()</code> -&gt; <code>同步</code><br>
<code>promise</code>-&gt; <code>异步，微任务</code><br>
<code>setTimeout</code> -&gt; <code>异步，宏任务</code><br>
执行顺序:<code>同步</code> &gt;<code>异步,微任务</code> &gt; <code>异步，宏任务</code></p>
<h1 id="7mathabs-6666-的结果是多少">【7.】Math.abs(-6.666) 的结果是多少?</h1>
<h2 id="答案6666">答案：6.666</h2>
<p><code>Math.abs()</code>转为为绝对值</p>
<p><code>parseInt(7/2)</code>丢弃小数部分,保留整数部分</p>
<p><code>Math.ceil(7/2)</code>向上取整,有小数就整数部分加1</p>
<p><code>Math.round(7/2)</code>四舍五入</p>
<p><code>Math.floor(7/2)</code>向下取整</p>
<h1 id="812345-的数组的基础上-删除第一个-和-最后一位">【8.】[1,2,3,4,5] 的数组的基础上 删除第一个 和 最后一位</h1>
<p>[1,2,3,4,5].replace(1, -1)<br>
[1,2,3,4,5].reverse(1，-1)<br>
[1,2,3,4,5].toString(-1，1)<br>
[1,2,3,4,5].slice(1, -1)</p>
<h2 id="答案12345slice1-1">答案：[1,2,3,4,5].slice(1, -1)</h2>
<p><code>slice(1,-1)</code>  slice不会操作原数组，会返回一个新数组 。 表示从索引为0开始截取，-1表示截取到倒数第二个，并将这个新数组返回。</p>
<p><code>replace</code>方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。原字符串不会改变。</p>
<p><code>reverse</code>方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p>
<h1 id="9计算结果">【9.】计算结果</h1>
<pre><code class="language-js">function setname(name){
 this.name = name
}
setname.prototype.printName = function(){ console.log(this.name) }
let a = new setname(&quot;cc&quot;)
a.name = &quot;dd&quot;
a.__proto__.name = &quot;ee&quot;

a.__proto__.printName()  // ?
a.printName() // ?
</code></pre>
<h2 id="答案ee-dd">答案：ee dd</h2>
<p>首先定义了一个函数 setname（）接下来定义了一个方法printname<br>
调用new 方法生成对象传参 “cc” 此时a对象上面的name属性为cc<br>
<img src="https://cutezhangq.github.io/post-images/1597559456328.png" alt="" loading="lazy"><br>
接下来通过a.name修改属性 此时a对象的name属性为 dd<br>
<img src="https://cutezhangq.github.io/post-images/1597559495746.png" alt="" loading="lazy"><br>
最后修改通过a修改构造函数中的属性 --proto--<br>
<img src="https://cutezhangq.github.io/post-images/1597559529281.png" alt="" loading="lazy"></p>
<h1 id="输入">输入</h1>
<pre><code class="language-js">    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    rl.on('line',(line)=&gt;{
      console.log();
    })
</code></pre>
<h1 id="10找出有序数组从小到大排列中和为sum的两个数要求复杂度为on找到一组即可">【10.】找出有序数组（从小到大排列）中和为sum的两个数，要求复杂度为O(n)，找到一组即可</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1597739669645.png" alt="" loading="lazy"></figure>
<p>可以采用<code>暴力枚举</code>,即2层for循环——但是<code>复杂度</code>就不符合了<br>
<strong>从小到大排列</strong>——想起<strong>二分查找</strong>的思想（从数组的第一个查找i；从数组的最后一个查找j）</p>
<pre><code class="language-js">//[1    3   4   6       8]
//13    14  16  18  34  36  46  48  
//10
//头 i
//尾 j
//  1+8 = 9 &lt;10 数组从小到大排列的，需要挪动数组，考虑移动i还是j，因为从小到大排列，所以i++
//  3+8 = 11 &gt;10 比目标值大了，要想办法减小，j--
//  3+6 = 9 &lt;10 进行i++
//  4+6 = 10 = 10 找到了，返回4和6
</code></pre>
<p>答案：</p>
<pre><code class="language-js">   //没找到，i往后走，j往前走
    //javascript(node)运行
    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    const maxLine = 3;
    let input = []; //放数组的
    function solution(input){
      //input[1].split(' ')取出第一个输入的数字，以空格将其分开
      //.map(e =&gt; parseInt(e))将切出的字符串转换为数字
      const arr = input[1].split(' ').map(e =&gt; parseInt(e));  
      //sum拿到数组的最后一项
      const sum = parseInt(input[2]);
      const len = arr.length;
      let i = 0;  //头指针
      let j = len - 1;  //尾指针
      while(i&lt;j){
        let res = arr[i] + arr[j];
        //如果找到了
        if(res === sum) return `${arr[i]} ${arr[j]}`
        //如果没找到
        if(res &lt; sum){
          i++;
        }
        if(res &gt; sum){
          j--;
        }
      }
      return 'notfound' //数组中没找到
    }
    rl.on('line',(line)=&gt;{
      input.push(line);
      if(input.length === maxLine){
        console.log(solution(input));
        rl.close();
      }
    })
</code></pre>
<h1 id="11判断由6种括号组成的字符串是否合法">【11.】判断由&quot;()[]{}&quot;6种括号组成的字符串是否合法</h1>
<ol>
<li>所有括号必须闭合</li>
<li>左括号必须在正确的位置闭合<br>
<img src="https://cutezhangq.github.io/post-images/1597739560221.png" alt="" loading="lazy"></li>
</ol>
<h1 id="12有n级台阶每一步可以走1级或2级问一共有多少种走法">【12.】有n级台阶，每一步可以走1级或2级，问一共有多少种走法</h1>
<p><img src="https://cutezhangq.github.io/post-images/1597739843040.png" alt="" loading="lazy"><br>
答案：</p>
<pre><code class="language-js">   //20 走法(18走法+19走法)
      //18走法 + 2 = 20 或 
      //19走法 + 1 = 20
    //19
      //17 + 2 = 19 或 18 + 1 = 19

    //1
      //1
    //2
      //1 或 2
    //3
      //1走法+2走法
    //...


    //1 2 3 4 ... 18  19  20  ——————后面的走法为前两个走法之 和 ——————斐波那契数列
    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    function solution(step){
      step = parseInt(step);
      function walk(n){
        if(n &lt; 1){    //没有台阶
          return 0
        }
        if(n === 1) return 1; //只有一个台阶
        if(n === 2) return 2;
        return walk(n-1) + walk(n-2);
      }
      return walk(step);
    }
    rl.on('line',(line)=&gt;{
      console.log();
    })
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇淫巧技]]></title>
        <id>https://cutezhangq.github.io/post/qi-yin-qiao-ji/</id>
        <link href="https://cutezhangq.github.io/post/qi-yin-qiao-ji/">
        </link>
        <updated>2020-08-11T01:49:25.000Z</updated>
        <summary type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
<!-- more -->
<h1 id="对数据进行奇偶判断">对数据进行奇偶判断</h1>
<p>普通选手：</p>
<pre><code class="language-js">const n = 11;
if(n%2 == 1){
   console.log('奇数')
}else{
    console.log('偶数')
}
</code></pre>
<p>种子选手：&amp; 位运算符的妙用，相“与”</p>
<pre><code class="language-js">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="判断类型-封装可判断所有类型">判断类型 封装（可判断所有类型）</h1>
<p>普通选手：</p>
<pre><code class="language-js">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>种子选手：<br>
判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。<br>
因此要真正完美判断时，我们需要区分对待:<br>
* 基本类型( null ): 使用String( )，如：String(null)<br>
* 基本类型(string / number / boolean / undefined) + function + symbol: 直接使用 typeof 即可<br>
* 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断，本质上还是调用 valueof 进行判断。</p>
<pre><code class="language-js"> let class2type = {}
  'Array Date RegExp Object Error'.split(' ').forEach(e =&gt; class2type['[object ' + e + ']'] = e.toLowerCase())

  function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[Object.prototype.toString.call(obj)] || 'object' : typeof obj
  }
</code></pre>
<p>这里的.call是绑定this对象指向当前的Object对象<br>
**RegExp：**是正则表达式（regular expression）的简写。</p>
<h1 id="判断是否存在">判断是否存在</h1>
<pre><code class="language-js">  if(typeof a!=&quot;undefined&quot;){     //不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错
      xxx
    }
</code></pre>
<h1 id="检测-某个对象-是不是-另一个对象-的-实例">检测 某个对象 是不是 另一个对象 的 实例</h1>
<p>（测试一个对象在其原型链中是否存在一个构造函数的prototype属性）</p>
<pre><code class="language-js">  function test(){};
  var b = new test();
  var c = new test();
  console.log(b instanceof test); //true   可用来判断一个变量是否是某个对象的实例
  console.log(c == b);  //false
</code></pre>
<h1 id="判断一个-实例-是否属于它的-父类型">判断一个 实例 是否属于它的 父类型</h1>
<p>instanceof 可以在 继承关系 中用来判断一个 实例 是否属于它的 父类型。</p>
<pre><code class="language-js"> var a = new Array();  
 console.log(a instanceof Array);  //true
 console.log(a instanceof Object); //true  因为 Array 是 Object的 子类
</code></pre>
<h1 id="判断-对象是否为空-的三种方法">判断 对象是否为空 的三种方法：</h1>
<pre><code class="language-js">  //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }


  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象


  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
    //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
  t = {};
  if(Object.keys(t).length == 0){
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="apply的使用">.apply（）的使用</h1>
<h2 id="1找出数组最大元素">（1）找出数组最大元素</h2>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>
<pre><code class="language-js">var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
</code></pre>
<h2 id="2将数组的空元素变为undefined">（2）将数组的空元素变为undefined</h2>
<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>
<pre><code class="language-js">Array.apply(null, ['a', ,'b'])
// [ 'a', undefined, 'b' ]
</code></pre>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。<br>
因此，遍历内部元素的时候，会得到不同的结果。</p>
<pre><code class="language-js">var a = ['a', , 'b'];

function print(i) {
console.log(i);
}

a.forEach(print)
// a
// b

Array.apply(null, a).forEach(print)
// a
// undefined
// b
</code></pre>
<h1 id="如何判断是否是数组">如何判断是否是数组？</h1>
<p>es6中加入了新的判断方法：<code>.isArray()</code></p>
<pre><code class="language-js">  value = []
  if (Array.isArray(value)) {
    console.log('是数组')
  } else {
    console.log('NO')
  }
</code></pre>
<p>在考虑兼容性的情况下可以用toString的方法：</p>
<pre><code class="language-js">  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]'
    }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[slot插槽]]></title>
        <id>https://cutezhangq.github.io/post/slot-cha-cao/</id>
        <link href="https://cutezhangq.github.io/post/slot-cha-cao/">
        </link>
        <updated>2020-08-07T03:04:18.000Z</updated>
        <summary type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
<!-- more -->
<p>由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>两大类。<br>
非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；<br>
插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p>
<h1 id="单个插槽-默认插槽-匿名插槽">单个插槽 | 默认插槽 | 匿名插槽</h1>
<p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。<br>
单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。<br>
下面通过一个例子来展示。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;h3&gt;这里是父组件&lt;/h3&gt;
        &lt;child&gt;
            &lt;div class=&quot;tmpl&quot;&gt;
              &lt;span&gt;菜单1&lt;/span&gt;
              &lt;span&gt;菜单2&lt;/span&gt;
              &lt;span&gt;菜单3&lt;/span&gt;
              &lt;span&gt;菜单4&lt;/span&gt;
              &lt;span&gt;菜单5&lt;/span&gt;
              &lt;span&gt;菜单6&lt;/span&gt;
            &lt;/div&gt;
        &lt;/child&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;child&quot;&gt;
        &lt;h3&gt;这里是子组件&lt;/h3&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p>
<pre><code class="language-html">&lt;div class=&quot;tmpl&quot;&gt;
  &lt;span&gt;菜单1&lt;/span&gt;
  &lt;span&gt;菜单2&lt;/span&gt;
  &lt;span&gt;菜单3&lt;/span&gt;
  &lt;span&gt;菜单4&lt;/span&gt;
  &lt;span&gt;菜单5&lt;/span&gt;
  &lt;span&gt;菜单6&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>最终的渲染结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892088251.png" alt="" loading="lazy"></p>
<h1 id="具名插槽">具名插槽</h1>
<p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个<strong>具名插槽</strong>和<strong>单个插槽</strong>的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;child&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt;
        &lt;span&gt;菜单1&lt;/span&gt;
        &lt;span&gt;菜单2&lt;/span&gt;
        &lt;span&gt;菜单3&lt;/span&gt;
        &lt;span&gt;菜单4&lt;/span&gt;
        &lt;span&gt;菜单5&lt;/span&gt;
        &lt;span&gt;菜单6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt;
        &lt;span&gt;菜单-1&lt;/span&gt;
        &lt;span&gt;菜单-2&lt;/span&gt;
        &lt;span&gt;菜单-3&lt;/span&gt;
        &lt;span&gt;菜单-4&lt;/span&gt;
        &lt;span&gt;菜单-5&lt;/span&gt;
        &lt;span&gt;菜单-6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot;&gt;
        &lt;span&gt;菜单-&gt;1&lt;/span&gt;
        &lt;span&gt;菜单-&gt;2&lt;/span&gt;
        &lt;span&gt;菜单-&gt;3&lt;/span&gt;
        &lt;span&gt;菜单-&gt;4&lt;/span&gt;
        &lt;span&gt;菜单-&gt;5&lt;/span&gt;
        &lt;span&gt;菜单-&gt;6&lt;/span&gt;
      &lt;/div&gt;
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
    // 具名插槽
    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 具名插槽
    &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt;
    // 匿名插槽
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596892200490.png" alt="" loading="lazy"><br>
可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。</p>
<h1 id="作用域插槽-带数据的插槽">作用域插槽 | 带数据的插槽</h1>
<p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p>
<pre><code class="language-cmd">匿名插槽
&lt;slot&gt;&lt;/slot&gt;
具名插槽
&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
</code></pre>
<p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p>
<pre><code class="language-html">&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;
 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    },
}
</code></pre>
<p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p>
<pre><code class="language-cmd">&lt;child&gt;
   html模板
&lt;/child&gt;
</code></pre>
<p>可以说是子组件暴露的一个让父组件传入自定义内容的接口。<br>
写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。<br>
OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？<br>
<code>正因为作用域插槽绑定了一套数据，父组件可以拿来用。</code>于是，情况就变成了这样：<code>样式父组件说了算，但内容可以显示子组件插槽绑定的。</code><br>
我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。<br>
下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;!--第一次使用：用flex展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;div class=&quot;tmpl&quot;&gt;
          &lt;span v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第二次使用：用列表展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第三次使用：直接显示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;              &lt;!--通过slot-scope获取子组件的信息--&gt;
       {{user.data}}
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;
    &lt;child&gt;
      我就是模板
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;

</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;

    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 作用域插槽
    &lt;slot  :data=&quot;data&quot;&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    }
}
</code></pre>
<p>结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892616696.png" alt="" loading="lazy"></p>
<h1 id="slot-scope">slot-scope</h1>
<p><strong>父组件中在使用时：</strong></p>
<ul>
<li>默认插槽的话直接在子组件的标签内写入内容即可</li>
<li>具名插槽是在默认插槽的基础上加上slot属性，值为子组件插槽name属性值</li>
<li>作用域插槽则是通过<code>slot-scope获取子组件的信息</code>，在内容中使用。这里可以用解构语法去直接获取想要的属性</li>
</ul>
<h1 id="v-slot">v-slot</h1>
<pre><code class="language-cmd">在vue2.6中，上述的API被软废弃（3.0正式废弃），取而代之的是内置指令v-slot，可以缩写为【#】
</code></pre>
<p>**子组件用法保持不变，**父组件中</p>
<ul>
<li>slot属性弃用，具名插槽通过指令参数<code>v-slot:插槽名</code>的形式传入，可以简化为 <code>#插槽名。</code></li>
<li><code>slot-scope</code>属性弃用，作用域插槽通过<code>v-slot:xxx=&quot;slotProps&quot;</code>的slotProps来获取子组件传出的属性</li>
<li>v-slot属性只能在 <code>&lt;template&gt;</code>上使用，但在**【只有默认插槽时】**可以在组件标签上使用</li>
</ul>
<pre><code class="language-html">//Parent
&lt;template&gt;
  &lt;child&gt;
   &lt;!--默认插槽--&gt;
   &lt;template v-slot&gt;
     &lt;div&gt;默认插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--具名插槽--&gt;
   &lt;template #header&gt;
     &lt;div&gt;具名插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--作用域插槽--&gt;
   &lt;template #footer=&quot;slotProps&quot;&gt;
     &lt;div&gt;
      {{slotProps.testProps}}
     &lt;/div&gt;
   &lt;/template&gt;
  &lt;child&gt;
&lt;/template&gt;
</code></pre>
<h1 id="拓展用法">拓展用法：</h1>
<ol>
<li>同样可以通过解构获取v-slot={user},<br>
还可以重命名v-slot=&quot;{user: newName}&quot;和定义默认值v-slot=&quot;{user = '默认值'}&quot;</li>
<li>插槽名可以是动态变化的 v-slot:[slotName]</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>默认插槽名为<code>default</code>，可以省略default直接写<code>v-slot</code>，<br>
缩写为#时不能不写参数，写成<code>#default</code>（这点所有指令都一样，v-bind、v-on）</li>
<li>多个插槽混用时，v-slot不能省略default</li>
</ol>
<h1 id="作用域插槽的原理">作用域插槽的原理</h1>
<p>slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过<br>
<code>template &gt;&gt; render function &gt;&gt; VNode &gt;&gt; DOM</code>过程。 组件挂载的本质就是执行渲染函数得到VNode，至于data/props/computed这些属性都是给VNode提供数据来源。<br>
在2.5之前，如果是普通插槽就<strong>直接是VNode</strong>的形式了，而如果是作用域插槽，由于子组件需要在父组件访问子组件的数据，所以父组件下是一个<strong>未执行的函数</strong><code>(slotScope) =&gt; return h('div', slotScope.msg)</code>，接受子组件的slotProps参数，在子组件渲染实例时会调用该函数传入数据。<br>
在2.6之后，两者合并，普通插槽也变成一个函数，只是不接受参数了。</p>
<h1 id="总结">总结</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596938553804.png" alt="" loading="lazy"></figure>
<h1 id="slot的使用场景">slot的使用场景</h1>
<ul>
<li>布局组件、</li>
<li>表格列、</li>
<li>下拉选项</li>
</ul>
<h1 id="slot-scope的使用场景">slot-scope的使用场景</h1>
<p>想象一个场景：<br>
<strong>当你要给同事封装一个列表组件，你就需要使用作用域插槽（注意是列表或者类似列表的组件）</strong><br>
你开发的这个列表组件要如何使用呢？<br>
一般来说作为列表组件的调用者，你的同事先做ajax请求，拿到一个这样的数组</p>
<pre><code class="language-json">   todos: [
        {
          id: 0,
          text: 'ziwei0',
          isComplete: false
        },
        {
          text: 'ziwei1',
          id: 1,
          isComplete: true
        },
        {
          text: 'ziwei2',
          id: 2,
          isComplete: false
        },
        {
          text: 'ziwei3',
          id: 3,
          isComplete: false
        }
      ]
</code></pre>
<p>之后会把todso传递给列表组件吧，那么列表组件内部做什么事情呢？<br>
列表内部肯定会v-for去帮你的同事渲染这个数组嘛。 就类似element-ui里的table组件一样<br>
问题的关键就在这里<br>
<strong>列表组件的循环，是发生在组件内部的，所以通过 v-for=&quot;todo in todos&quot; ,列表组件很容易拿到一项todo，但列表拿到数据没用呀，列表只是一个瓜皮，它又不懂业务逻辑这个数据是你同事的业务数据，</strong><br>
<strong>所以这个数据必须得交给组件的调用者，也就是把数据交给你的同事才对。</strong></p>
<p>那么你怎样才能把每一项的todo数据给传递出去呢？<br>
你会发现没有办法！</p>
<p>无论是用$emit、vuex还是localStorage，可以考虑一下，会发现没有合适的时机，能让你把todo传递出去</p>
<p>所以为了应对这个场景下，发明了<code>作用域插槽</code>，列表组件可以通过<code>&lt;slot :todo=&quot;todo&quot;&gt;&lt;/slot&gt;</code>传递todo出去<br>
你的同事可以通过 slot-scope=&quot;slotsProps&quot;<code>拿到todo</code>。<br>
回答几个疑问，其实如果你看懂上面的问题，应该可以回答下面的问题。这也是我曾经的疑问</p>
<ul>
<li>疑问1：一般不是我们传参数来调用组件吗？为什么组件还把数据传递回来？</li>
</ul>
<pre><code class="language-cmd">的确，调用ui组件时一般是我们传递配置参数给他们。

但是就像elemnt-ui的table组件，你把数组传递给table后，是不是有时候需要拿到某一行的row对象

并根据row对象里的字段，来判断一些内容的显示隐藏？

因为循环的过程发生在table组件内部，所以table组件可以方便的获取到每一项数据，但是这些数据最终不是给组件的，而是我们自己要用的业务数据。所以也需要一个方式，让调用者能拿到自己想要的数据
</code></pre>
<ul>
<li>疑问2： 既然子组件最终还要把我给他的数据，再返还给我，那我当初还干嘛给它，能不能就自己在父组件里玩？</li>
</ul>
<pre><code class="language-cmd">如果你不把数据给子组件当然可以。但是就等于抛弃掉了子组件的封装，只能你直接在父组件自己写一个列表

毕竟你不把数据给子组件，子组件还渲染个锤子？没有父子关系的话，也就不用什么插槽了。

但是咱不是为了封装后，可以复用嘛，总不能永远不用组件嘛
</code></pre>
<ul>
<li>疑问3： 父组件需要子组件的数据？那不会有$emit和vuex嘛，为什么要有slot-scope？</li>
</ul>
<pre><code class="language-cmd">$emit和vuex是数据传递的一种方法，但是你可以尝试用$emit和vuex把todo传递给父组件。

你会发现的确没有合适的钩子、时机来$emit数据
</code></pre>
<h1 id="26新增用法">2.6新增用法</h1>
<h2 id="动态插槽名260新增">动态插槽名(2.6.0新增)</h2>
<p>动态指令参数(需要自己了解)也可以用在v-slot上，来定义动态的插槽名：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<h2 id="具名插槽的缩写260新增">具名插槽的缩写(2.6.0新增)</h2>
<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：<br>
原来是这样写的：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;  
</code></pre>
<p>现在可以这样写：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;
</code></pre>
<p>如果希望使用缩写的话，必须始终以明确插槽名取而代之：</p>
<pre><code class="language-html">&lt;test #default=&quot;{ usertext }&quot;&gt;
  {{ usertext.firstName }}
&lt;/test&gt;
</code></pre>
<h1 id="其他示例">其他示例</h1>
<p>插槽 prop 允许我们将插槽转换为<code>可复用</code>的模板，这些模板可以基于输入的 <code>prop</code>渲染出不同的内容。 这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。<br>
例如，我们要实现一个 <code>&lt;todo-list&gt;</code>组件，它是一个列表且包含布局和过滤逻辑：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>我们可以将每个<code>todo</code>作为父级组件的插槽，以此通过父级组件对其进行控制，然后将<code>todo</code> 作为一个插槽<code>prop</code>进行绑定：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    &lt;!--
    我们为每个 todo 准备了一个插槽，
    将 `todo` 对象作为一个插槽的 prop 传入。
    --&gt;
    &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code>组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code>作为替代方案，并且可以从子组件获取数据：</p>
<pre><code class="language-html">&lt;todo-list v-bind:todos=&quot;todos&quot;&gt;
  &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
&lt;/todo-list&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[computed，watch，method执行的先后顺序]]></title>
        <id>https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/</id>
        <link href="https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/">
        </link>
        <updated>2020-08-06T13:57:16.000Z</updated>
        <summary type="html"><![CDATA[<p>👉他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>👉他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
<!-- more -->
<h1 id="computed">computed：</h1>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<h1 id="methods">methods：</h1>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<h1 id="watch">watch：</h1>
<p>是一种更通用的方式来观察和响应 Vue 实例上的数据变动。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
<p>通俗来讲，</p>
<p>computed是在HTML DOM加载后马上执行的，如赋值；</p>
<p>而methods则必须要有一定的触发条件才能执行，如点击事件；</p>
<p>watch呢？它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。</p>
<p>所以他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
<p>下面的例子可以做为说明。</p>
<p>computed 属性 vs watched 属性：Vue 确实提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：watch 属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的想法是使用 computed 属性而不是命令式的 watch 回调。</p>
<h1 id="computed与watch的区别">computed与watch的区别</h1>
<p>在很多情况下, computed会比watch使用起来更加方便,但是当需要在数据变化时执行异步或者开销比较大的情况下,用watch会更加合适。<br>
例如官网提供的例子(问与答。watch观察question的值,若值有改变会执行方法getAnswer,并且根据question不同的值, answer会给出不同的回答,并且会异步调用API返回相应的值,这些都是计算属性做不到的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>目的</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>computed</td>
<td>依赖变动实时更新数据</td>
<td>更新数据</td>
</tr>
<tr>
<td>watch</td>
<td>观察某一特定的值，执行特定的函数</td>
<td>观察数据</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">&lt;divid=&quot;demo&quot;&gt;{{ fullName }}&lt;/div&gt;

使用watch方法观察数据（单个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar',
fullName: 'Foo Bar'
},
watch: {
firstName: function (val) {
this.fullName = val + ' ' + this.lastName
},
lastName: function (val) {
this.fullName = this.firstName + ' ' + val
}
}
})

使用computed方法计算数据（多个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar'
},
computed: {
fullName: function () {
return this.firstName + ' ' + this.lastName
}
}
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON.stringify与"环"问题]]></title>
        <id>https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/</id>
        <link href="https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/">
        </link>
        <updated>2020-08-06T10:50:32.000Z</updated>
        <summary type="html"><![CDATA[<p>JSON.stringify在解析接口数据时，我们经常使用到，那么它为什么会产生“环“呢，啥是”环“和？😨<br>
🙄博主酱的脑海中一堆问号，赶快来了解下了！</p>
]]></summary>
        <content type="html"><![CDATA[<p>JSON.stringify在解析接口数据时，我们经常使用到，那么它为什么会产生“环“呢，啥是”环“和？😨<br>
🙄博主酱的脑海中一堆问号，赶快来了解下了！</p>
<!-- more -->
<p>JSON.stringify的功能是，将一个js字面量对象转化为一个JSON格式的字符串，例如：</p>
<pre><code class="language-js">const obj = {a:1,b:2}
JSON.stringify(obj)     //  ‘ {“a”:1,“b”:2}’
</code></pre>
<!-- more -->
<p>当要转化的对象有**“环”**存在时（<strong>子节点属性赋值了父节点的引用</strong>），为了避免死循环，JSON.stringify 会抛出异常，例如：</p>
<pre><code class="language-js">const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
JSON.stringify(obj) // =&gt; TypeError: Converting circular structure to JSON 类型错误:将循环结构转换为JSON
</code></pre>
<p>请完善以下“环”检查器函数 cycleDetector，当入参对象中有环时返回 true，否则返回 false。</p>
<pre><code class="language-js">function cycleDetector(obj) {   
  // 请添加代码
}
</code></pre>
<p>“环”的形成是因为对象的子节点属性赋值了父节点的引用，所以我们需要记录下父节点的地址，然后再拿其子节点的属性与之前记录下的父节点地址做一个比较，当结果一致时，就形成了“环”。</p>
<p>那么，在“环”检测器函数中，我们首先需要遍历这个对象的属性，前面提到了引用，那么我们只需对Object类型的属性进行处理即可（简单数据类型不存在引用关系）。对于Objcet类型的属性，我们先与记录下来的父节点地址做一个对比，如无匹配项，将当前属性地址记录下来，然后遍历其子节点属性，一层一层找下去。下面开始上代码：</p>
<pre><code class="language-js">function cycleDetector(obj){
    var hasCircle = false,  //  定义一个变量，标志是否有环
    cache = [];          //  定义一个数组，来保存对象类型的属性值
    (function(obj){
        var keys = Object.keys(obj);    //获取当前对象的属性数组——key是获取属性
             for (var i = 0; i &lt; keys.length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (typeof value == 'object' &amp;&amp; value !== null) {
                var index = cache.indexOf(value)
                if (index !== -1) {
                    hasCircle = true
                    break
                } else {
                    cache.push(value)
                    arguments.callee(value)
                    cache.pop()      //  注意：这里要推出数据，因为递归返回，后面遍历的属性不是这个数据的子属性
                }
            }
        }
    })(obj)
}

</code></pre>
<p>补充：<br>
<strong>Object.keys</strong> 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。<br>
<strong>测试用例</strong></p>
<pre><code class="language-js">/* 测试一 */

const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
</code></pre>
<pre><code class="language-js">/* 测试二 */

var obj = {
    foo: {
        name: 'foo',
        bar: {
            name: 'bar',
            baz: {
                name: 'baz',
                aChild: null
            }
        }
    },
    aaa: {
        name: &quot;test&quot;,
        bbb: null
    }
}
obj.aaa.bbb = obj.foo;   //  aaa-&gt;bbb-&gt;bar-&gt;baz-&gt;aChild-&gt;null 不形成环
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JWT认证原理（JSON Web Token）、SSO单点登录]]></title>
        <id>https://cutezhangq.github.io/post/jwt-ren-zheng-yuan-li/</id>
        <link href="https://cutezhangq.github.io/post/jwt-ren-zheng-yuan-li/">
        </link>
        <updated>2020-07-31T06:27:29.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于👉分布式站点的<code>单点登录（SSO）</code>场景👈。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。👀</p>
<p>JWT认证原理（JSON Web Token）</p>
<p>互联网服务离不开用户认证。一般流程是下面这样。🙌</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于👉分布式站点的<code>单点登录（SSO）</code>场景👈。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。👀</p>
<p>JWT认证原理（JSON Web Token）</p>
<p>互联网服务离不开用户认证。一般流程是下面这样。🙌</p>
<!-- more -->
<h1 id="一-传统的session认证">一、传统的Session认证</h1>
<h2 id="流程session">流程session</h2>
<p>认证的流程一般如下：</p>
<ul>
<li>1.用户向服务器发送用户名和密码。</li>
<li>2.服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>3.服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>4.用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>5.服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>session保存在服务器，当注册用户很多，会增加服务器的开销。</li>
<li>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡的能力。这也意味着限制了应用的扩展能力。</li>
<li>session是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到<code>跨站请求伪造（CSRF）</code>的攻击。</li>
</ul>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 <code>session 数据持久化</code>，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都<code>保存在客户端</code>，每次请求都发回服务器。<code>JWT</code>就是这种方案的一个代表。</p>
<h1 id="二-jwt-认证">二、JWT 认证</h1>
<h2 id="token">token</h2>
<p><code>JWT</code>是基于<code>token</code>的鉴权机制类似于<code>http协议</code>也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。<br>
这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<h2 id="流程">流程</h2>
<ul>
<li>1.用户使用用户名密码来请求服务器。</li>
<li>2.服务器进行验证用户的信息</li>
<li>3.服务器通过验证发送给用户一个token</li>
<li>4.客户端存储token，并在每次请求时附送上这个token值</li>
<li>5.服务端验证token值，并返回数据</li>
</ul>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)策略</code>，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p>
<h2 id="jwt-的原理">JWT 的原理</h2>
<p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<pre><code class="language-json">{
  &quot;姓名&quot;: &quot;张三&quot;,
  &quot;角色&quot;: &quot;管理员&quot;,
  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;
}
</code></pre>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>
服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h1 id="三-jwt-的数据结构">三、JWT 的数据结构</h1>
<pre><code class="language-js">    const accessToken =    &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1597647417511.png" alt="" loading="lazy"></figure>
<p>JWT 的三个部分依次如下:</p>
<pre><code class="language-cmd">Header（头部）
Payload（负载）
Signature（签名）
</code></pre>
<p>写成一行，就是下面的样子。<br>
Header.Payload.Signature<br>
下面依次介绍这三个部分。</p>
<h2 id="header">Header</h2>
<p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<pre><code class="language-json">{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>
最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h2 id="payload">Payload</h2>
<p>载荷就是存放有效信息的地方。这些有效信息包含三个部分:<br>
标准中注册的声明<br>
公共的声明<br>
私有的声明<br>
Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<pre><code class="language-cmd">iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
</code></pre>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<pre><code class="language-json">{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}
</code></pre>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>
这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h2 id="signature">Signature</h2>
<p>JWT的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64加密)</li>
<li>payload (base64加密)</li>
<li>secret 密钥<br>
Signature 部分是对前两部分的签名，防止数据篡改。<br>
首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</li>
</ul>
<pre><code class="language-cmd">HMACSHA256(
  base64UrlEncode(header) + &quot;.&quot; +
  base64UrlEncode(payload),
  secret)
</code></pre>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（.）分隔，就可以返回给用户。</p>
<p><strong>注意</strong>：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的<code>私钥</code>，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以<code>自我签发jwt</code>了。如果觉得密钥泄露了，请及时修改。</p>
<h2 id="base64url">Base64URL</h2>
<p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>
JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+、/和=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h1 id="五-jwt-的几个特点">五、JWT 的几个特点</h1>
<p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>
（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>
（3）JWT 不仅可以<code>用于认证</code>，也可以用于<code>交换信息</code>。有效使用 JWT，可以<code>降低服务器查询数据库的次数</code>。<br>
（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>
（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>
（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<p>案例：request.js</p>
<pre><code class="language-js">import axios from 'axios'
import global from '../../api/global'
import router from '../../router/router'
// 拿到token
function getAccessToken() {
    // 从localStorage中获取token
    //let accessToken = localStorage.getItem('accessToken')
    const accessToken = &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
    if (accessToken != null&amp;&amp; refreshToken !== undefined) {
        return &quot;Bearer &quot; + accessToken
    }
}

// 创建一个axios实例
const axiosJWT = axios.create({
    baseURL: global.API,
    timeout: 300000,
    headers: {
        'Authorization': getAccessToken(),
        &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
    }
})

async function refreshToken() {    //之前的逻辑是去发送请求拿到刷新的token(refreshToken)
    // instance是当前request.js中已创建的axios实例
    // return await axiosBASIC.get('/auth/reissueToken', {
    //   params: {
    //     refreshToken: getRefreshToken()
    //   }
    // })
    return await axiosBASIC.get('/auth/issueToken', {
    params: {
      openId: &quot;oV76BwiaUXpg1aJ6KTCoxPmjiDx4&quot;
    }
  })
}


// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中
axiosJWT.setToken = (accessToken) =&gt; {
    localStorage.setItem('accessToken', accessToken)
    axiosJWT.defaults.headers['Authorization'] = &quot;Bearer &quot;+accessToken
}

// 是否正在刷新的标记
let isRefreshing = false
// 重试队列，每一项将是一个待执行的函数形式
let requests = []


// 响应拦截
axiosJWT.interceptors.response.use(response =&gt; {
        const {code} = response.data
        // 接下来会在这里进行token过期重发逻辑处理
        switch(code){
            case 604:
                //非法token！
                break
            case 603:
                //缺少token！
            case 605:
                //accessToken已过期！
                //获取当前失败的请求
                const config = response.config
                if (!isRefreshing) {
                    isRefreshing = true
                   return refreshToken()
                        .then(res =&gt; {
                            const {code} = res.data
                            switch(code){
                                case 200:
                                    //refreshToken有效，刷新Token成功
                                    //将最新的token更新到header中，同时保存在localStorage中
                                    const {accessToken} = res.data.data
                                    console.log('access_token====='+accessToken)
                                    axiosJWT.setToken(accessToken)
                                    // 刷新下之前的请求配置
                                    config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
                                    config.baseURL = ''
                                    //已经刷新了token，将所有队列中的请求进行重试
                                    requests.forEach(cb =&gt; cb(accessToken))
                                    //清空队列
                                    requests = []
                                    // 重试之前的请求并返回promise
                                    return axiosJWT(config)
                                case 500:
                                case 606:
                                    //refreshToken过期
                                   router.push(&quot;/auth&quot;)
                            }
                        })
                        .finally(() =&gt; {
                            //刷新成功，恢复标志位
                            isRefreshing = false
                        })
                } else {
                    // 正在刷新token，返回一个未执行resolve的promise
                    return new Promise((resolve) =&gt; {
                        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行
                        requests.push((accessToken) =&gt; {
                            config.baseURL = ''
                            config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
                            resolve(axiosJWT(config))
                        })
                    })
                }
            case 701:
                //JWT认证失败!
                break
            default: 
            return response.data
        }
    },error =&gt; {
        return Promise.reject(error)
    })

export  {
    axiosJWT,
    axiosBASIC
}
</code></pre>
<h1 id="六-什么是单点登录">六、什么是单点登录</h1>
<p><img src="https://cutezhangq.github.io/post-images/1598427024701.jpg" alt="" loading="lazy"><br>
单点登录的英文名叫做：Single Sign On（简称SSO）。<br>
在初学/以前的时候，一般我们就单系统，所有的功能都在同一个系统上。<br>
<img src="https://cutezhangq.github.io/post-images/1598356039400.png" alt="" loading="lazy"></p>
<p>后来，我们为了合理利用资源和降低耦合性，于是把单系统拆分成多个子系统。<br>
回顾：分布式基础知识</p>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598356074130.png" alt="" loading="lazy"></figure>
<p>比如阿里系的淘宝和天猫，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。<code>不需要用户重复登录</code><br>
简单来说，<strong>单点登录就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录</strong>。<br>
众所周知，HTTP是无状态的协议，这意味着服务器无法确认用户的信息。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。<br>
如果说<strong>Cookie</strong>是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session</strong>相当于在服务器中建立了一份“客户明细表”。<br>
<code>Cookie：令牌（识别身份）</code><br>
<code>Session：花名册（核对身份）</code><br>
所以，一般我们单系统实现登录会这样做：</p>
<ul>
<li><strong>登录</strong>：将用户信息保存在Session对象中
<ul>
<li>如果在Session对象中能查到，说明已经登录</li>
<li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li>
</ul>
</li>
<li><strong>注销（退出登录）</strong>：从Session中删除用户的信息</li>
<li><strong>记住我（关闭掉浏览器后，重新打开浏览器还能保持登录状态）</strong>：配合Cookie来用</li>
</ul>
<h1 id="实战基于云平台的儿童英语听说交互系统">实战（基于云平台的儿童英语听说交互系统）</h1>
<p>1、代码进入main.js页面，通过路由拦截</p>
<ul>
<li>当已经登录（sessionStorage 中存了状态isLogin），则跳转要前往的页面；</li>
<li>当没有存储isLogin或进入设置设备页，则进入login.vue页面
<ul>
<li>注：使用sessionStorage 是为了即时更新登录态（浏览器未关闭，第一次获取完isLogin，后面的请求就都授权了，但是当浏览器关闭了，就要重新授权）</li>
</ul>
</li>
</ul>
<p>2、当“没有授权或需要操作设备时” 进入login.vue页面，通过路由拦截（路由守卫）</p>
<ul>
<li>2.1、不是从auth授权页跳转过来的，就存储来的路径（存在sessionStorage中）</li>
<li>2.2、获取存储的需要跳转的路径</li>
<li>2.3、请求login接口（JWT请求）将登陆时间存储到isLogin中</li>
<li>2.4、跳转之前存储的进入页面
<ul>
<li>注：login.vue是用来登陆授权的（在未授权前登陆）</li>
</ul>
</li>
</ul>
<p>3、requset.js（封装JWT的）</p>
<ul>
<li>
<p>axiosJWT 携带请求头（发送Token给后台）</p>
<ul>
<li>Token从localStorage 中获取，能拿到则将token放在请求头中发送过去</li>
<li>后台设置不过期的token，前端将这个token携带在请求头中发过去</li>
</ul>
<pre><code class="language-js">如：const accessToken =       &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
</code></pre>
</li>
<li>
<p>更新Token: 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</p>
<pre><code class="language-js"> axiosJWT.setToken = (accessToken) =&gt; {
        localStorage.setItem('accessToken', accessToken)
        axiosJWT.defaults.headers['Authorization'] = &quot;Bearer &quot;+accessToken
    }
</code></pre>
</li>
<li>
<p>响应拦截 :<code>axiosJWT.interceptors.response.use(response =&gt; { })</code></p>
<ul>
<li>在这里进行token过期重发逻辑处理 :
<ul>
<li>判断code：<code>（604非法token、603缺少token、605token过期、701JWT认证失败、默认： return response.data ）</code></li>
<li>token过期：
<ul>
<li>
<p>1、获取当前失败的请求：const config = response.config</p>
</li>
<li>
<p>2、判断是否进入刷新状态</p>
<ul>
<li>刷新中：</li>
</ul>
<pre><code class="language-js">      // 正在刷新token，返回一个未执行resolve的promise
        return new Promise((resolve) =&gt; {
          // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行
          requests.push((accessToken) =&gt; {
            config.baseURL = ''
            config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
             resolve(axiosJWT(config))
          })
      })
</code></pre>
<ul>
<li>未刷新：<br>
更新刷新状态为：刷新中，返回 refreshToken：(携带固定 openId 请求 /auth/issueToken)</li>
</ul>
<pre><code class="language-js">    async function refreshToken() {
        // instance是当前request.js中已创建的axios实例
        // return await axiosBASIC.get('/auth/reissueToken', {
        //   params: {
        //     refreshToken: getRefreshToken()
        //   }
        // })
        return await axiosBASIC.get('/auth/issueToken', {
        params: {
          openId: &quot;oV76BwiaUXpg1aJ6KTCoxPmjiDx4&quot;
        }
      })
</code></pre>
<p>通过请求后台接口，拿到返回值，响应状态码（200刷新token成功、500后台错误、606 refreshToken过期，跳转auth页面）</p>
<ul>
<li>200 刷新token成功（refreshToken有效）<pre><code class="language-js">//refreshToken有效，刷新Token成功
//将最新的token更新到header中，同时保存在localStorage中
const {accessToken} = res.data.data
axiosJWT.setToken(accessToken)
// 刷新下之前的请求配置
config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
config.baseURL = ''
//已经刷新了token，将所有队列中的请求进行重试
requests.forEach(cb =&gt; cb(accessToken))
requests = []	//清空队列
return axiosJWT(config)	// 重试之前的请求并返回promise
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>error ：<code>返回失败信息 return Promise.reject(error)</code></li>
</ul>
</li>
<li>
<p>axiosBASIC （auth页使用）</p>
<ul>
<li>
<pre><code>const BASIC_TOKEN = &quot;b3JhbmdlMjpvcmFuZ2UyLXNlY3JldA==&quot; 
</code></pre>
</li>
</ul>
</li>
</ul>
<p>4、auth页（ 进行路由拦截 ）</p>
<ul>
<li>4.1、需要跳转的不是auth页时：
<ul>
<li>
<pre><code>`sessionStorage.setItem(&quot;authBackUrl&quot;, from.path)`
</code></pre>
</li>
</ul>
</li>
<li>4.2、获取url中的code<code>let code = myUtils.getUrlArg(&quot;code&quot;);</code></li>
<li>4.3、url中是否携带code：
<ul>
<li>code不为null（url中携带了code）
<ul>
<li>取出之前需要跳转的地址 authBackUrl</li>
</ul>
</li>
</ul>
<pre><code class="language-js">    //携带code请求后台签发token+openid
         axiosBASIC({
            url: &quot;/auth/issueToken&quot;,
            method: &quot;get&quot;,
            params: {
              code: code
            }
        })
</code></pre>
<ul>
<li>请求响应成功200，重新设置<code>accessToken</code>和<code>reflashToken</code></li>
</ul>
<pre><code class="language-js">      let WxUser = res.data
      axiosJWT.setToken(WxUser.accessToken)
      localStorage.setItem(&quot;refreshToken&quot;, WxUser.refreshToken)
</code></pre>
<ul>
<li>路由跳转要去的页面</li>
<li>请求响应701：打印错误</li>
<li>请求响应805：表示未绑定设备，前往Open 页绑定设备</li>
<li>code = null：<code>window.location.href = sysConst.OAUTH2 //请求腾讯OAuth服务器</code></li>
</ul>
</li>
</ul>
<p>通过code拿到open_id，进而拿到Token(由open_id构成)——&gt;open_id不过期，code与Token均会过期</p>
<ul>
<li><code>code</code>：授权码，由微信授权生成（有时间限制，并且只能使用一次）</li>
<li><code>open_id</code>：通过这个授权码code获取该用户的openid（将这个授权码code发送给后台以后，后台用code去请求openid，openid是唯一的，可以通过这个openid在数据库中绑定用户）</li>
<li><code>taken</code>:（后台生成，有时间限制，由open_id组成）</li>
</ul>
]]></content>
    </entry>
</feed>