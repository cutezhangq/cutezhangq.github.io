<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-08-03T10:24:40.879Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[居中方案（水平居中、垂直居中、水平垂直居中）]]></title>
        <id>https://cutezhangq.github.io/post/ju-zhong-fang-an-shui-ping-ju-zhong-chui-zhi-ju-zhong-shui-ping-chui-zhi-ju-zhong/</id>
        <link href="https://cutezhangq.github.io/post/ju-zhong-fang-an-shui-ping-ju-zhong-chui-zhi-ju-zhong-shui-ping-chui-zhi-ju-zhong/">
        </link>
        <updated>2020-08-03T01:10:23.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="案例内容">案例内容</h1>
<pre><code class="language-html"> &lt;style&gt;
    .fu{
      width: 200px;
      height: 200px;
      background-color: powderblue;
    }

  &lt;/style&gt;

    &lt;body style=&quot;background-color: antiquewhite;&quot;&gt;
      &lt;div class=&quot;fu&quot;&gt;
        &lt;h2&gt;这是标题哦&lt;/h2&gt;
        &lt;div class=&quot;zi&quot;&gt;
          &lt;p&gt;哈哈&lt;/p&gt;
          &lt;form action=&quot;&quot;&gt;
            姓名:&lt;input type=&quot;text&quot;&gt;&lt;br /&gt;
            性别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女
            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;br /&gt;
            爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;篮球
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;下棋
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;画画
             &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;写作&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
             &lt;img src=&quot;../bootstrap/img/1.png&quot; alt=&quot;&quot; width=&quot;150px&quot;&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/body&gt;
</code></pre>
<h1 id="水平垂直-居中方案1">水平垂直 居中方案1</h1>
<h3 id="需要知道-宽高">需要知道 宽高</h3>
<pre><code class="language-css">        .fu{
          position: absolute;
          left: 0;
          right: 0;
          bottom: 0;
          top: 0;
          margin: auto;
        }
</code></pre>
<h1 id="水平垂直-居中方案2">水平垂直 居中方案2</h1>
<h3 id="可用于-不知道宽高-的情况下使用">可用于 不知道宽高 的情况下使用</h3>
<p>缺点：transform的兼容性不高</p>
<ul>
<li>translate()函数是css3的新特性,在不知道自身宽高的情况下,可以利用它来进行水平垂直居中</li>
<li>当使用: top: 50%;left: 50%；是以左上角为原点，故不处于中心位置</li>
<li>translate(-50%,-50%)作用是：往上(x轴),左(y轴)移动自身长宽的50%,以使其居于中心位置。</li>
</ul>
<pre><code class="language-css">.fu{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);   //百分比是相对于自身宽高的百分比
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596418063196.png" alt="" loading="lazy"></figure>
<h1 id="对于仅文本内容的需要居中的也可使img标签对于div标签-水平居中">对于仅文本内容的，需要居中的：(也可使Img标签对于div标签 水平居中)</h1>
<pre><code class="language-css">h2{
    text-align: center;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1596417930705.png" alt="" loading="lazy"></figure>
<h1 id="表格中内容水平垂直居中">表格中内容水平垂直居中：</h1>
<pre><code class="language-css">.table&gt;tbody&gt;tr&gt;td{
  vertical-align: middle;
  text-align: center;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="案例内容">案例内容</h1>
<pre><code class="language-html"> &lt;style&gt;
    .fu{
      width: 200px;
      height: 200px;
      background-color: powderblue;
    }

  &lt;/style&gt;

    &lt;body style=&quot;background-color: antiquewhite;&quot;&gt;
      &lt;div class=&quot;fu&quot;&gt;
        &lt;h2&gt;这是标题哦&lt;/h2&gt;
        &lt;div class=&quot;zi&quot;&gt;
          &lt;p&gt;哈哈&lt;/p&gt;
          &lt;form action=&quot;&quot;&gt;
            姓名:&lt;input type=&quot;text&quot;&gt;&lt;br /&gt;
            性别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女
            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;br /&gt;
            爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;篮球
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;下棋
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;画画
             &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;写作&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
             &lt;img src=&quot;../bootstrap/img/1.png&quot; alt=&quot;&quot; width=&quot;150px&quot;&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/body&gt;
</code></pre>
<h1 id="水平垂直-居中方案1">水平垂直 居中方案1</h1>
<h3 id="需要知道-宽高">需要知道 宽高</h3>
<pre><code class="language-css">        .fu{
          position: absolute;
          left: 0;
          right: 0;
          bottom: 0;
          top: 0;
          margin: auto;
        }
</code></pre>
<h1 id="水平垂直-居中方案2">水平垂直 居中方案2</h1>
<h3 id="可用于-不知道宽高-的情况下使用">可用于 不知道宽高 的情况下使用</h3>
<p>缺点：transform的兼容性不高</p>
<ul>
<li>translate()函数是css3的新特性,在不知道自身宽高的情况下,可以利用它来进行水平垂直居中</li>
<li>当使用: top: 50%;left: 50%；是以左上角为原点，故不处于中心位置</li>
<li>translate(-50%,-50%)作用是：往上(x轴),左(y轴)移动自身长宽的50%,以使其居于中心位置。</li>
</ul>
<pre><code class="language-css">.fu{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);   //百分比是相对于自身宽高的百分比
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596418063196.png" alt="" loading="lazy"></figure>
<h1 id="对于仅文本内容的需要居中的也可使img标签对于div标签-水平居中">对于仅文本内容的，需要居中的：(也可使Img标签对于div标签 水平居中)</h1>
<pre><code class="language-css">h2{
    text-align: center;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1596417930705.png" alt="" loading="lazy"></figure>
<h1 id="表格中内容水平垂直居中">表格中内容水平垂直居中：</h1>
<pre><code class="language-css">.table&gt;tbody&gt;tr&gt;td{
  vertical-align: middle;
  text-align: center;
}
</code></pre>
<!-- more -->
<h1 id="10种-水平垂直居中对齐方式">10种 水平垂直居中对齐方式</h1>
<p>测试代码</p>
<pre><code class="language-html"> &lt;div class=&quot;wp&quot;&gt;
    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;
 &lt;/div&gt;
</code></pre>
<pre><code class="language-css">/* 公共代码 */
.wp {
border: 1px solid red;
width: 300px;
height: 300px;
}

.box {
background: green;
}

.box.size{
width: 100px;
height: 100px;
}
/* 公共代码 */
</code></pre>
<h2 id="absolute-负margin-需要知道子元素的宽高">absolute + 负margin 需要知道子元素的宽高</h2>
<ul>
<li>绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示。</li>
<li>但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示</li>
<li>为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了</li>
</ul>
<pre><code class="language-css">/* 定位代码 */
.wp {
    position: relative;
}
.box {
    position: absolute;;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
</code></pre>
<h2 id="absolute-margin-auto-见上面内容">absolute + margin auto 见上面内容</h2>
<h2 id="absolute-transform-见上面内容">absolute + transform 见上面内容</h2>
<h2 id="absolute-calc-这种方法兼容性依赖calc的兼容性缺点是需要知道子元素的宽高">absolute + calc        这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高</h2>
<p>感谢css3带来了calc 计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了</p>
<pre><code class="language-css">.wp {
position: relative;
}
.box {
position: absolute;;
top: calc(50% - 50px);
left: calc(50% - 50px);
}
</code></pre>
<h2 id="lineheight">lineheight</h2>
<p>利用行内元素 居中属性也可以做到水平垂直 居中，<br>
把box设置为行内元素，通过text-align就可以做到水平居中，但很多同学可能不知道通过通过vertical-align也可以在垂直方向做到居中</p>
<p>/* 定位代</p>
<pre><code class="language-css">/* 定位代码 */
.wp {
line-height: 300px;
text-align: center;
font-size: 0px;
}
.box {
font-size: 16px;
display: inline-block;
vertical-align: middle;
line-height: initial;
text-align: left; /* 修正文字 */
}
</code></pre>
<p>这种方法需要在子元素中将文字显示重置为想要的效果<br>
<img src="https://cutezhangq.github.io/post-images/1596444057505.png" alt="" loading="lazy"></p>
<h2 id="writing-mode">writing-mode</h2>
<p>简单来说writing-mode可以改变文字的显示方向，比如可以通过writing-mode让文字的显示变为垂直方向</p>
<pre><code class="language-html">&lt;div class=&quot;div1&quot;&gt;水平方向&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;垂直方向&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.div2 {
   writing-mode: vertical-lr;
}
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596444154555.png" alt="" loading="lazy"><br>
更神奇的是所有水平方向上的css属性，都会变为垂直方向上的属性，比如text-align，通过writing-mode和text-align就可以做到水平和垂直方向的居中了，只不过要稍微麻烦一点</p>
<pre><code class="language-css">/* 此处引用上面的公共代码 */
/* 此处引用上面的公共代码 */

/* 定位代码 */
.wp {
writing-mode: vertical-lr;
text-align: center;
}
.wp-inner {
writing-mode: horizontal-tb;
display: inline-block;
text-align: center;
width: 100%;
}
.box {
display: inline-block;
margin: auto;
text-align: left;
}
</code></pre>
<h2 id="table">table</h2>
<p>曾经table被用来做页面布局，现在没人这么做了，但table也能够实现水平垂直居中，但是会增加很多冗余代码</p>
<pre><code class="language-css">.wp {
text-align: center;
}
.box {
display: inline-block;
}
</code></pre>
<h2 id="css-table">css-table</h2>
<p>css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中<br>
下面通过css属性，可以让div显示的和table一样<br>
这种方法和table一样的原理，但却没有那么多冗余代码，兼容性也还不错</p>
<pre><code class="language-css">.wp {
display: table-cell;
text-align: center;
vertical-align: middle;
}
.box {
display: inline-block;
}
</code></pre>
<h2 id="flex">flex</h2>
<p>flex作为现代的布局方案，颠覆了过去的经验，只需几行代码就可以优雅的做到水平垂直居中</p>
<pre><code class="language-css">.wp {
    display: flex;
    justify-content: center;
    align-items: center;
}
</code></pre>
<h2 id="grid">grid</h2>
<p>css新出的网格布局，由于兼容性不太好，一直没太关注，通过grid也可以实现水平垂直居中</p>
<pre><code class="language-css">.wp {
    display: grid;
}
.box {
    align-self: center;
    justify-self: center;
}
</code></pre>
<h1 id="总结">总结</h1>
<pre><code>* PC端有兼容性要求，宽高固定，推荐absolute + 负margin
* PC端有兼容要求，宽高不固定，推荐css-table
* PC端无兼容性要求，推荐flex
* 移动端推荐使用flex
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[进程, 线程, 浏览器内核, js执行顺序 WebWorkers]]></title>
        <id>https://cutezhangq.github.io/post/jin-cheng-xian-cheng-liu-lan-qi-nei-he-js-zhi-xing-shun-xu/</id>
        <link href="https://cutezhangq.github.io/post/jin-cheng-xian-cheng-liu-lan-qi-nei-he-js-zhi-xing-shun-xu/">
        </link>
        <updated>2020-08-02T13:48:44.000Z</updated>
        <content type="html"><![CDATA[<p>进程process ：程序的一次执行，它占有一片独有的内存空间<br>
可以通过windows任务管理器查看进程</p>
<p>线程thread：是进程内的一个独立执行单元<br>
是程序执行的一个完整流程<br>
是CPU的最小的调度单元</p>
<p>多线程：一个进程里面有多个线程，一个程序可以同时启动对个实例运行。<br>
单线程：一个进程里面只有一个线程。（JS是单线程的，但是用H5中的Web Workers可以多线程运行）<br>
<strong>js执行顺序</strong><br>
1、js是单线程，执行模式有两种：同步，异步<br>
　　单线程：只有一条流水线<br>
　　同步：依次再流水线上执行<br>
　　异步：流水线旁加了一个临时储物台（任务队列），会把某些模块拿到临时储物台，或者会把临时储物台的某些模块插队到流水线<br>
2、js默认模式是同步模式，按流水线执行:A,B,C，不管A里边代码运行时间多长，都要先执行完A，再执行B，再执行C<br>
3、实现异步模式的几种方法<br>
　　①回调函数（把临时储物台的模块插入到流水线）<br>
　　②setTimeout（把流水线的模块拿到临时储物台，过一段时间再插入回去）<br>
　　③Promise对象（把临时储物台的模块插入到流水线）<br>
4、小程序中所有的wx.xxx()接口，也都是异步模式（先执行流水线上非wx.xxx的模块，把流水线上所有的wx.xxx模块先拿到临时储物台执行，等哪个有了返回结果，并且流水线上有空了，也就是流水线上非wx.xxx的模块执行完了，再把哪个插回去）<br>
5、async函数中，代码的执行模式是异步模式，所有的模块都放在临时储物台上执行，哪个模块执行完了，就先把哪个模块拿到流水线上执行<br>
6、举例</p>
<pre><code class="language-js">  jobs.add({
      data: {
        userName: 'aaa'
      }
    })
    .then(res =&gt; {
      wx.hideLoading({
        success: res =&gt; {
          console.log('hideLoading')
        }
      })
      wx.showToast({
        title: '提交成功',
        icon: 'success',
        duration: 2000
      })
      wx.switchTab({
        url: '../my/my',
      })
      console.log('aaaa')
    })
    .catch(err =&gt; {
      console.log(err)
    })
</code></pre>
<p>执行顺序分析：<br>
把wx.hideLoading，wx.showToast，wx.switchTap先放到临时储物台，并执行执行流水线上的console.log('aaaa')，流水线上有空了，把临时储物台上最先有了返回结果的wx.hideLoading插入回流水线执行，流水线上有空了，又把第二个有了返回结果的wx.switchTab插入回流水线执行<br>
显示顺序：aaaa，hideLoading，跳转<br>
7、if...else if....else会按照顺序执行，先执行if，再执行else if，再执行else<br>
8、for循环是先执行完内部的循环，再跳出循环，for循环后面的代码，必须for循环完成后才能执行</p>
<h1 id="js引擎j">js引擎j</h1>
<p>js引擎执行代码的基本流程：    初始化代码---&gt;回调代码script 引入方式</p>
<pre><code>* html 静态&lt;script&gt;引入
* js 动态插入&lt;script&gt;
* &lt;script defer&gt;: 延迟加载，元素解析完成后执行
* &lt;script async&gt;: 异步加载，但执行时会阻塞元素渲染
</code></pre>
<h1 id="web-workers">Web Workers</h1>
<p>1.H5规范了js 分线程的实现，取名为:Web Workers    （但是 js 仍然是 单线程 的）</p>
<p>2.相关API:<br>
Worker:  构造函数，加载分线程执行的js文件<br>
Worker.prototype.onmessage： 用于接收另一个线程的回调函数<br>
Worker.protptype.postMessage:  向另一个线程发送消息</p>
<p>3.不足：</p>
<ol>
<li>Worker内代码不能操作DOM（更新UI）：因为他的全局变量不再是window</li>
<li>不能跨域加载JS</li>
<li>不是每个浏览器都支持这个新特性</li>
</ol>
<p>Web Workers使用：<br>
在主线程的JS中 发消息并设置回调：</p>
<p>主线程中的代码：</p>
<pre><code class="language-js">&lt;body&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;数值&quot; id=&quot;number&quot;/&gt;
  &lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
  //斐波那契数 1 1 2 3 5 8  f(n)=f(n-1)+f(n-2)
  function fibonacci(n){
    return n&lt;2? 1 : fibonacci(n-1) + fibonacci(n-2)
  }
  var input = document.getElementById('number');
  document.getElementById('btn').onclick = function(){
    var number = input.value;
    //创建一个Worker对象，并向它传递在新线程中脚本的URL
    var worker = new Worker('worker.js');
    //绑定接收消息的监听
    worker.onmessage = function(event){ //onmessage当接收到消息时，自动回调
      console.log('主线程接收分线程返回的数据'+event.data);
      // console.log(event.data);
    }
    //向分线程发送消息
    worker.postMessage(number);
    console.log('主线程向分线程发送数据'+number);
  }
</code></pre>
<p>分线程中的代码：<br>
分线程不能更新界面，因为在分线程中看不到window<br>
<img src="https://cutezhangq.github.io/post-images/1596377870491.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1596377904673.png" alt="" loading="lazy"><br>
总结：</p>
<ol>
<li>分线程中的全局对象不再是window，所以在分线程中不可能更新界面</li>
<li>postMessage可以双向发送消息，一个一个发送<br>
<img src="https://cutezhangq.github.io/post-images/1596377925811.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内存溢出与内存泄漏]]></title>
        <id>https://cutezhangq.github.io/post/nei-cun-yi-chu-yu-nei-cun-xie-lou/</id>
        <link href="https://cutezhangq.github.io/post/nei-cun-yi-chu-yu-nei-cun-xie-lou/">
        </link>
        <updated>2020-08-02T13:38:29.000Z</updated>
        <content type="html"><![CDATA[<p>闭包的缺点：<br>
1.函数执行完后，函数内的局部变量没有被释放，占用内存时间会变长<br>
2.容易造成内存泄漏（内存被占用着，但用不上里面的内容）<br>
解决：<br>
1.尽量不用闭包<br>
2.及时释放（让内部函数成为垃圾对象--&gt;就收闭包） 即 f = null<br>
<img src="https://cutezhangq.github.io/post-images/1596375551223.png" alt="" loading="lazy"><br>
内存溢出与内存泄漏:内存溢出：<br>
一种程序运行出现的错误。<br>
当程序运行的内存超过了剩余的内存时，就抛出内存溢出的错误<br>
<img src="https://cutezhangq.github.io/post-images/1596375576188.png" alt="" loading="lazy"><br>
注：是一种抛出错误，浏览器会崩溃</p>
<p>内存泄漏：<br>
占用的内存没有及时释放<br>
内存泄漏积累多了就容易导致内存溢出<br>
常见的内存泄漏：<br>
1.意外的全局变量<br>
2.没有及时清理的计时器或回调函数<br>
3.闭包</p>
<p><code>1.意外的全局变量</code><br>
<img src="https://cutezhangq.github.io/post-images/1596375625382.png" alt="" loading="lazy"><br>
<code>2.没有及时清理的计时器或回调函数，清理定时器</code>：clearInterval( )<br>
<img src="https://cutezhangq.github.io/post-images/1596375657343.png" alt="" loading="lazy"><br>
<code>3.闭包</code><br>
<img src="https://cutezhangq.github.io/post-images/1596375936764.png" alt="" loading="lazy"><br>
面试重点：<br>
1.this的指向<br>
<img src="https://cutezhangq.github.io/post-images/1596375977020.png" alt="" loading="lazy"><br>
输出：The window<br>
注：不属于闭包（有函数嵌套，但没有内部函数引用外部函数）</p>
<ol start="2">
<li>var that = this    指定局部作用域<br>
<img src="https://cutezhangq.github.io/post-images/1596376032467.png" alt="" loading="lazy"><br>
输出：My Object<br>
注：属于闭包</li>
</ol>
<p>3.闭包问题</p>
<pre><code class="language-js">function fun(n,o){
  console.log(o);
  return {
    fun:function(m){
      return fun(m,n);
    }
  }
}
var a = fun(0); a.fun(1); a.fun(2); a.fun(3); //undefined ,0 ,0 ,0
console.log('——————————');
var b = fun(0).fun(1).fun(2).fun(3);  //undefined ,0 ,1 ,2
console.log('——————————');
var c = fun(0).fun(1); c.fun(2);  c.fun(3); //undefined ,0 ,1 ,1

</code></pre>
<p>分析：<br>
a中，<br>
a.fun(1)时m=1,n=0（闭包，内部n调用外部传入的0）,然后内部的fun:function这个走完回到外面函数，将0传给o，然后console.log(o)得到 0<br>
a.fun(2)时m=2,n=0，然后到外面函数中n=2,o=0，然后console.log(o)得到 0</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建对象4种方式]]></title>
        <id>https://cutezhangq.github.io/post/chuang-jian-dui-xiang-4-chong-fang-shi/</id>
        <link href="https://cutezhangq.github.io/post/chuang-jian-dui-xiang-4-chong-fang-shi/">
        </link>
        <updated>2020-08-02T12:07:55.000Z</updated>
        <content type="html"><![CDATA[<p>变量与对象的区别<br>
变量：只能存一个数据<br>
对象：可以存多个数据（属性、封装...）<br>
对象的组成：<br>
属性（属性名 String类型，属性值 任意类型）<br>
方法（一种特别的属性，属性值是函数）</p>
<p>访问 对象内部数据 的方法    (中括号运算符总是能代替点运算符。但点运算符却不一定能全部代替中括号运算符。)<br>
. 点 属性名        后面加静态标志符<br>
当对象内部没有定义该属性时不能使用。<br>
[' 属性名 ']        后面可以加动态标志符<br>
当属性名包含特殊字符：-  空格，必须使用[' ']；<br>
当属性名 不确定时，必须使用[' ']；</p>
<p>常用：点是访问json对象。而方括号是数组。   obj.name='xx'  ;  arr[0] = 1</p>
<pre><code class="language-js">//访问对象内部属性
var person = {
  name:'cutezhangq',
  age:20,
  setName:function(name){
    this.name = name      //改变person对象的name属性，this是局部作用域内的对象，即person
  },
  setAge:function(age){
    this.age = age
  }
}
console.log(person)                 //Object {name: &quot;cutezhangq&quot;, age: 20, setName: , setAge: }
//采用 点 的方式，访问对象内部属性
person.setName('zhuangzhou');  
console.log(person)                 //Object {name: &quot;zhuangzhou&quot;, age: 20, setName: , setAge: }
//采用['']的方式，[''](值)  这种是给该属性赋值
person['setAge'](100);
console.log(person)                 //Object {name: &quot;zhuangzhou&quot;, age: 100, setName: , setAge: } 

</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596370140753.png" alt="" loading="lazy"><br>
什么时候必须使用['属性名']？<br>
中括号运算符可以用字符串变量的内容作为属性名。点运算符不能。<br>
中括号运算符可以用纯数字为属性名。点运算符不能。<br>
中括号运算符可以用js的关键字和保留字作为属性名。点运算符不能。</p>
<pre><code class="language-js">var p= {},b = {};
//给对象添加属性：content-type:text/json
//p.content-type不可以使用,含义特殊字符 - 
p['content-type'] = 'text/json';
console.log(p['content-type']);   //text/json
//属性名 不确定
var propName = 'age';
var value = 20;
// p.propName = value;  //报错
b[propName] = value;
console.log(b);   //Object {age: 20}
//——————————————————————————————————————————————————————
var obj={
         say1:1,
         say2:2,
         say3:3
        }
 
for(let i=1; i&lt;Object.keys(obj).length+1; i++){
    console.log(obj[&quot;say&quot;+i]);  
}
//  1
//  2
//  3
</code></pre>
<p>创建对象的四种方式：<br>
<strong>系统的构造函数Object</strong><br>
<strong>自定义构造函数</strong><br>
<strong>字面量的方式</strong><br>
<strong>工厂化模式</strong></p>
<pre><code class="language-js">//创建对象的4中方式
//1.调用 系统的构造函数Object 创建对象（per2.name=&quot; &quot;）
var person = new Object();
person.name = 'cutezhangq';
person.age = 20;
person.key = function(i){
  console.log('给实例自定义方法'+i);
}
console.log(person);  //Object {name: &quot;cutezhangq&quot;, age: 20, key: }
person.key(123)       //给实例自定义方法123



//2.自定义构造函数    (申请一块空闲的空间,首字母一般大写)
function stu(name,age){
  this.name = name;
  this.age = age;
  this.say = function(){
    return console.log(&quot;我叫：&quot;+this.name,&quot;,年龄是:&quot;+this.age);
  };
}
var stu_zq = new stu('ccc',22);
stu_zq.say();    //我叫：ccc ,年龄是:22
for(var key in stu_zq){
  console.log('key:'+key+',value:'+stu_zq[key])
}
//  key:name,value:ccc
//  key:age,value:22
//  key:say,value:function(){ return console.log(&quot;我叫：&quot;+this.name,&quot;,年龄是:&quot;+this.age);  }



//3.字面量的方式创建对象
var obj = {
  name:'piu',
  age:20,
  eat:function(){
    console.log('wowowo');
  }
}
obj.eat();  //wowowo
console.log(obj.name);  //piu
//3.1
var b1 = {
  b2:[1,'aaa',console.log],
  b3:function(){
    console.log('b3');
    return function(){
      return 'yiny';
    }
  }
}
console.log(typeof b1.b2[2])  //function  说明console.log是函数
console.log(b1.b3()())  //yiny
//b1.b3() 找到b3属性里的函数
//b1.b3()() 找到函数里的return的函数



//4.工厂化模式创建对象（批量制作对象）  采用createObject批量化生产，能实例化多个具有相似属性和方法的对象
function createObject(name,age){
  var obj = new Object;
  obj.name = name;
  obj.age = age;
  return obj;
}
var per1 = createObject(&quot;xixi&quot;,23);
var per2 = createObject(&quot;hihi&quot;,53);
console.log(per1);  //Object {name: &quot;xixi&quot;, age: 23}
console.log(per2);  //Object {name: &quot;hihi&quot;, age: 53}
console.log(createObject);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[变量的生命周期 let、var、const]]></title>
        <id>https://cutezhangq.github.io/post/js-bian-liang-de-sheng-ming-zhou-qi-letvarconst/</id>
        <link href="https://cutezhangq.github.io/post/js-bian-liang-de-sheng-ming-zhou-qi-letvarconst/">
        </link>
        <updated>2020-08-02T11:34:39.000Z</updated>
        <content type="html"><![CDATA[<p>具体let、var、consts区别见es6中内容</p>
<h1 id="变量的生命周期">变量的生命周期</h1>
<p>当引擎（如：浏览器中的js引擎）访问变量的时候，它们的生命周期包括下面几个阶段：<br>
1.<strong>声明 阶段</strong>：在作用域中注册一个变量<br>
2.<strong>初始化 阶段</strong>：分配内存，给作用域中的变量创建绑定。在这个阶段，变量自动地被初始化为 undefined<br>
3.<strong>赋值 阶段</strong>：给已经初始化过的变量赋值<br>
通过声明阶段但是没有到达初始化阶段的变量是处于未定义的状态。<br>
<img src="https://cutezhangq.github.io/post-images/1596368154142.png" alt="" loading="lazy"><br>
注意，根据变量的生命周期，声明阶段和一般说的变量声明是不同的术语。<br>
简言之，引擎在这三个阶段处理变量声明：声明阶段、初始化阶段和赋值阶段。</p>
<h1 id="var-变量-的生命周期">var 变量 的生命周期</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596368206711.png" alt="" loading="lazy"><br>
严格来说，提升的概念是在函数作用域的顶部 声明和初始化 变量。在 声明和初始化 阶段之间 没有间隙。</p>
<pre><code class="language-js">function multiplyByTen(number) {  
  console.log(ten); // =&gt; undefined
  var ten;
  ten = 10;
  console.log(ten); // =&gt; 10
  return number * ten;
}
multiplyByTen(4); // =&gt; 40
</code></pre>
<h1 id="函数声明的生命周期">函数声明的生命周期</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596368259214.png" alt="" loading="lazy"><br>
声明、初始化、赋值阶段在 函数作用域 的开始 立刻执行（只有一步）。<br>
funcName()可以在该作用域的任何地方调用，不依赖于声明语句的位置（甚至可以在最后）。</p>
<h1 id="let-变量的生命周期">let 变量的生命周期</h1>
<p>let变量的处理方式和 var 不同。最主要的区别就是声明和初始化阶段被分开了。<br>
<img src="https://cutezhangq.github.io/post-images/1596368317409.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1596368337198.png" alt="" loading="lazy"></p>
<pre><code class="language-js">  let condition = true;  
  // console.log(number); // =&gt; Throws ReferenceError
  let number;
  console.log(number); // =&gt; undefined
  number = 5;
  console.log(number); // =&gt; 5
</code></pre>
<p>const和class类型 和let有相同的生命周期，除了赋值只能发生一次。</p>
<h3 id="为什么提升在let的生命周期里无效">为什么提升在let的生命周期里无效</h3>
<p>如上所述，<code>提升就是变量在作用域顶部进行声明和初始化。</code><br>
但是<code>let的生命周期</code>将 <code>声明和初始化</code> 两个阶段 <code>解耦</code> 了。<code>解耦让提升这个术语失效了</code>。<br>
两个阶段中间的间隙创建了暂时性死区，在这里，变量不能被访问。</p>
<h3 id="暂时性死区">暂时性死区</h3>
<p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre><code class="language-js">var tmp = 123;
if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
</code></pre>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。<br>
在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）</p>
<p>随意使用var声明变量容易犯错。基于这个教训，ES2015创建了let。它使用一种改进的算法来声明变量，并且使用块级作用域。<br>
由于声明和定义两个阶段解耦，提升对于一个let声明的变量（包括包括const和class）无效。在初始化之前，变量处于暂时性死区并且不可以访问。<br>
保持稳定的变量声明，有如下建议：</p>
<ul>
<li>声明、初始化，然后再使用变量。这个流程正确并且容易遵守；</li>
<li>尽可能隐藏变量。变量暴露的越少，代码就越模块化。</li>
</ul>
<p>new运算符的执行过程<br>
*  新生成一个对象<br>
*  链接到原型: obj.<strong>proto</strong> = Con.prototype<br>
*  绑定this:  apply<br>
* 返回新对象(如果构造函数有自己 retrun 时，则返回该值)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js常规问题]]></title>
        <id>https://cutezhangq.github.io/post/js/</id>
        <link href="https://cutezhangq.github.io/post/js/">
        </link>
        <updated>2020-06-16T06:05:13.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
<!-- more -->
<p>当然有些可以合并，引用类型部分也可以归为Object类型一种，故也称7种数据类型（5+1+1）<br>
其中，基本数据类型存储的是实际数据的值；引用数据类型存储的是数据的引用（引用存储在<code>栈</code>里，实际内容存储在<code>堆</code>里）<br>
那么，为啥要分几种不同的数据类型呢？因为我们最终的目的是要使用数据来搞事情~😀，面对庞大的数据必然有许多重复，如果不分类的存储不然会造成混乱。这就需要我们对数据进行分类存储了。</p>
<!-- more -->
<ul>
<li>
<p>有的数据是直接存储起来，用的时候直接使用就行了，不需要对数据进行改变，这种类型的往往比较简单，所以统称为<strong>基本数据类型</strong>。</p>
</li>
<li>
<p>有的数据存储了之后，再进行使用需要对数据进行改动，可以原始数据就进行改动，也可只对引用的数据进行改动，这种情况就比较复杂了，所以对数据的结构就分出来栈和堆，栈中的数据指向堆中最终存储的数据。这种统称为<strong>引用数据类型</strong>。</p>
</li>
</ul>
<p>🔶局部变量存放在<code>栈</code>中(该方法中声明的变量随着栈的销毁而结束，局部变量只能在方法中有效)；<br>
🔷全局变量存放在<code>堆</code>中(不会随着某个方法执行结束而销毁)</p>
<!-- more -->
<p>那么分好了存储，接下来还要👊使用数据，一般是定义变量来使用存储的数据。但是因为存储类型不同，所以在使用<code>变量</code>定义数据是也有不同的特性(变量的类型是根据其内部存储的数据类型来决定的)：</p>
<ul>
<li>基本变量类型：一个变量要复制另一个变量时，采用 <code>深拷贝</code> ，会开辟一块新的内存空间进行存储，所以数据改变不影响原始数据。变量存放的就是数据值。</li>
<li>引用变量类型：给变量添加属性，采用 点 的方式。一个变量复制引用类型时，采用 <code>浅拷贝</code> ，所以数据改变会影响原数据的值。变量存放的是数据的引用（指针）。</li>
</ul>
<h1 id="不同数据类型之间的运算及比较">不同数据类型之间的运算及比较</h1>
<h2 id="和-的区别">=== 和 == 的区别</h2>
<p>===这种先比较数据的类型，再比较数据的值。<strong>类型</strong>和<strong>值</strong>要完全一样才相等。（不转换类型）<br>
==这种比较值，当类型不同，可先进行转换，<strong>转换完</strong>再比较<strong>值</strong>。<br>
注：==中转换情况如下几种情况：</p>
<ul>
<li><strong>String和Number</strong>：将String按照ASCII转换为数字再进行比较。</li>
<li><strong>Undefined和Null</strong>：这两个实际的值都是false，它们==是<strong>相等</strong>的。</li>
<li><strong>NaN</strong>：只能使用isNaN来检测类型。</li>
<li><strong>boolean与其他类型</strong>：boolean先转为 0 或 1 再进行比较。</li>
<li>如果是<strong>对象和数字比较</strong>：会将对象先转换为基础数据类型。js中🙆一般valueof优先于tostring类型，采用valueof内置类进行转换，🤷‍♀但在data中是tostring采用转换。</li>
</ul>
<p>😃注：即基本的数据类型间比较时，都是转为数字进行比较（ASCII码转）；涉及到对象这种引用变量时，则是转换为字符串进行比较。</p>
<h2 id="不同数据类型间运算">不同数据类型间运算</h2>
<ul>
<li>执行<code>- 、*、/、%</code> 运算时，都转换为数字进行运算。</li>
<li>执行<code>+</code>运算时，分为几种情况：
<ul>
<li>number + String --&gt;String</li>
<li>number + object --&gt;String ，优先调用tostring转换了
<ul>
<li>如：[1].toString() === '1'</li>
<li>如：{}.toString() === '[object Object]'</li>
</ul>
</li>
<li>number + null/boolean --&gt; <strong>数字</strong></li>
<li>number + undefined --&gt; <strong>NaN</strong></li>
</ul>
</li>
</ul>
<h2 id="和-和">&amp;&amp;和||、&amp;和|</h2>
<p>&amp;&amp;和||是逻辑运算符。</p>
<ul>
<li>
<p>&amp;&amp;表示逻辑与，当左边为真时，才执行右边；左边为假，不执行右边。（会短路）</p>
</li>
<li>
<p>| | 表示逻辑或，当左边为真时，执行左边；左边为假，执行右边。<br>
&amp;和|是位运算符。</p>
</li>
<li>
<p>&amp;表示与运算，转换为二进制逐位进行比较，相同位为1，不同位为0，最后输出的二进制再转为十进制输出最后结果。</p>
</li>
<li>
<p>| 表示或运算，转换为二进制逐位进行比较，只要位上有1就为1，位上都为0则为0，最后输出的二进制再转为十进制输出最后结果。<br>
注：&amp;还可以用来判断 奇偶:</p>
</li>
</ul>
<pre><code class="language-javascript">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="数据类型的判断">数据类型的判断</h1>
<p>👉基本数据类型中<strong>null</strong>：采用 <code>String（）</code> 判断<br>
👉<strong>基本数据类型</strong>中除了null的：采用 <code>typeof()</code> 判断<br>
👉<strong>引用数据类型</strong> 中如object、array、Data等：采用 <code>toString()</code> 判断<br>
一种很稳的判断数据类型方法：💖</p>
<pre><code class="language-javascript">let class2type = {};
'Array Date RegExp Object Error'.splice('').forEach(e =&gt; class2type['[object'+e+']'] = e.toLowerCase())
function type(obj){
    if(obj == null){
        return String(obj)
    }
    return typeof obj ==='object'?  class2type[Object.prototype.toString.call(obj)] || 'object': typeof(obj)
}
</code></pre>
<h1 id="如何判断一个变量是对象还是数组">如何判断一个变量是对象还是数组</h1>
<p>判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。</p>
<pre><code class="language-javascript">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>ps：千万不能使用typeof来判断对象和数组，因为这两种类型都会返回&quot;object&quot;。</p>
<h2 id="判断对象为空的3中方法">判断对象为空的3中方法</h2>
<ul>
<li>JSON.stringify(obj) == ‘{}’</li>
<li>for(var a in obj) == true</li>
<li>Object.keys(obj).length() == 0<br>
具体如下：</li>
</ul>
<pre><code class="language-javascript"> //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }

  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象

  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
  t = {};
  if(Object.keys(t).length == 0){   //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="不同数据类型的保存">不同数据类型的保存</h1>
<ul>
<li>基本数据类型：保存在 <code>堆</code>中</li>
<li>引用数据类型：保存在<code>栈</code>中</li>
<li>变量：可能是基本数据也可能是地址值。</li>
</ul>
<h1 id="内存-变量的生命周期">内存、变量的生命周期</h1>
<p>内存：是内存条通电后产生的一定的存储空间。<br>
变量的生命周期：当js引擎访问变量的时候，要经历：变量声明===》变量初始化===》变量赋值<br>
经历从 产生 到 销毁 的过程。<br>
🌰举例：<br>
<code>var</code>变量的生命周期：其中<strong>变量声明</strong>和<strong>变量初始化</strong>这2个阶段没有间隙，<br>
<code>函数声明</code>的生命周期：<strong>变量声明</strong>和<strong>变量初始化</strong>和<strong>变量赋值</strong>这3个阶段没有间隙，<br>
<code>let</code>:变量的生命周期：每段都有间隙，其中<strong>变量声明</strong>和<strong>变量初始化</strong>之间还有<strong>暂时性死区</strong></p>
<h2 id="为什么-提升-在let的生命周期里无效">为什么 提升 在let的生命周期里无效？</h2>
<p><code>提升：就是变量在作用域顶部进行 声明和初始化。</code><br>
因为let中每个阶段都有间隙，<strong>变量声明</strong>和<strong>变量初始化</strong>是解耦的（解耦让提升这个术语失效了），还存在暂时性死区，在这里，变量不能被访问。</p>
<h2 id="new的执行过程">new的执行过程</h2>
<p>1.创建一个对象<br>
2.将对象挂载到原型上<code>obj.__proto__ = Con.prototype</code><br>
3.this的指向<br>
4.返回新对象(如果构造函数有自己 retrun 时，则返回该值)</p>
<h1 id="对象">对象</h1>
<h2 id="访问对象内部数据的方法">访问对象内部数据的方法</h2>
<p>当访问json数据内部值时，一般采用 <code>点</code>的形式；当访问数组中数据时，一般采用<code>[ ]</code>的形式。<br>
其中，<strong>必须</strong>采用<code>[ ]</code>形式的情况有：属性中有特殊字符，如 - 空格 等的，有关键字的，是未定义的属性的。其余的都可采用这2中方式。</p>
<h2 id="创建对象的四种方法">创建对象的四种方法</h2>
<pre><code class="language-javascript">//1.采用系统的构造函数
var obj = new Object();
obj.name = 'zq';
obj.age = 20;
console.log(obj.name+','+obj.age);//zq,20

//2.自定义构造函数
function stu(name,age){
  this.name = name;
  this.age = age;
  this.mmm = 'koko';  //都是this.的形式，此处的this指代stu对象
  console.log(this.name+','+this.age);  //pk,22
}
var p1 = new stu('pk',22);  
console.log(p1.mmm);  //koko

//3.字面量形式
var tea = {
  name:'bobo',
  age:50,
  say:function(){
    console.log('hello js');
  }
}
console.log(tea.name);  //bobo
tea.say();  //hello js

//4.工厂模式    类似于封装了 系统的构造函数，批量生产对象
function createObject(name,age){
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  return obj; //别忘了返回
} 
var stu1 = createObject('stu1',12);
var stu2 = createObject('stu2',13);
console.log(stu1.name+','+stu1.age);//stu1,12
console.log(stu2.name+','+stu2.age);//stu2,13
</code></pre>
<h1 id="函数">函数</h1>
<h2 id="几种常见的回调函数">几种常见的回调函数</h2>
<p>👉dom中的回调函数</p>
<pre><code class="language-javascript"> //1.dom中时间回调函数，包括Node.js中的
  document.getElementById('btn').onclick = function(){
    console.log('诶呀，被点了!');
  }//诶呀，被点了!
</code></pre>
<p>👉定时器</p>
<pre><code class="language-javascript"> //2.定时器
  setTimeout(function(){
    console.log('我是一个定时器');
  },2000)
  console.log('——————');  
  //——————
  //我是一个定时器
</code></pre>
<p>👉ajax请求中的回调函数（包括promise）</p>
<pre><code class="language-javascript">  $.ajax({
    url:'xxx',
    type:'get',
    data:data,
    success:function(data){
      console.log(data);
    }
  })
</code></pre>
<p>👉生命周期中的回调函数</p>
<pre><code class="language-javascript">//如vue中的

</code></pre>
<h2 id="钩子函数和回调函数">钩子函数和回调函数</h2>
<p>两者都是事件处理函数，不同的是：<br>
<strong>钩子函数</strong>：函数<code>调用时触发</code>，本质上是监听函数。<br>
<strong>回调函数</strong>：函数调用<code>结束时触发</code>。</p>
<h2 id="iife">IIFE</h2>
<p>立即调用函数<br>
形式：<code>( 匿名函数自调用 )( )</code>        或者       <code>( 匿名函数自调用 )(参数)</code><br>
作用：</p>
<ul>
<li>隐藏内部内容代码</li>
<li>防止污染全局（外部）命名空间</li>
<li>进行js编码</li>
<li>解决闭包问题（闭包中变量一直无法释放，占用内存）</li>
</ul>
<p>其他几种也是立即执行函数</p>
<pre><code class="language-javascript">(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) () //用括号把函数包起来
!function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()
</code></pre>
<h2 id="函数声明与函数表达式">函数声明与函数表达式</h2>
<p>一、所能放置的 **位置 ** 不同<br>
函数声明：由于有<code>函数提升</code>，所以可以在任意地方声明</p>
<pre><code class="language-javascript">  fnName();
  //函数声明
  function fnName() { 
  }
  //正常，因为‘提升’了函数声明，函数调用可在函数声明之前
</code></pre>
<pre><code class="language-javascript">var fnName = function () {     
    alert('11');
  }();
    //函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数
</code></pre>
<p>二、是否 可以<strong>进行函数立即调用</strong></p>
<ul>
<li>函数声明不可以，只能以fnName()形式调用 。</li>
<li>函数表达式后面可以加括号立即调用该函数。</li>
</ul>
<h1 id="原型原理">原型原理</h1>
<p>1、所有的 引用类型 都有一个_ _ proto_ _ 属性     ( 隐式原型)。<br>
它们的_ _ proto_ <em>属性指向 它的构造函数 的 prototype 属性。<br>
如果对象本身不存在这个属性，那么会去它的</em> _ proto_ _属性 (也就是 它的构造函数的 prototype 属性) 中寻找。<br>
如：girl 的name,sayHello属性，最终是到它的构造函数（Person）的 prototype  属性中寻找</p>
<pre><code class="language-js">function Person(name,age){
      this.name = name;
      this.age = age;
      this.sayHello = function(){
          console.log(this.name + &quot; say hello&quot;);
      }
  }
  var girl = new Person(&quot;bella&quot;,23);
  console.log(girl.name);  //bella
  girl.sayHello(); //bella say hello

</code></pre>
<p>2、所有的 函数 都有一个 prototype 属性    ( 显式原型)。<br>
（prototype既是属性也是对象）这个属性是在 函数创建 的时候添加上的（定义函数的时候）</p>
<p>引用类型： 由类型的实际值引用（类似于指针）表示的数据类型（数组、对象、函数）<br>
构造函数：主要用来在 创建对象时 初始化 对象， 即为 对象成员变量 赋初始值，总与new运算符一起使用在创建对象的语句中。a = new people()<br>
一个类可以有多个构造函数 ，可根据其参数个数的不同 或 参数类型的不同来区分它们----&gt;构造函数的重载。<br>
实例化：用 类 创建对象的过程， 是将一个抽象的概念类，具体到该类实物的过程。<br>
var boy = new Person( );<br>
实例： 通过构造函数和 new 创建出来的对象，便是实例。</p>
<pre><code class="language-js">这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --&gt; true
// o.__proto__ = null;
// o.constructor === Object   --&gt; false
</code></pre>
<p><code>原型、构造函数、实例 关系 图解：</code><br>
<img src="https://cutezhangq.github.io/post-images/1596356775494.png" alt="" loading="lazy"></p>
<p>结论：<br>
1.对象的隐式原型的值__proto__为其 对应 构造函数的显式原型prototype 的值 ——&gt; 实例的__protp__和构造函数的prototype 都是指向原型的</p>
<pre><code class="language-js">function Person(name,height){
     this.name=name;
 }
var boy = new Person('keith');
console.log(boy.__proto__ === Person.prototype);     //true
</code></pre>
<p>通过 调用构造函数 产生的 实例对象，都拥有一个 内部属性，指向了原型对象。<br>
实例对象 能够访问 原型对象上 的所有属性和方法（继承）。(girl 能访问 Person 的所有属性和方法)<br>
如：构造函数：    Person()<br>
原型：         girl 的 <strong>proto</strong>    、Person.prototype<br>
实例对象：   girl<br>
<img src="https://cutezhangq.github.io/post-images/1596356885891.png" alt="" loading="lazy"><br>
<code>原型链 图示：</code></p>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596356873816.png" alt="" loading="lazy"></figure>
<p>使用 原型 自定义方法：</p>
<pre><code class="language-js">
1.prototype属性 指向：
    每个函数 都有一个prototype属性，它默认指向一个object 空对象（原型对象），Object最终是指向 null 空对象的
        如：Date.prototype  返回的是object    
               function.prototype  返回的也是object   
    原型对象 中有一个 属性constructor ,它指向 函数对象（先指向 构造函数，然后 构造函数 最终指向函数对象）
          如：console.log(Person)
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596356964474.png" alt="" loading="lazy"><br>
2.给原型对象添加属性（一般都是方法）<br>
作用：函数的 所有实例对象 自动拥有 原型中的属性（方法）<br>
原型上面的方法是给实例对象使用的<br>
3.prototype与constructor的关系：    相互引用<br>
<img src="https://cutezhangq.github.io/post-images/1596357057951.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1596357062445.png" alt="" loading="lazy"></p>
<p>4.prototype与__proto__的关系：<br>
怎么让两个引用变量指向同一个对象？（如下图）<br>
让一个引用变量 赋值 给另一个引用变量<br>
<img src="https://cutezhangq.github.io/post-images/1596357094861.png" alt="" loading="lazy"><br>
注：new Fn( ) 就是在实例化对象，实例对象的___proto__属性是 js引擎自动添加的</p>
<p>5.原型链 （隐式原型链）<br>
定义：原型链是由原型对象组成，每个对象都有 <strong>proto</strong> 属性，指向了创建该对象的构造函数的原型，<strong>proto</strong> 将对象连接起来组成了原型链。</p>
<p>作用： 共享属性：访问 一个对象的属性<br>
实现继承 ：构造函数的实例对象自动拥有构造函数原型对象的方法（属性）<br>
空Object的原型对象（null） 是原型链的尽头<br>
属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；<br>
属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。<br>
<img src="https://cutezhangq.github.io/post-images/1596357121592.png" alt="" loading="lazy"><br>
原型链的 属性 问题：1.读取对象 的属性值时，会自动到原型链中查找2.设置对象 的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值3.方法 一般定义在原型中，属性一般通过构造函数定义在对象本身上理解：函数的 prototype属性：在定义函数时 自动添加，默认值是一个空object对象对象的 ___proto__属性：创建对象时 自动添加（产生的）,执行语句this.<strong>proto</strong> = Fn.prototype      ,默认值为构造函数的prototype属性值  程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）   :Foo.prototype={ XXX:YYY  }函数大概像抽象的类，是一个高度概括的封装体；                               （抽象的概括）对象则是某个具体的实例，可以使用抽象体的某些特性，通过 对象 点  的方式使用。    （具体的使用）    所以，在使用对象之前要 构造函数 ，即初始化对象   ，相当于创建出一个具体的实例（new 一个对象）              因为：fun = new Function时 自身的显式原型（构造函数）和隐式原型（实例对象）是相等的</p>
<p>判断某个属性是否 属于原型</p>
<pre><code class="language-js">//判断某个属性是否属于原型
function hasPropertyPrototype(object,name){
  return !object.hasOwnProperty(name) &amp;&amp; (name in object);    //不是object原型上的，但是能在原型链上找到
}
</code></pre>
<h1 id="数组">数组</h1>
<h2 id="q如何对一个数组去重">Q：如何对一个数组去重？</h2>
<pre><code class="language-javascript">//1、Set结构去重。
let set = new Set([1,2,3,4,3,2,1,6,'1',NaN,NaN]);
console.log(set);
//Set(6)
// 0: 1
// 1: 2
// 2: 3
// 3: 4
// 4: 6
// 5: &quot;1&quot;
//6: NaN

//2、遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果。
let a = ['1','2','3',1,NaN,NaN,undefined,undefined,null,null, 'a','b','b'];
  let unique = arr =&gt;{
    let newA = [];
    arr.forEach(key =&gt; {
      if(newA.indexOf(key)&lt;0){  //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步
        newA.push(key);
      }
    });
    return newA;
  }
  console.log(unique(a)) ;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;]
  //ps:这个方法不能分辨NaN,会出现两个NaN。是有问题的，下面那个方法好一点。

  //3、遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，
  //以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。
//注意：这个方法会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想想还是Set去重最简单也最有效。
  let b = ['1', '2', '3', 1,NaN,NaN,undefined,undefined,null,null, 'a', 'b', 'b'];
  const unique2 = arr =&gt; {
        var obj = {}
        arr.forEach(value =&gt; {
            obj[value] = 0;//这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去
        })
        return Object.keys(obj);//`Object.keys(对象)`返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组
    }
    console.log(unique2(b));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 模板字符串的前世今生]]></title>
        <id>https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/</id>
        <link href="https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/">
        </link>
        <updated>2020-05-13T08:07:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模板字符串的前世今生">模板字符串的前世今生</h1>
<h2 id="js">JS</h2>
<p>js中，输出模板是这样写的。通过<code>字符串</code>拼接</p>
<pre><code class="language-js">$('#result').append(
 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' +
 'items in your basket, ' +
 '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'
);
</code></pre>
<h2 id="es6">es6</h2>
<p>es6中，输出模板是这样写的。通过<code>${ }嵌入变量</code></p>
<pre><code class="language-js">$('#result').append(`
    There are &lt;b&gt;${basket.count}&lt;/b&gt; items
    in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
    are on sale!
`);
</code></pre>
<h2 id="vue">Vue</h2>
<p>Vue中，输出模板是这样写的。</p>
<pre><code class="language-js">new Vue({
     el:'#replace',
    template:'&lt;p&gt;字符串模板&lt;/p&gt;'
})
</code></pre>
<h2 id="vue20模板的三种写法">Vue2.0模板的三种写法</h2>
<h3 id="第一种利用模板字符串">第一种：利用模板字符串</h3>
<pre><code class="language-js">&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
        el:&quot;#app&quot;,
        data:{ },
        template:`&lt;h1 style=&quot;color:red&quot;&gt;第一种写法&lt;/h1&gt;`
    })
&lt;/script&gt;
</code></pre>
<h3 id="第二种利用template标签实现内容填充通过-id-或者其他的选择器挂载到template上">第二种：利用template标签实现内容填充,通过 id 或者其他的选择器挂载到template上</h3>
<p>通过 id,挂载到template上</p>
<pre><code class="language-js">&lt;template id=&quot;template&quot;&gt;
    &lt;h1&gt;11&lt;/h1&gt;
&lt;/template&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
    ...
    template:&quot;#template&quot;
})
&lt;/script&gt;
</code></pre>
<h3 id="改变script中的type变为typex-template给它id最终挂载到template中">改变script中的type.变为type=&quot;x-template&quot;,给它id,最终挂载到template中</h3>
<p>使用于内容比较多或有公共的模板,可以使用,引入就可以<br>
type=&quot;x-template&quot;，给它id</p>
<pre><code class="language-js">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;x-template&quot; id=&quot;template&quot;&gt;
    &lt;h2&gt;11&lt;/h2&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var app=new Vue({
     ...
    template:&quot;#template&quot;
})
</code></pre>
<h2 id="vue30模板的写法">Vue3.0模板的写法</h2>
<pre><code class="language-js">import Vue from 'vue'
import App from './App.vue'
new Vue({
   ...
    render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 整理]]></title>
        <id>https://cutezhangq.github.io/post/vue/</id>
        <link href="https://cutezhangq.github.io/post/vue/">
        </link>
        <updated>2020-05-13T07:55:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue-简介">Vue 简介</h1>
<p>2014年诞生vue、2013年react、2009年angular<br>
核心：<br>
组件化、<br>
双向数据流（js内存属性变化导致页面的变化、页面的变化影响js内存属性变化）：因为vue是响应式的，会自动更新。<br>
常用指令：v-text、v-html、v-if、v-show<br>
把 vue.js 换成 vue.min.js：可以避免刷新后有时渲染有时不渲染的情况</p>
<pre><code class="language-javascript">&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;  
    &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
  &lt;/div&gt;
 
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
</code></pre>
<p>一个 渐进式 JS框架（核心库，插件）。官网 https://cn.vuejs.org/</p>
<ul>
<li>作用: 动态构建用户界面</li>
</ul>
<h1 id="注意点">注意点</h1>
<h2 id="路由动画">路由动画</h2>
<p>💥出现问题：动画滑动时，最上面的header元素没有置顶，导致最后动画完成时突然向上移动。<br>
✔️解决：</p>
<pre><code class="language-html">&lt;transition :name=&quot;transitionName&quot;&gt;
    &lt;router-view :Event_Play=&quot;Event_Play&quot; class=&quot;transitionBody&quot;&gt;&lt;router-view&gt;
&lt;/transition&gt;
&lt;style lang=&quot;less&quot;&gt;
.transitionBody {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
 }
 &lt;/style&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题]]></title>
        <id>https://cutezhangq.github.io/post/interview-question/</id>
        <link href="https://cutezhangq.github.io/post/interview-question/">
        </link>
        <updated>2020-04-01T01:22:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第-1-题-react-vue-项目时为什么要在列表组件中写-key其作用是什么">第 1 题： React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h1>
<p>😅emm..对这个问题有过疑问，但是一直没有探寻原因，现在梳理一下</p>
<h2 id="答案"><strong>答案</strong></h2>
<p>首先在vue循环遍历生成节点中会使用到key，那么到底要不要使用key，参考官网上的描述：<br>
📃VUE文档:</p>
<ul>
<li>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</li>
</ul>
<p>得出结论，多数情况最好使用key!</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;i in dataList&quot; :key=&quot;i&quot;&gt;{{ i }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>key是用来<code>绑定</code>虚拟节点的，给每一个vnode<code>唯一</code>id。<br>
当不使用key的时候，也可以通过v-for实现以下的dom节点数组<br>
🌰 案例：</p>
<pre><code class="language-js">var vm = new Vue({
  el: '#app',
  data: {
    dataList: [1, 2, 3, 4, 5]
  }
})
</code></pre>
<p>为了方便，标记上id加以说明节点。当数组为[1, 2, 3, 4, 5]时，加key与不加key都如下：</p>
<pre><code class="language-html"> [
    '&lt;div&gt;1&lt;/div&gt;',     // id:  A
    '&lt;div&gt;2&lt;/div&gt;',     // id:  B
    '&lt;div&gt;3&lt;/div&gt;',     // id:  C
    '&lt;div&gt;4&lt;/div&gt;',     // id:  D
    '&lt;div&gt;5&lt;/div&gt;'      // id:  E
  ]
</code></pre>
<p>但是，当数组有变化时，两者就有区别了。<br>
改变dataList数据，进行数据位置替换，对比改变后的数据如下：</p>
<pre><code class="language-javascript"> vm.dataList = [4, 1, 3, 5, 2] // 数据位置替换
 // 没有key的情况， 节点位置不变，但是节点innerText内容更新了
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： A
    '&lt;div&gt;1&lt;/div&gt;', // id:  B
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  D
    '&lt;div&gt;2&lt;/div&gt;'  // id:  E
  ]

  // 有key的情况，dom节点位置进行了交换，但是内容没有更新
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： D
    '&lt;div&gt;1&lt;/div&gt;', // id:  A
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;2&lt;/div&gt;'  // id:  B
  ]
</code></pre>
<p>原因：<code>没有绑定key的情况下，节点会进行复用</code>，即呈现出id没变，内容变化了（<code>就地更新</code>），这样<code>有利于diff速度</code>，但是这种模式会带来一些隐藏的副作用。可能不会产生过渡的效果，某些节点绑定数据（表单）状态时，会出现状态错位。没办法追踪到每个节点。<br>
使用key可以：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<pre><code class="language-html">&lt;transition&gt;
  &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;
&lt;/transition&gt;
</code></pre>
<p>当 text 发生改变时，span总是会被替换而不是被修改，因此会触发过渡。</p>
<p>📃VUE文档也说明了</p>
<ul>
<li>不加key时，<a href="https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81">这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</a></li>
</ul>
<p>增删dataList列表项，对比改变后的数据如下：</p>
<pre><code class="language-html">vm.dataList = [3, 4, 5, 6, 7] // 数据进行增删
  // 1. 没有key的情况， 节点位置不变，内容也更新了
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： A
    '&lt;div&gt;4&lt;/div&gt;', // id:  B
    '&lt;div&gt;5&lt;/div&gt;', // id:  C
    '&lt;div&gt;6&lt;/div&gt;', // id:  D
    '&lt;div&gt;7&lt;/div&gt;'  // id:  E
  ]

  // 2. 有key的情况， 节点删除了 A, B 节点，新增了 F, G 节点
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： C
    '&lt;div&gt;4&lt;/div&gt;', // id:  D
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;6&lt;/div&gt;', // id:  F
    '&lt;div&gt;7&lt;/div&gt;'  // id:  G
  ]
</code></pre>
<p>key是给每一个vnode的唯一id,可以依靠key,<code>更准确</code>, <code>更快</code>的拿到oldVnode中对应的vnode节点。<br>
更快 体现在：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。</p>
<h2 id="扩展"><strong>扩展</strong>：</h2>
<h3 id="diff算法">diff算法</h3>
<h3 id="vue源码">vue源码</h3>
<h1 id="第-2-题1-2-3mapparseint-what-why">第 2 题：['1', '2', '3'].map(parseInt) what &amp; why ?</h1>
<p>emm..map是es6中涉及到的方法，是指不重复的Key-value形式的数据，parseInt是....返回整数的，然并卵...orz🤒</p>
<h2 id="答案-2"><strong>答案</strong></h2>
<p>真正的答案是[1, NaN, NaN]<br>
这题的主要考察，还是arr.map（）方法，和parseInt，对它们一定要深入理解。下面附上MDN官方解释：<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()</a></li>
</ul>
<pre><code class="language-javascript">    var new_array = arr.map(function callback(currentValue[, index[, array]]) {     }[, thisArg])
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585987454821.png" alt="" width="400" height="300" loading="lazy"></figure>
<h3 id="map方法定义">map方法定义</h3>
<p>将数组中的值按顺序调用callback函数，然后由callback返回的数按顺序组成新数组；没有赋值或删除掉的索引不会调用。</p>
<h3 id="map方法使用">map方法使用</h3>
<p>map方法针对<code>新数组</code>的，<code>不会修改原数组</code>，若是对原数组进行操作则使用for-of或forEach。<br>
callback 函数会被自动传入三个参数：<code>数组元素</code>，<code>元素索引</code>，<code>原数组本身</code>。</p>
<p>🙄其实这里主要难度是parseInt，下面一起来研究下叭~<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a></li>
</ul>
<pre><code class="language-javascript">parseInt(string, radix);
</code></pre>
<p>将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。</p>
<h1 id="3原生js使用vuejs时的闪现问题">[3.]原生js使用vue.js时的闪现问题</h1>
<p>原生js中在使用到vue.js时，如使用<code>{{}}</code>会出现闪现问题，会先变成<code>{{message}}</code>显示在页面上，然后再变成需要显示的值。<br>
闪现问题是如何产生的？<br>
因为代码的执行顺序，先编译（编译template代码），再进行数据绑定。<br>
解决办法（2种）避免FOUC (Flash of Uncompiled Content)</p>
<h2 id="v-cloak">v-cloak</h2>
<p><code>v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。</code></p>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
    [v-cloak] {
      display: none;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;方法一: v-cloak&lt;/p&gt;
  &lt;!-- 页面加载数据时，原始代码会闪现一下
  加入一段css代码，在view上引用css模块 --&gt;
  &lt;!-- v-cloak 这个指令保持在元素上直到关联实例结束编译。 v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。--&gt;
  &lt;div id=&quot;app&quot; v-cloak&gt;    &lt;!-- &lt;div&gt; 不会显示，直到编译结束。--&gt;
    &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
    &lt;!-- 双括号会被编译成textNode的一个v-text指令 --&gt;
  &lt;/div&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
</code></pre>
<h2 id="v-text-取代">v-text 取代 {{}}</h2>
<pre><code class="language-html">&lt;body&gt;
    &lt;p&gt;方法二: v-text&lt;/p&gt;
    &lt;h1 v-text=&quot;message&quot;&gt;&lt;/h1&gt;
    &lt;h1 v-text=&quot;name&quot;&gt;&lt;/h1&gt;
  &lt;/div&gt;
    &lt;!-- vue中我们会将数据包在两个大括号中，然后放到HTML里，但是在vue内部，所有的双括号会被编译成textNode的一个v-text指令。
  而使用v-text的好处就是永远更好的性能，更重要的是可以避免FOUC (Flash of Uncompiled Content) ，也就是上面与遇到的问题。 --&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h1 id="4v-if-与-v-show">[4.]v-if 与 v-show</h1>
<p>区别：v-if 的那段代码为false就不编译了，为true才编译；而 v-show 的代码是一定会编译的<br>
使用场景：v-show用于标签切换更频繁的地方，v-if用于初始进行判断是否编译</p>
<h1 id="5computed-和-watch-的区别和运用的场景">[5.]computed 和 watch 的区别和运用的场景？</h1>
<p><strong>computed</strong> ：主要进行<strong>计算</strong>，依赖于其他属性，并且有缓存。只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。computed中的函数必须要用return返回；</p>
<ul>
<li>使用场景：当一个值受多个属性影响的时候————购物车商品结算<br>
<strong>watch</strong>：更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作，<strong>监听一个值的变化，然后执行对应的回调</strong>；<br>
<strong>运用场景：</strong></li>
<li>使用场景：当一条数据的更改影响到多条数据的时候————搜索框。需要监听属性时<br>
总结：</li>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h1 id="6直接给一个数组项赋值vue-能检测到变化吗">[6.]直接给一个数组项赋值，Vue 能检测到变化吗？</h1>
<p>由于 JavaScript 的限制，Vue <strong>不能</strong>检测到以下数组的变动：</p>
<p>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code><br>
当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></p>
<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<pre><code class="language-js">// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
 this.$set(this.tableData, this.idx, this.form);    //修改数组的值
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
this.item.splice(1,1,'xx')  //给数组中下标是1的位置添加一个新值‘xx’
</code></pre>
<p>为了解决第二个问题（修改数组长度——添加数据、删除数据），Vue 提供了以下操作方法：</p>
<pre><code class="language-js">// Array.prototype.splice
vm.items.splice(newLength)

var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2);         //从第 2 位开始删除所有元素
// 运算后的 myFish: [&quot;angel&quot;, &quot;clown&quot;]
// 被删除的元素: [&quot;mandarin&quot;, &quot;sturgeon&quot;]
</code></pre>
<h1 id="7vue-的父组件和子组件生命周期钩子函数执行顺序">[7.]Vue 的父组件和子组件生命周期钩子函数执行顺序？</h1>
<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><code>加载渲染过程</code>
<ul>
<li>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
</ul>
</li>
<li><code>子组件更新过程</code>
<ul>
<li>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
</ul>
</li>
<li><code>父组件更新过程</code>
<ul>
<li>父 beforeUpdate -&gt; 父 updated</li>
</ul>
</li>
<li><code>销毁过程</code>
<ul>
<li>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
</li>
</ul>
<h1 id="8在哪个生命周期内调用异步请求">[8.]在哪个生命周期内调用异步请求？</h1>
<p>分析：ajax就是异步请求，即相当于在问：在那个生命周期中调用ajax请求？<br>
可以在钩子函数<code>created、beforeMount、mounted</code>中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端返回的数据进行赋值。但是<code>推荐</code>在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h1 id="9在什么阶段才能访问操作dom">[9.]在什么阶段才能访问操作DOM？</h1>
<p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p>
<h1 id="10父组件可以监听到子组件的生命周期吗">[10.]父组件可以监听到子组件的生命周期吗？</h1>
<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<pre><code class="language-js">// Parent.vue
&lt;Child @mounted=&quot;doSomething&quot;/&gt;
    
// Child.vue
mounted() {
  this.$emit(&quot;mounted&quot;);
}
</code></pre>
<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 <code>@hook</code> 来监听即可，如下所示：</p>
<pre><code class="language-js">//  Parent.vue
&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     
</code></pre>
<p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h1 id="11谈谈你对-keep-alive-的了解">[11.]谈谈你对 keep-alive 的了解？</h1>
<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供<code>include</code> 和<code>exclude</code> 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
<ul>
<li><code>&lt;keep-alive :exclude=&quot;&quot;&gt;</code></li>
</ul>
</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h1 id="12组件中-data-为什么是一个函数">[12.]组件中 data 为什么是一个函数？</h1>
<blockquote>
<p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>
<pre><code class="language-js">// data
data() {
  return {
	message: &quot;子组件&quot;,
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '&lt;App/&gt;',
  components: {App}
})
</code></pre>
<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，<br>
如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；<br>
而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h1 id="13v-model-的原理">[13.]v-model 的原理</h1>
<p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input  表单元素为例：</p>
<pre><code class="language-html">&lt;input v-model='something'&gt;
</code></pre>
<p>相当于</p>
<pre><code class="language-html">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;
</code></pre>
<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：<br>
父组件：</p>
<pre><code class="language-html">&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-js">&lt;div&gt;{{value}}&lt;/div&gt;

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
},
</code></pre>
<h1 id="14q标准盒子模型与ie怪异盒子模型">[14.]Q：标准盒子模型与IE怪异盒子模型</h1>
<p>这个问题主要会出现在笔试题上面，比如：</p>
<pre><code class="language-javascript">&lt;div style=&quot;width:100px;height=&quot;100px;border:10px;padding:10px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这个盒子在w3c标准盒子模型和IE的怪异盒子模型下面它的宽度分别是多少？</p>
<pre><code class="language-javascript">标准盒子模型：总宽度=content100px+border 10px*2+padding 10px*2 //140px
怪异盒子模型: 总宽度=content60px+ border 10px*2+padding 10px*2 //100px
</code></pre>
<p>怪异盒子：box-sizing：border-box将div的width就是width赋值的宽<br>
标准盒子：宽度为width的宽加上border和padding</p>
<h1 id="15闭包">[15.]闭包</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596370324100.png" alt="" loading="lazy"><br>
注：关键看有没有产生新的闭包<br>
结果：<br>
<img src="https://cutezhangq.github.io/post-images/1596370348698.png" alt="" loading="lazy"><br>
补充：<br>
通过闭包---立即执行函数，生成块级作用域</p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;测试1&lt;/button&gt;
    &lt;br&gt;
    &lt;button&gt;测试2&lt;/button&gt;
    &lt;br&gt;
    &lt;button&gt;测试3&lt;/button&gt;
    &lt;br&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
//使用var:
    let bottons = document.getElementsByTagName('button');
    //1.
    for(var j = 0;j&lt;  bottons.length;j++){
      var botton = bottons[j];
      botton.onclick = function(){
        alert(j)    //输出都是3
        //点击事件对应回调函数，回调函数会被放入事件队列中，等主线程代码执行完了，才将回调函数&quot;钩&quot;出来去执行
        //回调函数（钩子函数）
      }
    }
    //2.使用闭包解决问题：
        //----闭包产生条件：1.函数嵌套  2调用外部函数
    for(var k= 0;k&lt; bottons.length;k++){
      var botton = bottons[k];
      (function(k){     //()()立即执行函数
        botton.onclick = function(){
        alert(k)         //点击每个按钮一次输出0,1,2   
        }
      })(k) //立即执行函数有其自己的作用于（私有作用域），每执行一次有一个自己的函数作用域
    }
&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>使用闭包的注意点1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退     出函数之前，将不使用的局部变量全部删除.<br>
2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当     作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git使用]]></title>
        <id>https://cutezhangq.github.io/post/git/</id>
        <link href="https://cutezhangq.github.io/post/git/">
        </link>
        <updated>2020-03-22T06:51:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="定义">定义</h1>
<p>是一个分布式版本控制工具（系统）。</p>
<h1 id="git特点">Git特点</h1>
<p>1.尽可能添加数据而不是删除或修改数据，存储能力强，容易备份</p>
<p>2.完整性保证（对于每次提交做Hash的操作）</p>
<p>3.与linux命令全面兼容</p>
<p>4.良好性能，支持离线（在本地完成）</p>
<p>5.制定工作流</p>
<p>6.分布式仓库</p>
<h1 id="git官网">Git官网</h1>
<p><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<h1 id="git三种状态三个逻辑区域">Git三种状态,三个逻辑区域</h1>
<h2 id="三种状态">三种状态</h2>
<ul>
<li>
<p>modified(已修改)</p>
</li>
<li>
<p>staged(已暂存)</p>
</li>
<li>
<p>committed(已提交)</p>
</li>
</ul>
<h2 id="三种分区">三种分区</h2>
<p>git分为：<code>工作区</code>，<code>暂存区</code>，<code>本地库</code>，<code>远程区</code>  四块大区域</p>
<h2 id="对应关系">对应关系</h2>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585704345724.jpg" alt="" loading="lazy"></figure>
<h1 id="git文件内容结构">.Git文件内容结构</h1>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1585704336057.png" alt="" loading="lazy"></figure>
<h1 id="git命令">Git命令</h1>
<h2 id="搭建git仓库">搭建Git仓库</h2>
<h3 id="两种场景">两种场景：</h3>
<p>使用<code>init</code>初始化，将本地的目录变成git<code>本地仓库</code></p>
<ul>
<li>1.已有项目，将项目纳入Git管理</li>
</ul>
<pre><code class="language-cmd">cd 项目所在文件夹
git init
</code></pre>
<ul>
<li>2.没有项目，新建用Git管理的项目</li>
</ul>
<pre><code class="language-cmd">cd 项目所在文件夹
git init your_project   #会在当前路径下创建和项目名称同名的文件夹
</code></pre>
<h3 id="查看本地目录的状态">查看本地目录的状态</h3>
<pre><code class="language-cmd">git status
</code></pre>
<h3 id="本地仓库与远程仓库关联">本地仓库与远程仓库关联</h3>
<p>与<code>远程仓库</code>关联，（此前已在码云等上注册远程仓库）</p>
<pre><code class="language-cmd">git add origin 远程仓库地址
</code></pre>
<hr>
<h2 id="更新项目">更新项目</h2>
<p>准备上传你的项目之前，最好更新一下项目，确保没有和远程仓库的代码有<code>冲突</code></p>
<pre><code class="language-cmd">git pull --rebase origin master
</code></pre>
<hr>
<h2 id="提交项目">提交项目</h2>
<pre><code class="language-cmd">git add .           #添加目录下所有发生改变的文件
git commit -m           #'注释信息'
git push -u origin master       #本地仓库代码提交至远程仓库(有时候会提交失败，可以尝试git push -u origin master -f 强制提交,只建议在第一次提交中使用)
</code></pre>
<hr>
<h2 id="克隆项目">克隆项目</h2>
<pre><code class="language-cmd">git clone 远程仓库地址
</code></pre>
<hr>
<h2 id="分支相关命令">分支相关命令</h2>
<ul>
<li>查看所有分支</li>
</ul>
<pre><code class="language-cmd">git branch  -a
</code></pre>
<ul>
<li>创建分支</li>
</ul>
<pre><code class="language-cmd">git branch 分支名
</code></pre>
<ul>
<li>切换到某一分支</li>
</ul>
<pre><code class="language-cmd">git checkout  分支名
</code></pre>
<ul>
<li><code>合并分支</code></li>
</ul>
<pre><code class="language-cmd">git merge 分支名
</code></pre>
<ul>
<li><code>创建远程的分支,并且把本地分支推送到远程分支上</code></li>
</ul>
<pre><code class="language-cmd">git push origin 分支名
</code></pre>
<ul>
<li>删除本地分支</li>
</ul>
<pre><code class="language-cmd">git branch -d 分支名
</code></pre>
<ul>
<li>查看本地分支状态</li>
</ul>
<pre><code class="language-cmd">git branch
</code></pre>
<ul>
<li>删除远程分支</li>
</ul>
<pre><code class="language-cmd">git push origin --delete [branch_name]
</code></pre>
<h1 id="git本地项目代码上传至远程仓库">git本地项目代码上传至远程仓库</h1>
<h2 id="一-在码云github上创建项目名称为xx的项目">一、在码云/gitHub上创建项目名称为xx的项目</h2>
<h2 id="二-打开gitbash-用cd命令进入本地项目然后把初始化一下把本地的目录变成git本地仓库-git-status-可以查看本地目录的状态信息">二、打开GitBash ，用cd命令进入本地项目,然后把初始化一下，把本地的目录变成git本地仓库, git status 可以查看本地目录的状态信息</h2>
<p>git init<br>
git status<br>
注意：当git status报红时，是本地的文件没有暂存，选择：暂存本地文件<br>
<img src="https://cutezhangq.github.io/post-images/1596367654143.png" alt="" loading="lazy"><br>
(可以使用git add . 进行暂存)暂存完了之后：再次查看git status发现变绿了<br>
<img src="https://cutezhangq.github.io/post-images/1596367683394.png" alt="" loading="lazy"></p>
<h2 id="三-将你本地仓库与码云上的远程仓库关联起来">三、将你本地仓库与码云上的远程仓库关联起来</h2>
<p>git remote add origin https://gitee.com/xxx/xxx.git</p>
<h2 id="四-在你准备上传你的项目之前最好更新一下项目确保没有和远程仓库的代码有冲突">四、在你准备上传你的项目之前，最好更新一下项目，确保没有和远程仓库的代码有冲突</h2>
<p>git pull --rebase origin master</p>
<h2 id="五-把你的项目复制到这个目录下用命令添加你要上传的项目再提交到本地暂存区最后把本地仓库项目提交到远程仓库-git-是强烈建议你在提交代码的时候要写备注注释的所以既然人家是强烈建议你就别懒了">五、把你的项目复制到这个目录下，用命令添加你要上传的项目，再提交到本地暂存区，最后把本地仓库项目提交到远程仓库。git 是强烈建议你在提交代码的时候，要写备注注释的，所以既然人家是强烈建议，你就别懒了。</h2>
<p>git add . 添加目录下所有发生改变的文件<br>
git commit -m '注释信息'<br>
git push -u origin master 本地仓库代码提交至远程仓库(有时候会提交失败，可以尝试$ git push -u origin master -f 强制提交,只建议在第一次提交中使用)</p>
]]></content>
    </entry>
</feed>