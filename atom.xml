<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-08-10T13:37:48.014Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[this、apply、call、bind]]></title>
        <id>https://cutezhangq.github.io/post/thisapplycallbind/</id>
        <link href="https://cutezhangq.github.io/post/thisapplycallbind/">
        </link>
        <updated>2020-08-09T07:12:03.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="面试题-区别bind与call和apply">面试题: 区别bind()与call()和apply()?</h1>
<ul>
<li>都能指定函数中的this</li>
<li>call()/apply()是 立即调用函数</li>
<li>bind()是 将函数返回</li>
</ul>
<pre><code class="language-js">//在不传参的形式下： .call同.apply  可以强制this的指向
  var obj0 = {username:'gaga'};
  function foo(){
    console.log(this);
  }
  foo.call(obj0)        //{username:'gaga'}
  foo.apply(obj0)       //{username:'gaga'}

//传参时： call直接传   apply放到数组中传
  function foo1(data){
      console.log(this,data);
  }
  foo1.call(obj0,33)      //{username:'gaga'} 33    直接从第二个参数开始，依次传入
  foo1.apply(obj0,[33])   //{username:'gaga'} 33  第二个参数必须是数组，传入的数据放在数组里
  foo.bind(obj0)   //没有输出
</code></pre>
<p><strong>bind的特点：</strong><br>
绑定完this不会立即调用当前的函数，而是将函数返回</p>
<pre><code class="language-js">//bind的特点：
    //绑定完this不会立即调用当前的函数，而是将函数返回
      //写法1.
    var bar = foo.bind(obj0)
    console.log('bar',bar)      //foo(){  console.log(this);  }
    bar();                     //{username:'gaga'}
      //写法2.
    foo.bind(obj0)();         //{username:'gaga'}

//bind的用法：用来指定回调函数的this      vue中常用
    setTimeout(function(){
      console.log('---',this)   //不绑定bind,this是window；bind后this指向为obj0     --- {username: &quot;gaga&quot;}
    }.bind(obj0),1000)

//bind传参的方式：
    function fun(age) {
        this.name = 'kobe';
        this.age = age;
        console.log('dd');
    }
    var obj = {};
    fun.bind(obj, 12)();
    console.log(obj.name, obj.age);      //kobe 12
</code></pre>
<h1 id="this">this</h1>
<ul>
<li>this可以用在构造函数之中，表示实例对象。<br>
除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。<br>
简单说，<code>this就是属性或方法“当前”所在的 对象。</code><br>
下面是一个实际的例子。</li>
</ul>
<pre><code class="language-js">var person = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

person.describe()       // &quot;姓名：张三&quot;
</code></pre>
<p>上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。<br>
由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，<br>
<strong>即this的指向是可变的。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var B = {
    name: '李四'
};

B.describe = A.describe;
B.describe()    // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。<br>
稍稍重构这个例子，this的动态指向就能看得更清楚。</p>
<pre><code class="language-js">function f() {
    return '姓名：'+ this.name;
}

var A = {
    name: '张三',
    describe: f
};

var B = {
    name: '李四',
    describe: f
};

A.describe() // &quot;姓名：张三&quot;
B.describe() // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。<br>
<strong>只要函数被赋给另一个变量，this的指向就会变。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var name = '李四';
var f = A.describe;
f()     // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。</p>
<h1 id="2-this-的使用场景">2. this 的使用场景</h1>
<h2 id="1全局环境">（1）全局环境</h2>
<pre><code class="language-js">this === window // true

function f() {
    console.log(this === window);
}
f() // true
</code></pre>
<h2 id="2构造函数">（2）构造函数</h2>
<p>构造函数中的this，指的是实例对象。</p>
<pre><code class="language-js">var Obj = function (p) {
    this.p = p;
};
</code></pre>
<h2 id="3对象的方法">（3）对象的方法</h2>
<p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。<br>
但是，这条规则很不容易把握。请看下面的代码。</p>
<pre><code class="language-js">var obj ={
    foo: function () {
        console.log(this);
    }
};

obj.foo() // obj
</code></pre>
<p>上面代码中，obj.foo方法执行时，它内部的this指向obj。<br>
但是，下面这几种用法，都会改变this的指向。</p>
<pre><code class="language-js">// 情况一
(obj.foo = obj.foo)() // window
// 情况二
(false || obj.foo)() // window
// 情况三
(1, obj.foo)() // window

</code></pre>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。</p>
<pre><code class="language-js">var a = {
    b: {
        m: function() {
            console.log(this.p);
        },
        p: 'Hello'
    }
};

var hello = a.b.m;
hello() // undefined
</code></pre>
<p><strong>即：当有赋值情况时，先将值替换，然后再看this的指向</strong></p>
<h1 id="使用注意点">使用注意点</h1>
<h2 id="countersection-避免多层-this">counter(section) &quot;　&quot;避免多层 this</h2>
<p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。</p>
<pre><code class="language-js">var o = {
    f1: function () {
        console.log(this);
        var f2 = function () {
            console.log(this);
        }();
    }
}

o.f1()
// Object
</code></pre>
<p>上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<pre><code class="language-js">var temp = function () {
    console.log(this);
};

var o = {
    f1: function () {
        console.log(this);
        var f2 = temp();
    }
}
</code></pre>
<p>一个解决方法是在第二层改用一个指向外层this的变量。</p>
<pre><code class="language-js">var o = {
    f1: function() {
        console.log(this);
        var that = this;
        var f2 = function() {
            console.log(that);    //然后在内层使用that，就不会发生this指向的改变
        }();
    }
}

o.f1()
// Object
// Object
</code></pre>
<p><strong>上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</strong><br>
事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。<br>
JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。</p>
<h2 id="2-countersection-避免数组处理方法中的-this">2 &quot;.&quot; counter(section) &quot;　&quot;避免数组处理方法中的 this</h2>
<p>数组的<code>map</code>和<code>forEach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用this。<br>
——<strong>使用中间变量固定this。</strong><br>
或者<strong>是将this当作forEach方法的第二个参数，固定它的运行环境。</strong></p>
<h3 id="一种方法就是前面提到的使用中间变量固定this">一种方法，就是前面提到的，使用中间变量固定this。</h3>
<p>应用：</p>
<pre><code class="language-js"> //下单
      async orderDown() {
        var _this = this;
        //获取选择的商品数组信息
        this.listData.forEach(function(item,index){
          goodsIdArr.forEach(function(item2,index2){
            if(item.productId == item2){
              _this.chooseProductList.push(_this.listData[index]);
            }
          })
        });
      },
</code></pre>
<h3 id="另一种方法是将this当作foreach方法的第二个参数固定它的运行环境">另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</h3>
<pre><code class="language-js">var o = {
    v: 'hello',
    p: [ 'a1', 'a2' ],
    f: function f() {
        this.p.forEach(function (item) {
            console.log(this.v + ' ' + item);
        }, this);
    }
}

o.f()
// hello a1
// hello a2
</code></pre>
<h2 id="3-countersection-避免回调函数中的-this">3 &quot;.&quot; counter(section) &quot;　&quot;避免回调函数中的 this</h2>
<p><strong>回调函数中的this往往会改变指向，最好避免使用。</strong></p>
<h2 id="4-绑定-this-的方法">4 &quot;. &quot;绑定 this 的方法</h2>
<p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call、apply、bind</code>这三个方法，来切换/固定this的指向。</p>
<h1 id="call">.call()</h1>
<p>函数实例的call方法，<strong>可以指定函数内部this的指向（即函数执行时所在的作用域）</strong>，然后在所指定的作用域中，调用该函数。</p>
<pre><code class="language-js">var obj = {};

var f = function () {
    return  this;
};

f() === window // true
f.call(obj) === obj // true
</code></pre>
<p>上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；<br>
call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。<br>
call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p>
<pre><code class="language-js">var n = 123;
var obj = { n: 456 };

function a() {
    console.log(this.n);
}

a.call() // 123
a.call(null) // 123
a.call(undefined) // 123
a.call(window) // 123
a.call(obj) // 456
</code></pre>
<p>如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。</p>
<pre><code class="language-js">var f = function () {
    return  this;
};

f.call(5)    // Number {[[PrimitiveValue]]: 5}
</code></pre>
<p>上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。<br>
call方法还可以接受多个参数。</p>
<p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<pre><code class="language-js">function add(a, b) {
    return a + b;
}

add.call(this, 1, 2) // 3
</code></pre>
<p>上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。<br>
call方法的一个应用是调用对象的原生方法。</p>
<pre><code class="language-js">var obj = {};
obj.hasOwnProperty('toString') // false

// 覆盖掉继承的 hasOwnProperty 方法
obj.hasOwnProperty = function () {
    return true;
};
obj.hasOwnProperty('toString') // true

Object.prototype.hasOwnProperty.call(obj, 'toString') // false
</code></pre>
<p>上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="面试题-区别bind与call和apply">面试题: 区别bind()与call()和apply()?</h1>
<ul>
<li>都能指定函数中的this</li>
<li>call()/apply()是 立即调用函数</li>
<li>bind()是 将函数返回</li>
</ul>
<pre><code class="language-js">//在不传参的形式下： .call同.apply  可以强制this的指向
  var obj0 = {username:'gaga'};
  function foo(){
    console.log(this);
  }
  foo.call(obj0)        //{username:'gaga'}
  foo.apply(obj0)       //{username:'gaga'}

//传参时： call直接传   apply放到数组中传
  function foo1(data){
      console.log(this,data);
  }
  foo1.call(obj0,33)      //{username:'gaga'} 33    直接从第二个参数开始，依次传入
  foo1.apply(obj0,[33])   //{username:'gaga'} 33  第二个参数必须是数组，传入的数据放在数组里
  foo.bind(obj0)   //没有输出
</code></pre>
<p><strong>bind的特点：</strong><br>
绑定完this不会立即调用当前的函数，而是将函数返回</p>
<pre><code class="language-js">//bind的特点：
    //绑定完this不会立即调用当前的函数，而是将函数返回
      //写法1.
    var bar = foo.bind(obj0)
    console.log('bar',bar)      //foo(){  console.log(this);  }
    bar();                     //{username:'gaga'}
      //写法2.
    foo.bind(obj0)();         //{username:'gaga'}

//bind的用法：用来指定回调函数的this      vue中常用
    setTimeout(function(){
      console.log('---',this)   //不绑定bind,this是window；bind后this指向为obj0     --- {username: &quot;gaga&quot;}
    }.bind(obj0),1000)

//bind传参的方式：
    function fun(age) {
        this.name = 'kobe';
        this.age = age;
        console.log('dd');
    }
    var obj = {};
    fun.bind(obj, 12)();
    console.log(obj.name, obj.age);      //kobe 12
</code></pre>
<h1 id="this">this</h1>
<ul>
<li>this可以用在构造函数之中，表示实例对象。<br>
除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。<br>
简单说，<code>this就是属性或方法“当前”所在的 对象。</code><br>
下面是一个实际的例子。</li>
</ul>
<pre><code class="language-js">var person = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

person.describe()       // &quot;姓名：张三&quot;
</code></pre>
<p>上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。<br>
由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，<br>
<strong>即this的指向是可变的。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var B = {
    name: '李四'
};

B.describe = A.describe;
B.describe()    // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。<br>
稍稍重构这个例子，this的动态指向就能看得更清楚。</p>
<pre><code class="language-js">function f() {
    return '姓名：'+ this.name;
}

var A = {
    name: '张三',
    describe: f
};

var B = {
    name: '李四',
    describe: f
};

A.describe() // &quot;姓名：张三&quot;
B.describe() // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。<br>
<strong>只要函数被赋给另一个变量，this的指向就会变。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var name = '李四';
var f = A.describe;
f()     // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。</p>
<h1 id="2-this-的使用场景">2. this 的使用场景</h1>
<h2 id="1全局环境">（1）全局环境</h2>
<pre><code class="language-js">this === window // true

function f() {
    console.log(this === window);
}
f() // true
</code></pre>
<h2 id="2构造函数">（2）构造函数</h2>
<p>构造函数中的this，指的是实例对象。</p>
<pre><code class="language-js">var Obj = function (p) {
    this.p = p;
};
</code></pre>
<h2 id="3对象的方法">（3）对象的方法</h2>
<p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。<br>
但是，这条规则很不容易把握。请看下面的代码。</p>
<pre><code class="language-js">var obj ={
    foo: function () {
        console.log(this);
    }
};

obj.foo() // obj
</code></pre>
<p>上面代码中，obj.foo方法执行时，它内部的this指向obj。<br>
但是，下面这几种用法，都会改变this的指向。</p>
<pre><code class="language-js">// 情况一
(obj.foo = obj.foo)() // window
// 情况二
(false || obj.foo)() // window
// 情况三
(1, obj.foo)() // window

</code></pre>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。</p>
<pre><code class="language-js">var a = {
    b: {
        m: function() {
            console.log(this.p);
        },
        p: 'Hello'
    }
};

var hello = a.b.m;
hello() // undefined
</code></pre>
<p><strong>即：当有赋值情况时，先将值替换，然后再看this的指向</strong></p>
<h1 id="使用注意点">使用注意点</h1>
<h2 id="countersection-避免多层-this">counter(section) &quot;　&quot;避免多层 this</h2>
<p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。</p>
<pre><code class="language-js">var o = {
    f1: function () {
        console.log(this);
        var f2 = function () {
            console.log(this);
        }();
    }
}

o.f1()
// Object
</code></pre>
<p>上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<pre><code class="language-js">var temp = function () {
    console.log(this);
};

var o = {
    f1: function () {
        console.log(this);
        var f2 = temp();
    }
}
</code></pre>
<p>一个解决方法是在第二层改用一个指向外层this的变量。</p>
<pre><code class="language-js">var o = {
    f1: function() {
        console.log(this);
        var that = this;
        var f2 = function() {
            console.log(that);    //然后在内层使用that，就不会发生this指向的改变
        }();
    }
}

o.f1()
// Object
// Object
</code></pre>
<p><strong>上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</strong><br>
事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。<br>
JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。</p>
<h2 id="2-countersection-避免数组处理方法中的-this">2 &quot;.&quot; counter(section) &quot;　&quot;避免数组处理方法中的 this</h2>
<p>数组的<code>map</code>和<code>forEach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用this。<br>
——<strong>使用中间变量固定this。</strong><br>
或者<strong>是将this当作forEach方法的第二个参数，固定它的运行环境。</strong></p>
<h3 id="一种方法就是前面提到的使用中间变量固定this">一种方法，就是前面提到的，使用中间变量固定this。</h3>
<p>应用：</p>
<pre><code class="language-js"> //下单
      async orderDown() {
        var _this = this;
        //获取选择的商品数组信息
        this.listData.forEach(function(item,index){
          goodsIdArr.forEach(function(item2,index2){
            if(item.productId == item2){
              _this.chooseProductList.push(_this.listData[index]);
            }
          })
        });
      },
</code></pre>
<h3 id="另一种方法是将this当作foreach方法的第二个参数固定它的运行环境">另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</h3>
<pre><code class="language-js">var o = {
    v: 'hello',
    p: [ 'a1', 'a2' ],
    f: function f() {
        this.p.forEach(function (item) {
            console.log(this.v + ' ' + item);
        }, this);
    }
}

o.f()
// hello a1
// hello a2
</code></pre>
<h2 id="3-countersection-避免回调函数中的-this">3 &quot;.&quot; counter(section) &quot;　&quot;避免回调函数中的 this</h2>
<p><strong>回调函数中的this往往会改变指向，最好避免使用。</strong></p>
<h2 id="4-绑定-this-的方法">4 &quot;. &quot;绑定 this 的方法</h2>
<p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call、apply、bind</code>这三个方法，来切换/固定this的指向。</p>
<h1 id="call">.call()</h1>
<p>函数实例的call方法，<strong>可以指定函数内部this的指向（即函数执行时所在的作用域）</strong>，然后在所指定的作用域中，调用该函数。</p>
<pre><code class="language-js">var obj = {};

var f = function () {
    return  this;
};

f() === window // true
f.call(obj) === obj // true
</code></pre>
<p>上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；<br>
call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。<br>
call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p>
<pre><code class="language-js">var n = 123;
var obj = { n: 456 };

function a() {
    console.log(this.n);
}

a.call() // 123
a.call(null) // 123
a.call(undefined) // 123
a.call(window) // 123
a.call(obj) // 456
</code></pre>
<p>如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。</p>
<pre><code class="language-js">var f = function () {
    return  this;
};

f.call(5)    // Number {[[PrimitiveValue]]: 5}
</code></pre>
<p>上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。<br>
call方法还可以接受多个参数。</p>
<p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<pre><code class="language-js">function add(a, b) {
    return a + b;
}

add.call(this, 1, 2) // 3
</code></pre>
<p>上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。<br>
call方法的一个应用是调用对象的原生方法。</p>
<pre><code class="language-js">var obj = {};
obj.hasOwnProperty('toString') // false

// 覆盖掉继承的 hasOwnProperty 方法
obj.hasOwnProperty = function () {
    return true;
};
obj.hasOwnProperty('toString') // true

Object.prototype.hasOwnProperty.call(obj, 'toString') // false
</code></pre>
<p>上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。</p>
<!-- more -->
<h1 id="2-apply">2 .apply()</h1>
<p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。<br>
apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。<br>
第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，<strong>必须以数组形式添加</strong>。</p>
<pre><code class="language-js">function f(x, y){
    console.log(x + y);
}

f.call(null, 1, 1) // 2
f.apply(null, [1, 1]) // 2
</code></pre>
<p>上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。<br>
利用这一点，可以做一些有趣的应用。</p>
<h2 id="1找出数组最大元素">（1）找出数组最大元素</h2>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>
<pre><code class="language-js">var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
</code></pre>
<h2 id="2将数组的空元素变为undefined">（2）将数组的空元素变为undefined</h2>
<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>
<pre><code class="language-js">Array.apply(null, ['a', ,'b'])
// [ 'a', undefined, 'b' ]
</code></pre>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。<br>
因此，遍历内部元素的时候，会得到不同的结果。</p>
<pre><code class="language-js">var a = ['a', , 'b'];

function print(i) {
console.log(i);
}

a.forEach(print)
// a
// b

Array.apply(null, a).forEach(print)
// a
// undefined
// b
</code></pre>
<h2 id="3转换类似数组的对象">（3）转换类似数组的对象</h2>
<p>另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p>
<pre><code class="language-js">Array.prototype.slice.apply({0: 1, length: 1}) // [1]
Array.prototype.slice.apply({0: 1}) // []
Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]
Array.prototype.slice.apply({length: 1}) // [undefined]
</code></pre>
<p>上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。</p>
<h2 id="4绑定回调函数的对象">（4）绑定回调函数的对象</h2>
<pre><code class="language-js">var o = new  Object();

o.f = function () {
    console.log(this === o);
}

var f = function (){
    o.f.apply(o);
    // 或者 o.f.call(o);
};

// jQuery 的写法
$('#button').on('click', f);
</code></pre>
<p>上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法。</p>
<h1 id="3-bind">3 .bind()</h1>
<p>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</p>
<pre><code class="language-js">var d = new Date();
d.getTime() // 1481869925657

var print = d.getTime;
print() // Uncaught TypeError: this is not a Date object.
</code></pre>
<p>上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。<br>
bind方法可以解决这个问题。</p>
<pre><code class="language-js">var print = d.getTime.bind(d);
print() // 1481869925657
</code></pre>
<p>上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。<br>
bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。</p>
<pre><code class="language-js">var counter = {
    count: 0,
    inc: function () {
        this.count++;
    }
};

var func = counter.inc.bind(counter);
func();
counter.count // 1
</code></pre>
<p>上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。<br>
this绑定到其他对象也是可以的。</p>
<pre><code class="language-js">var counter = {
    count: 0,
    inc: function () {
        this.count++;
    }
};

var obj = {
    count: 100
};
var func = counter.inc.bind(obj);
func();
obj.count // 101
</code></pre>
<p>上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。<br>
bind还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<pre><code class="language-js">var add = function (x, y) {
    return  x * this.m + y * this.n;
}

var obj = {
    m: 2,
    n: 2
};

var newAdd = add.bind(obj, 5);
newAdd(5) // 20
</code></pre>
<h2 id="1每一次返回一个新函数">（1）每一次返回一个新函数</h2>
<p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<pre><code class="language-js">element.addEventListener('click', o.m.bind(o));
</code></pre>
<p>上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<pre><code class="language-js">element.removeEventListener('click', o.m.bind(o));
</code></pre>
<p>正确的方法是写成下面这样：</p>
<pre><code class="language-js">var listener = o.m.bind(o);
element.addEventListener('click', listener);
// ...
element.removeEventListener('click', listener);
</code></pre>
<h2 id="回调函数是-javascript-最常用的模式之一但是一个常见的错误是将包含this的方法直接当作回调函数">回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。</h2>
<p>解决方法就是使用bind方法，将counter.inc绑定counter。</p>
<pre><code class="language-js">var counter = {
    count: 0,
    inc: function () {
        'use strict';
        this.count++;
    }
};

function callIt(callback) {
    callback();
}

callIt(counter.inc.bind(counter));
counter.count // 1
</code></pre>
<p>上面代码中，callIt方法会调用回调函数。<br>
这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。<br>
使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。<br>
还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。</p>
<pre><code class="language-js">var obj = {
    name: '张三',
    times: [1, 2, 3],
    print: function () {
        this.times.forEach(function (n) {
            console.log(this.name);
        });
    }
};

obj.print()    // 没有任何输出
</code></pre>
<p>上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<pre><code class="language-js">obj.print = function () {
    this.times.forEach(function (n) {
        console.log(this === window);
    });
};

obj.print()
// true
// true
// true
</code></pre>
<p>解决这个问题，也是通过bind方法绑定this。</p>
<pre><code class="language-js">obj.print = function () {
    this.times.forEach(function (n) {
        console.log(this.name);
    }.bind(this));
};

obj.print()
// 张三
// 张三
// 张三
</code></pre>
<h2 id="3结合call方法使用">（3）结合call方法使用</h2>
<p>利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[slot插槽]]></title>
        <id>https://cutezhangq.github.io/post/slot-cha-cao/</id>
        <link href="https://cutezhangq.github.io/post/slot-cha-cao/">
        </link>
        <updated>2020-08-07T03:04:18.000Z</updated>
        <content type="html"><![CDATA[<p>插槽，也就是slot，<strong>是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。 <strong>实际上，一个slot最核心的两个问题在这里就点出来了，是</strong>显示不显示</strong>和<strong>怎样显示</strong>。<br>
由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>两大类。<br>
非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；<br>
插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p>
<h1 id="单个插槽-默认插槽-匿名插槽">单个插槽 | 默认插槽 | 匿名插槽</h1>
<p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。<br>
单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。<br>
下面通过一个例子来展示。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;h3&gt;这里是父组件&lt;/h3&gt;
        &lt;child&gt;
            &lt;div class=&quot;tmpl&quot;&gt;
              &lt;span&gt;菜单1&lt;/span&gt;
              &lt;span&gt;菜单2&lt;/span&gt;
              &lt;span&gt;菜单3&lt;/span&gt;
              &lt;span&gt;菜单4&lt;/span&gt;
              &lt;span&gt;菜单5&lt;/span&gt;
              &lt;span&gt;菜单6&lt;/span&gt;
            &lt;/div&gt;
        &lt;/child&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;child&quot;&gt;
        &lt;h3&gt;这里是子组件&lt;/h3&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p>
<pre><code class="language-html">&lt;div class=&quot;tmpl&quot;&gt;
  &lt;span&gt;菜单1&lt;/span&gt;
  &lt;span&gt;菜单2&lt;/span&gt;
  &lt;span&gt;菜单3&lt;/span&gt;
  &lt;span&gt;菜单4&lt;/span&gt;
  &lt;span&gt;菜单5&lt;/span&gt;
  &lt;span&gt;菜单6&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>最终的渲染结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892088251.png" alt="" loading="lazy"></p>
<h1 id="具名插槽">具名插槽</h1>
<p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个<strong>具名插槽</strong>和<strong>单个插槽</strong>的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;child&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt;
        &lt;span&gt;菜单1&lt;/span&gt;
        &lt;span&gt;菜单2&lt;/span&gt;
        &lt;span&gt;菜单3&lt;/span&gt;
        &lt;span&gt;菜单4&lt;/span&gt;
        &lt;span&gt;菜单5&lt;/span&gt;
        &lt;span&gt;菜单6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt;
        &lt;span&gt;菜单-1&lt;/span&gt;
        &lt;span&gt;菜单-2&lt;/span&gt;
        &lt;span&gt;菜单-3&lt;/span&gt;
        &lt;span&gt;菜单-4&lt;/span&gt;
        &lt;span&gt;菜单-5&lt;/span&gt;
        &lt;span&gt;菜单-6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot;&gt;
        &lt;span&gt;菜单-&gt;1&lt;/span&gt;
        &lt;span&gt;菜单-&gt;2&lt;/span&gt;
        &lt;span&gt;菜单-&gt;3&lt;/span&gt;
        &lt;span&gt;菜单-&gt;4&lt;/span&gt;
        &lt;span&gt;菜单-&gt;5&lt;/span&gt;
        &lt;span&gt;菜单-&gt;6&lt;/span&gt;
      &lt;/div&gt;
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
    // 具名插槽
    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 具名插槽
    &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt;
    // 匿名插槽
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596892200490.png" alt="" loading="lazy"><br>
可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。</p>
<h1 id="作用域插槽-带数据的插槽">作用域插槽 | 带数据的插槽</h1>
<p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p>
<pre><code class="language-cmd">匿名插槽
&lt;slot&gt;&lt;/slot&gt;
具名插槽
&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
</code></pre>
<p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p>
<pre><code class="language-html">&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;
 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    },
}
</code></pre>
<p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p>
<pre><code class="language-cmd">&lt;child&gt;
   html模板
&lt;/child&gt;
</code></pre>
<p>可以说是子组件暴露的一个让父组件传入自定义内容的接口。<br>
写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。<br>
OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？<br>
<code>正因为作用域插槽绑定了一套数据，父组件可以拿来用。</code>于是，情况就变成了这样：<code>样式父组件说了算，但内容可以显示子组件插槽绑定的。</code><br>
我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。<br>
下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;!--第一次使用：用flex展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;div class=&quot;tmpl&quot;&gt;
          &lt;span v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第二次使用：用列表展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第三次使用：直接显示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;              &lt;!--通过slot-scope获取子组件的信息--&gt;
       {{user.data}}
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;
    &lt;child&gt;
      我就是模板
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;

</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;

    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 作用域插槽
    &lt;slot  :data=&quot;data&quot;&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    }
}
</code></pre>
<p>结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892616696.png" alt="" loading="lazy"></p>
<h1 id="slot-scope">slot-scope</h1>
<p><strong>父组件中在使用时：</strong></p>
<ul>
<li>默认插槽的话直接在子组件的标签内写入内容即可</li>
<li>具名插槽是在默认插槽的基础上加上slot属性，值为子组件插槽name属性值</li>
<li>作用域插槽则是通过<code>slot-scope获取子组件的信息</code>，在内容中使用。这里可以用解构语法去直接获取想要的属性</li>
</ul>
<h1 id="v-slot">v-slot</h1>
<pre><code class="language-cmd">在vue2.6中，上述的API被软废弃（3.0正式废弃），取而代之的是内置指令v-slot，可以缩写为【#】
</code></pre>
<p>**子组件用法保持不变，**父组件中</p>
<ul>
<li>slot属性弃用，具名插槽通过指令参数<code>v-slot:插槽名</code>的形式传入，可以简化为 <code>#插槽名。</code></li>
<li><code>slot-scope</code>属性弃用，作用域插槽通过<code>v-slot:xxx=&quot;slotProps&quot;</code>的slotProps来获取子组件传出的属性</li>
<li>v-slot属性只能在 <code>&lt;template&gt;</code>上使用，但在**【只有默认插槽时】**可以在组件标签上使用</li>
</ul>
<pre><code class="language-html">//Parent
&lt;template&gt;
  &lt;child&gt;
   &lt;!--默认插槽--&gt;
   &lt;template v-slot&gt;
     &lt;div&gt;默认插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--具名插槽--&gt;
   &lt;template #header&gt;
     &lt;div&gt;具名插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--作用域插槽--&gt;
   &lt;template #footer=&quot;slotProps&quot;&gt;
     &lt;div&gt;
      {{slotProps.testProps}}
     &lt;/div&gt;
   &lt;/template&gt;
  &lt;child&gt;
&lt;/template&gt;
</code></pre>
<h1 id="拓展用法">拓展用法：</h1>
<ol>
<li>同样可以通过解构获取v-slot={user},<br>
还可以重命名v-slot=&quot;{user: newName}&quot;和定义默认值v-slot=&quot;{user = '默认值'}&quot;</li>
<li>插槽名可以是动态变化的 v-slot:[slotName]</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>默认插槽名为<code>default</code>，可以省略default直接写<code>v-slot</code>，<br>
缩写为#时不能不写参数，写成<code>#default</code>（这点所有指令都一样，v-bind、v-on）</li>
<li>多个插槽混用时，v-slot不能省略default</li>
</ol>
<h1 id="作用域插槽的原理">作用域插槽的原理</h1>
<p>slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过<br>
<code>template &gt;&gt; render function &gt;&gt; VNode &gt;&gt; DOM</code>过程。 组件挂载的本质就是执行渲染函数得到VNode，至于data/props/computed这些属性都是给VNode提供数据来源。<br>
在2.5之前，如果是普通插槽就<strong>直接是VNode</strong>的形式了，而如果是作用域插槽，由于子组件需要在父组件访问子组件的数据，所以父组件下是一个<strong>未执行的函数</strong><code>(slotScope) =&gt; return h('div', slotScope.msg)</code>，接受子组件的slotProps参数，在子组件渲染实例时会调用该函数传入数据。<br>
在2.6之后，两者合并，普通插槽也变成一个函数，只是不接受参数了。</p>
<h1 id="总结">总结</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596938553804.png" alt="" loading="lazy"></figure>
<h1 id="slot的使用场景">slot的使用场景</h1>
<ul>
<li>布局组件、</li>
<li>表格列、</li>
<li>下拉选项</li>
</ul>
<h1 id="slot-scope的使用场景">slot-scope的使用场景</h1>
<p>想象一个场景：<br>
<strong>当你要给同事封装一个列表组件，你就需要使用作用域插槽（注意是列表或者类似列表的组件）</strong><br>
你开发的这个列表组件要如何使用呢？<br>
一般来说作为列表组件的调用者，你的同事先做ajax请求，拿到一个这样的数组</p>
<pre><code class="language-json">   todos: [
        {
          id: 0,
          text: 'ziwei0',
          isComplete: false
        },
        {
          text: 'ziwei1',
          id: 1,
          isComplete: true
        },
        {
          text: 'ziwei2',
          id: 2,
          isComplete: false
        },
        {
          text: 'ziwei3',
          id: 3,
          isComplete: false
        }
      ]
</code></pre>
<p>之后会把todso传递给列表组件吧，那么列表组件内部做什么事情呢？<br>
列表内部肯定会v-for去帮你的同事渲染这个数组嘛。 就类似element-ui里的table组件一样<br>
问题的关键就在这里<br>
<strong>列表组件的循环，是发生在组件内部的，所以通过 v-for=&quot;todo in todos&quot; ,列表组件很容易拿到一项todo，但列表拿到数据没用呀，列表只是一个瓜皮，它又不懂业务逻辑这个数据是你同事的业务数据，</strong><br>
<strong>所以这个数据必须得交给组件的调用者，也就是把数据交给你的同事才对。</strong></p>
<p>那么你怎样才能把每一项的todo数据给传递出去呢？<br>
你会发现没有办法！</p>
<p>无论是用$emit、vuex还是localStorage，可以考虑一下，会发现没有合适的时机，能让你把todo传递出去</p>
<p>所以为了应对这个场景下，发明了<code>作用域插槽</code>，列表组件可以通过<code>&lt;slot :todo=&quot;todo&quot;&gt;&lt;/slot&gt;</code>传递todo出去<br>
你的同事可以通过 slot-scope=&quot;slotsProps&quot;<code>拿到todo</code>。<br>
回答几个疑问，其实如果你看懂上面的问题，应该可以回答下面的问题。这也是我曾经的疑问</p>
<ul>
<li>疑问1：一般不是我们传参数来调用组件吗？为什么组件还把数据传递回来？</li>
</ul>
<pre><code class="language-cmd">的确，调用ui组件时一般是我们传递配置参数给他们。

但是就像elemnt-ui的table组件，你把数组传递给table后，是不是有时候需要拿到某一行的row对象

并根据row对象里的字段，来判断一些内容的显示隐藏？

因为循环的过程发生在table组件内部，所以table组件可以方便的获取到每一项数据，但是这些数据最终不是给组件的，而是我们自己要用的业务数据。所以也需要一个方式，让调用者能拿到自己想要的数据
</code></pre>
<ul>
<li>疑问2： 既然子组件最终还要把我给他的数据，再返还给我，那我当初还干嘛给它，能不能就自己在父组件里玩？</li>
</ul>
<pre><code class="language-cmd">如果你不把数据给子组件当然可以。但是就等于抛弃掉了子组件的封装，只能你直接在父组件自己写一个列表

毕竟你不把数据给子组件，子组件还渲染个锤子？没有父子关系的话，也就不用什么插槽了。

但是咱不是为了封装后，可以复用嘛，总不能永远不用组件嘛
</code></pre>
<ul>
<li>疑问3： 父组件需要子组件的数据？那不会有$emit和vuex嘛，为什么要有slot-scope？</li>
</ul>
<pre><code class="language-cmd">$emit和vuex是数据传递的一种方法，但是你可以尝试用$emit和vuex把todo传递给父组件。

你会发现的确没有合适的钩子、时机来$emit数据
</code></pre>
<h1 id="26新增用法">2.6新增用法</h1>
<h2 id="动态插槽名260新增">动态插槽名(2.6.0新增)</h2>
<p>动态指令参数(需要自己了解)也可以用在v-slot上，来定义动态的插槽名：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<h2 id="具名插槽的缩写260新增">具名插槽的缩写(2.6.0新增)</h2>
<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：<br>
原来是这样写的：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;  
</code></pre>
<p>现在可以这样写：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;
</code></pre>
<p>如果希望使用缩写的话，必须始终以明确插槽名取而代之：</p>
<pre><code class="language-html">&lt;test #default=&quot;{ usertext }&quot;&gt;
  {{ usertext.firstName }}
&lt;/test&gt;
</code></pre>
<h1 id="其他示例">其他示例</h1>
<p>插槽 prop 允许我们将插槽转换为<code>可复用</code>的模板，这些模板可以基于输入的 <code>prop</code>渲染出不同的内容。 这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。<br>
例如，我们要实现一个 <code>&lt;todo-list&gt;</code>组件，它是一个列表且包含布局和过滤逻辑：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>我们可以将每个<code>todo</code>作为父级组件的插槽，以此通过父级组件对其进行控制，然后将<code>todo</code> 作为一个插槽<code>prop</code>进行绑定：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    &lt;!--
    我们为每个 todo 准备了一个插槽，
    将 `todo` 对象作为一个插槽的 prop 传入。
    --&gt;
    &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code>组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code>作为替代方案，并且可以从子组件获取数据：</p>
<pre><code class="language-html">&lt;todo-list v-bind:todos=&quot;todos&quot;&gt;
  &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
&lt;/todo-list&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 消息订阅与发布]]></title>
        <id>https://cutezhangq.github.io/post/xiao-xi-ding-yue-yu-fa-bu/</id>
        <link href="https://cutezhangq.github.io/post/xiao-xi-ding-yue-yu-fa-bu/">
        </link>
        <updated>2020-08-07T03:04:04.000Z</updated>
        <summary type="html"><![CDATA[<p>结合 Vue 源码谈谈发布-订阅模式</p>
<h1 id="发布订阅模式主要包含哪些内容呢">发布订阅模式主要包含哪些内容呢?</h1>
<ul>
<li>发布函数，发布的时候执行相应的回调</li>
<li>订阅函数，添加订阅者,传入发布时要执行的函数,可能会携额外参数</li>
<li>一个缓存订阅者以及订阅者的回调函数的列表</li>
<li>取消订阅(需要分情况讨论)</li>
</ul>
<p>这么看下来,其实就像 JavaScript 中的事件模型,我们在DOM节点上绑定事件函数,触发的时候执行就是应用了发布-订阅模式.</p>
<h1 id="我们先按照上面的内容自己实现一个-observer-对象如下">我们先按照上面的内容自己实现一个 Observer 对象如下:</h1>
<pre><code class="language-js">//用于存储订阅的事件名称以及回调函数列表的键值对
function Observer() {
    this.cache = {}  
}

//key:订阅消息的类型的标识（名称），fn收到消息之后执行的回调函数
Observer.prototype.on = function (key,fn) {
    if(!this.cache[key]){
        this.cache[key]=[]
    }
    this.cache[key].push(fn)
}


//arguments 是发布消息时候携带的参数数组
Observer.prototype.emit = function (key) {
    if(this.cache[key]&amp;&amp;this.cache[key].length&gt;0){
        var fns = this.cache[key]
    }
    for(let i=0;i&lt;fns.length;i++){
        Array.prototype.shift.call(arguments)
        fns[i].apply(this,arguments)
    }
}
// remove 的时候需要注意，如果你直接传入一个匿名函数fn，那么你在remove的时候是无法找到这个函数并且把它移除的，变通方式是传入一个
//指向该函数的指针，而 订阅的时候存入的也是这个指针
Observer.prototype.remove = function (key,fn) {
    let fns = this.cache[key]
    if(!fns||fns.length===0){
        return
    }
    //如果没有传入fn，那么就是取消所有该事件的订阅
    if(!fn){
        fns=[]
    }else {
        fns.forEach((item,index)=&gt;{
            if(item===fn){
                fns.splice(index,1)
            }
        })
    }
}


//example


var obj = new Observer()
obj.on('hello',function (a,b) {
    console.log(a,b)
})
obj.emit('hello',1,2)
//取消订阅事件的回调必须是具名函数
obj.on('test',fn1 =function () {
    console.log('fn1')
})
obj.on('test',fn2 = function () {
    console.log('fn2')
})
obj.remove('test',fn1)
obj.emit('test')
</code></pre>
<p>为什么会使用发布订阅模式呢? 它的优点在于:</p>
<ul>
<li>实现<strong>时间上的解耦</strong>(组件,模块之间的异步通讯)</li>
<li><strong>对象之间的解耦</strong>,交由发布订阅的对象管理对象之间的耦合关系.</li>
</ul>
<h1 id="发布-订阅模式在-vue中的应用">发布-订阅模式在 Vue中的应用</h1>
<p>发布-订阅模式又叫<code>观察者模式</code>,它定义对象间的一种<code>一对多</code>的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。JavaScript开发中我们一般用事件模型来代替传统的发布-订阅模式</p>
<h1 id="案例介绍1">案例介绍1</h1>
<p>卖烧饼的店主可以把小明、小龙的电话记录下来,等店里有烧饼了在通知小龙小明来拿这就是所谓的发布-订阅模式，代码如下：</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:[],//缓存列表
    addlisten:function(fn){//增加订阅者
        this.clienlist.push(fn);
    },
    trigger:function(){//发布消息
        for(var i=0,fn;fn=this.clienlist[i++];){
            fn.apply(this,arguments);
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(10,&quot;椒盐&quot;);
</code></pre>
<p>从代码中可以看出，只有小明，小龙预定了烧饼，烧饼店就可以发布消息告诉小龙与小明。但是有个问题不知道大家发现了没有。小明只喜欢椒盐味道的。而小龙只喜欢焦糖味道的。上面的代码就满足不了客户的需求，给客户一种感觉就是，不管我喜欢不喜欢，你都会发给我。如果发布比较多，客户就会感到厌烦，甚至会想删除订阅。下边是对代码进行改良大家可以看看。</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    },
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove:function(key,fn){
        var fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(&quot;焦糖&quot;,fn1=function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(&quot;椒盐&quot;,function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(&quot;椒盐&quot;,10,&quot;椒盐&quot;);

Sesamecakeshop.remove(&quot;焦糖&quot;,fn1);//注意这里是按照地址引用的。如果传入匿名函数则删除不了        

Sesamecakeshop.trigger(&quot;焦糖&quot;,40,&quot;焦糖&quot;);

</code></pre>
<p>删除的时候需要注意的是，如果订阅的时候传递的是匿名函数，删除的时候如果传入的也是匿名函数。则删除不了。因为删除时候是按照地址引用删除的。传进去的两个匿名函数，对应的地址引用是不同的。</p>
<h1 id="案例介绍2">案例介绍2</h1>
<p>比如咱们常见的用户身份分别有不同的功能，超级管理员拥有最高权限，可以删除修改任意用户。而普通用户则只能修改自己的账户信息。首先是用户身份验证，验证通过之后对应功能才可以显示。</p>
<pre><code class="language-js">//登录发布-订阅模式
login={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    }
}
//超级管理员修改所有用户
var editall=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editall.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;超级管理员修改所有用户&quot;);
        }
    }
})();

//仅仅修改自己
var editOwn=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editOwn.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;仅仅修改自己&quot;);
        }
    }
})();
</code></pre>
<p>发布-订阅模式简单封装</p>
<pre><code class="language-js">var _Event=(function(){
    var clienlist={},
    addlisten,trigger,remove;
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten=function(key,fn){
        if(!clienlist[key]){
            clienlist[key]=[];
        }
        clienlist[key].push(fn);
    };
    /**
     * 发布消息
     * */
    trigger=function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    };
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove=function(key,fn){
        var fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    };
    return{
        addlisten:addlisten,
        trigger:trigger,
        remove:remove
    }
})();


_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
});
_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
})
_Event.trigger(&quot;yyyy&quot;,&quot;xxx&quot;,&quot;前端工程师&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596872061540.png" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>发布-订阅模式就是常说的观察者模式，在实际开发中非常有用。它的优点是为时间是解耦，为对象之间解构，它的应用非常广泛，既可以在异步编程中也可以帮助我们完成更松的解耦。发布-订阅模式还可以帮助我们实现设计模式，从架构上来看，无论MVC还是MVVC都少不了发布-订阅模式的参与。然而发布-订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。</p>
]]></summary>
        <content type="html"><![CDATA[<p>结合 Vue 源码谈谈发布-订阅模式</p>
<h1 id="发布订阅模式主要包含哪些内容呢">发布订阅模式主要包含哪些内容呢?</h1>
<ul>
<li>发布函数，发布的时候执行相应的回调</li>
<li>订阅函数，添加订阅者,传入发布时要执行的函数,可能会携额外参数</li>
<li>一个缓存订阅者以及订阅者的回调函数的列表</li>
<li>取消订阅(需要分情况讨论)</li>
</ul>
<p>这么看下来,其实就像 JavaScript 中的事件模型,我们在DOM节点上绑定事件函数,触发的时候执行就是应用了发布-订阅模式.</p>
<h1 id="我们先按照上面的内容自己实现一个-observer-对象如下">我们先按照上面的内容自己实现一个 Observer 对象如下:</h1>
<pre><code class="language-js">//用于存储订阅的事件名称以及回调函数列表的键值对
function Observer() {
    this.cache = {}  
}

//key:订阅消息的类型的标识（名称），fn收到消息之后执行的回调函数
Observer.prototype.on = function (key,fn) {
    if(!this.cache[key]){
        this.cache[key]=[]
    }
    this.cache[key].push(fn)
}


//arguments 是发布消息时候携带的参数数组
Observer.prototype.emit = function (key) {
    if(this.cache[key]&amp;&amp;this.cache[key].length&gt;0){
        var fns = this.cache[key]
    }
    for(let i=0;i&lt;fns.length;i++){
        Array.prototype.shift.call(arguments)
        fns[i].apply(this,arguments)
    }
}
// remove 的时候需要注意，如果你直接传入一个匿名函数fn，那么你在remove的时候是无法找到这个函数并且把它移除的，变通方式是传入一个
//指向该函数的指针，而 订阅的时候存入的也是这个指针
Observer.prototype.remove = function (key,fn) {
    let fns = this.cache[key]
    if(!fns||fns.length===0){
        return
    }
    //如果没有传入fn，那么就是取消所有该事件的订阅
    if(!fn){
        fns=[]
    }else {
        fns.forEach((item,index)=&gt;{
            if(item===fn){
                fns.splice(index,1)
            }
        })
    }
}


//example


var obj = new Observer()
obj.on('hello',function (a,b) {
    console.log(a,b)
})
obj.emit('hello',1,2)
//取消订阅事件的回调必须是具名函数
obj.on('test',fn1 =function () {
    console.log('fn1')
})
obj.on('test',fn2 = function () {
    console.log('fn2')
})
obj.remove('test',fn1)
obj.emit('test')
</code></pre>
<p>为什么会使用发布订阅模式呢? 它的优点在于:</p>
<ul>
<li>实现<strong>时间上的解耦</strong>(组件,模块之间的异步通讯)</li>
<li><strong>对象之间的解耦</strong>,交由发布订阅的对象管理对象之间的耦合关系.</li>
</ul>
<h1 id="发布-订阅模式在-vue中的应用">发布-订阅模式在 Vue中的应用</h1>
<p>发布-订阅模式又叫<code>观察者模式</code>,它定义对象间的一种<code>一对多</code>的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。JavaScript开发中我们一般用事件模型来代替传统的发布-订阅模式</p>
<h1 id="案例介绍1">案例介绍1</h1>
<p>卖烧饼的店主可以把小明、小龙的电话记录下来,等店里有烧饼了在通知小龙小明来拿这就是所谓的发布-订阅模式，代码如下：</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:[],//缓存列表
    addlisten:function(fn){//增加订阅者
        this.clienlist.push(fn);
    },
    trigger:function(){//发布消息
        for(var i=0,fn;fn=this.clienlist[i++];){
            fn.apply(this,arguments);
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(10,&quot;椒盐&quot;);
</code></pre>
<p>从代码中可以看出，只有小明，小龙预定了烧饼，烧饼店就可以发布消息告诉小龙与小明。但是有个问题不知道大家发现了没有。小明只喜欢椒盐味道的。而小龙只喜欢焦糖味道的。上面的代码就满足不了客户的需求，给客户一种感觉就是，不管我喜欢不喜欢，你都会发给我。如果发布比较多，客户就会感到厌烦，甚至会想删除订阅。下边是对代码进行改良大家可以看看。</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    },
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove:function(key,fn){
        var fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(&quot;焦糖&quot;,fn1=function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(&quot;椒盐&quot;,function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(&quot;椒盐&quot;,10,&quot;椒盐&quot;);

Sesamecakeshop.remove(&quot;焦糖&quot;,fn1);//注意这里是按照地址引用的。如果传入匿名函数则删除不了        

Sesamecakeshop.trigger(&quot;焦糖&quot;,40,&quot;焦糖&quot;);

</code></pre>
<p>删除的时候需要注意的是，如果订阅的时候传递的是匿名函数，删除的时候如果传入的也是匿名函数。则删除不了。因为删除时候是按照地址引用删除的。传进去的两个匿名函数，对应的地址引用是不同的。</p>
<h1 id="案例介绍2">案例介绍2</h1>
<p>比如咱们常见的用户身份分别有不同的功能，超级管理员拥有最高权限，可以删除修改任意用户。而普通用户则只能修改自己的账户信息。首先是用户身份验证，验证通过之后对应功能才可以显示。</p>
<pre><code class="language-js">//登录发布-订阅模式
login={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    }
}
//超级管理员修改所有用户
var editall=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editall.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;超级管理员修改所有用户&quot;);
        }
    }
})();

//仅仅修改自己
var editOwn=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editOwn.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;仅仅修改自己&quot;);
        }
    }
})();
</code></pre>
<p>发布-订阅模式简单封装</p>
<pre><code class="language-js">var _Event=(function(){
    var clienlist={},
    addlisten,trigger,remove;
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten=function(key,fn){
        if(!clienlist[key]){
            clienlist[key]=[];
        }
        clienlist[key].push(fn);
    };
    /**
     * 发布消息
     * */
    trigger=function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    };
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove=function(key,fn){
        var fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    };
    return{
        addlisten:addlisten,
        trigger:trigger,
        remove:remove
    }
})();


_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
});
_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
})
_Event.trigger(&quot;yyyy&quot;,&quot;xxx&quot;,&quot;前端工程师&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596872061540.png" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>发布-订阅模式就是常说的观察者模式，在实际开发中非常有用。它的优点是为时间是解耦，为对象之间解构，它的应用非常广泛，既可以在异步编程中也可以帮助我们完成更松的解耦。发布-订阅模式还可以帮助我们实现设计模式，从架构上来看，无论MVC还是MVVC都少不了发布-订阅模式的参与。然而发布-订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。</p>
<!-- more -->
<h1 id="订阅发布模式和观察者模式的区别">订阅发布模式和观察者模式的区别</h1>
<p><strong>发布订阅模式属于广义上的观察者模式</strong><br>
发布订阅模式是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式</p>
<p><strong>发布订阅模式多了个事件通道</strong><br>
在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应<br>
<img src="https://cutezhangq.github.io/post-images/1596877097254.png" alt="" loading="lazy"></p>
<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件<br>
以此避免发布者和订阅者之间产生依赖关系<br>
<img src="https://cutezhangq.github.io/post-images/1596877130031.png" alt="" loading="lazy"></p>
<p>总结起来就是，一个是紧密耦合，一个是松散耦合。优缺点也很明显，紧密耦合的方式简单直接，扩展性差，而且要求两端同时存在。松散耦合不直接产生依赖，更容易扩展，懒加载的时候会有优势，但稍显复杂。</p>
<h2 id="从代码看区别">从代码看区别</h2>
<p>需求：数据打包下载功能</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[双向数据绑定、单向数据流]]></title>
        <id>https://cutezhangq.github.io/post/shuang-xiang-shu-ju-bang-ding-dan-xiang-shu-ju-liu/</id>
        <link href="https://cutezhangq.github.io/post/shuang-xiang-shu-ju-bang-ding-dan-xiang-shu-ju-liu/">
        </link>
        <updated>2020-08-07T01:30:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单向数据流和双向数据绑定有什么优缺点单向数据流优缺点">单向数据流和双向数据绑定有什么优缺点？单向数据流优缺点</h1>
<p><strong>优点：</strong><br>
所有状态的改变可记录、可跟踪，源头易追溯;<br>
所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性;<br>
一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data);<br>
如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。</p>
<p><strong>缺点：</strong><br>
HTML 代码渲染完成，无法改变，有新数据，就须把旧 HTML 代码去掉，整合新数据和模板重新渲染;<br>
代码量上升，数据流转过程变长，出现很多类似的样板代码;<br>
同时由于对应用状态独立管理的严格要求(单一的全局 store)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用)，会显得啰嗦及繁琐。</p>
<h1 id="双向数据绑定的优缺点">双向数据绑定的优缺点：</h1>
<p><strong>优点：</strong><br>
用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去；<br>
无需进行和单向数据绑定的那些相关操作；<br>
在表单交互较多的场景下，会简化大量业务无关的代码。<br>
<strong>缺点：</strong><br>
无法追踪局部状态的变化；<br>
“暗箱操作”，增加了出错时 debug 的难度；<br>
由于组件数据变化来源入口变得可能不止一个，数据流转方向易紊乱，若再缺乏“管制”手段，崩溃。</p>
<p>这样来看，单向绑定跟双向绑定在功能上基本上是互补的，所以我们可以在合适的场景下使用合适的手段。比如在 UI 控件 中(通常是类表单操作)，我会使用双向的方式绑定数据；而其他场景则统一采用 单向 + inline event ( &lt;component :msg=“msg” @update=“updateMsg(msg)”&gt; ) 的方式构建应用。<br>
<img src="https://cutezhangq.github.io/post-images/1596891716608.png" alt="" loading="lazy"></p>
<h1 id="单向数据流">单向数据流：</h1>
<p>如：<strong>props</strong><br>
数据从父级组件传递给子组件，只能单向绑定。<br>
子组件内部不能直接修改从父级传递过来的数据。<br>
其中，props的用法：<br>
props 是<strong>单向绑定</strong>的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改父组件的状态。<br>
所以<code>不应该在子组件中修改 props 中的值，Vue 会报出警告</code>。</p>
<h2 id="修改-props-数据">修改 props 数据</h2>
<p>通常有两种原因：</p>
<ul>
<li>prop 作为初始值传入后，子组件想把它当做局部数据来用</li>
<li>prop 作为初始值传入后，由子组件处理成其他数据输出</li>
</ul>
<h2 id="应对办法是">应对办法是</h2>
<ul>
<li>定义一个<code>局部变量</code>，并用 prop 的值初始化它<br>
但是由于定义的 ownChildMsg 只能接受 forChildMsg <code>的初始值</code>，当父组件要传递的值变化发生时，ownChildMsg <code>无法收到更新</code>。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return { ownChildMsg: this.forChildMsg };
  }
};
</code></pre>
<p>这里我们加了一个<p>用于查看 ownChildMsg 数据是否变化，结果发现只有默认值传递给了 ownChildMsg，父组件改变只会变化到 forChildMsg，不会修改 ownChildMsg。</p>
<ul>
<li>定义一个<code>计算属性</code>，处理 prop 的值并返回<br>
由于是计算属性，所以只能显示值，不能设置值。我们这里设置的是一旦从父组件修改了 forChildMsg 数据，我们就把 forChildMsg 加上一个字符串&quot;---ownChildMsg&quot;，然后显示在屏幕上。这时是可以每当父组件修改了新数据，<code>都会更新</code> ownChildMsg 数据的。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  computed: {
    ownChildMsg() {
      return this.forChildMsg + &quot;---ownChildMsg&quot;;
    }
  }
};
</code></pre>
<ul>
<li>更加妥帖的方式是<code>使用变量存储</code> prop 的初始值，并用<code>watch</code>来观察 prop 值得<code>变化</code>。发生变化时，更新变量的值。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return {
      ownChildMsg: this.forChildMsg
    };
  },
  watch: {
    forChildMsg() {
      this.ownChildMsg = this.forChildMsg;
    }
  }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[computed，watch，method执行的先后顺序]]></title>
        <id>https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/</id>
        <link href="https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/">
        </link>
        <updated>2020-08-06T13:57:16.000Z</updated>
        <content type="html"><![CDATA[<h1 id="computed">computed：</h1>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<h1 id="methods">methods：</h1>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<h1 id="watch">watch：</h1>
<p>是一种更通用的方式来观察和响应 Vue 实例上的数据变动。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
<p>通俗来讲，</p>
<p>computed是在HTML DOM加载后马上执行的，如赋值；</p>
<p>而methods则必须要有一定的触发条件才能执行，如点击事件；</p>
<p>watch呢？它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。</p>
<p>所以他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
<p>下面的例子可以做为说明。</p>
<p>computed 属性 vs watched 属性：Vue 确实提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：watch 属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的想法是使用 computed 属性而不是命令式的 watch 回调。</p>
<h1 id="computed与watch的区别">computed与watch的区别</h1>
<p>在很多情况下, computed会比watch使用起来更加方便,但是当需要在数据变化时执行异步或者开销比较大的情况下,用watch会更加合适。<br>
例如官网提供的例子(问与答。watch观察question的值,若值有改变会执行方法getAnswer,并且根据question不同的值, answer会给出不同的回答,并且会异步调用API返回相应的值,这些都是计算属性做不到的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>目的</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>computed</td>
<td>依赖变动实时更新数据</td>
<td>更新数据</td>
</tr>
<tr>
<td>watch</td>
<td>观察某一特定的值，执行特定的函数</td>
<td>观察数据</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">&lt;divid=&quot;demo&quot;&gt;{{ fullName }}&lt;/div&gt;

使用watch方法观察数据（单个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar',
fullName: 'Foo Bar'
},
watch: {
firstName: function (val) {
this.fullName = val + ' ' + this.lastName
},
lastName: function (val) {
this.fullName = this.firstName + ' ' + val
}
}
})

使用computed方法计算数据（多个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar'
},
computed: {
fullName: function () {
return this.firstName + ' ' + this.lastName
}
}
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据通信方案、组件间传值]]></title>
        <id>https://cutezhangq.github.io/post/shu-ju-tong-xin-fang-an-zu-jian-jian-chuan-zhi/</id>
        <link href="https://cutezhangq.github.io/post/shu-ju-tong-xin-fang-an-zu-jian-jian-chuan-zhi/">
        </link>
        <updated>2020-08-06T13:12:36.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="组件间通信的特点">组件间通信的特点</h1>
<pre><code>1. 不要在子组件中直接修改父组件的状态数据
2. 数据在哪, 更新数据的行为(函数)就应该定义在哪
</code></pre>
<h1 id="vue-组件数据通信方案总结">Vue 组件数据通信方案总结</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596720130251.png" alt="" loading="lazy"><br>
组件 A 与组件 B 、C 之间是父子组件，组件 B 、C 之间是兄弟组件，而组件 A 、D 之间是隔代的关系。<br>
那么对于这些不同的关系，本文主要分享了他们之间可以采用的几种数据通信方式，<br>
例如 Props 、$emit / $on 、Vuex 等，大家可以根据自己的使用场景可以选择适合的使用方式。</p>
<h1 id="一-prop-emit-父子-子父">一、 Prop / $emit    （父——&gt;子        子——&gt;父）</h1>
<h2 id="prop-通过绑定属性的方式">Prop  通过绑定属性的方式</h2>
<pre><code class="language-html">// 父组件   &lt;child :title=&quot;title1&quot;&gt;&lt;/child&gt;
// 子组件   props: { title:Object }
</code></pre>
<p>其中，props的用法：<br>
props 是<strong>单向绑定</strong>的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改父组件的状态。<br>
所以<code>不应该在子组件中修改 props 中的值，Vue 会报出警告</code>。</p>
<h2 id="修改-props-数据">修改 props 数据</h2>
<p>通常有两种原因：</p>
<ul>
<li>prop 作为初始值传入后，子组件想把它当做局部数据来用</li>
<li>prop 作为初始值传入后，由子组件处理成其他数据输出</li>
</ul>
<h2 id="应对办法是">应对办法是</h2>
<ul>
<li>定义一个<code>局部变量</code>，并用 prop 的值初始化它<br>
但是由于定义的 ownChildMsg 只能接受 forChildMsg <code>的初始值</code>，当父组件要传递的值变化发生时，ownChildMsg <code>无法收到更新</code>。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return { ownChildMsg: this.forChildMsg };
  }
};
</code></pre>
<p>这里我们加了一个<p>用于查看 ownChildMsg 数据是否变化，结果发现只有默认值传递给了 ownChildMsg，父组件改变只会变化到 forChildMsg，不会修改 ownChildMsg。</p>
<ul>
<li>定义一个<code>计算属性</code>，处理 prop 的值并返回<br>
由于是计算属性，所以只能显示值，不能设置值。我们这里设置的是一旦从父组件修改了 forChildMsg 数据，我们就把 forChildMsg 加上一个字符串&quot;---ownChildMsg&quot;，然后显示在屏幕上。这时是可以每当父组件修改了新数据，<code>都会更新</code> ownChildMsg 数据的。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  computed: {
    ownChildMsg() {
      return this.forChildMsg + &quot;---ownChildMsg&quot;;
    }
  }
};
</code></pre>
<ul>
<li>更加妥帖的方式是<code>使用变量存储</code> prop 的初始值，并用<code>watch</code>来观察 prop 值得<code>变化</code>。发生变化时，更新变量的值。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return {
      ownChildMsg: this.forChildMsg
    };
  },
  watch: {
    forChildMsg() {
      this.ownChildMsg = this.forChildMsg;
    }
  }
};
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="组件间通信的特点">组件间通信的特点</h1>
<pre><code>1. 不要在子组件中直接修改父组件的状态数据
2. 数据在哪, 更新数据的行为(函数)就应该定义在哪
</code></pre>
<h1 id="vue-组件数据通信方案总结">Vue 组件数据通信方案总结</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596720130251.png" alt="" loading="lazy"><br>
组件 A 与组件 B 、C 之间是父子组件，组件 B 、C 之间是兄弟组件，而组件 A 、D 之间是隔代的关系。<br>
那么对于这些不同的关系，本文主要分享了他们之间可以采用的几种数据通信方式，<br>
例如 Props 、$emit / $on 、Vuex 等，大家可以根据自己的使用场景可以选择适合的使用方式。</p>
<h1 id="一-prop-emit-父子-子父">一、 Prop / $emit    （父——&gt;子        子——&gt;父）</h1>
<h2 id="prop-通过绑定属性的方式">Prop  通过绑定属性的方式</h2>
<pre><code class="language-html">// 父组件   &lt;child :title=&quot;title1&quot;&gt;&lt;/child&gt;
// 子组件   props: { title:Object }
</code></pre>
<p>其中，props的用法：<br>
props 是<strong>单向绑定</strong>的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改父组件的状态。<br>
所以<code>不应该在子组件中修改 props 中的值，Vue 会报出警告</code>。</p>
<h2 id="修改-props-数据">修改 props 数据</h2>
<p>通常有两种原因：</p>
<ul>
<li>prop 作为初始值传入后，子组件想把它当做局部数据来用</li>
<li>prop 作为初始值传入后，由子组件处理成其他数据输出</li>
</ul>
<h2 id="应对办法是">应对办法是</h2>
<ul>
<li>定义一个<code>局部变量</code>，并用 prop 的值初始化它<br>
但是由于定义的 ownChildMsg 只能接受 forChildMsg <code>的初始值</code>，当父组件要传递的值变化发生时，ownChildMsg <code>无法收到更新</code>。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return { ownChildMsg: this.forChildMsg };
  }
};
</code></pre>
<p>这里我们加了一个<p>用于查看 ownChildMsg 数据是否变化，结果发现只有默认值传递给了 ownChildMsg，父组件改变只会变化到 forChildMsg，不会修改 ownChildMsg。</p>
<ul>
<li>定义一个<code>计算属性</code>，处理 prop 的值并返回<br>
由于是计算属性，所以只能显示值，不能设置值。我们这里设置的是一旦从父组件修改了 forChildMsg 数据，我们就把 forChildMsg 加上一个字符串&quot;---ownChildMsg&quot;，然后显示在屏幕上。这时是可以每当父组件修改了新数据，<code>都会更新</code> ownChildMsg 数据的。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  computed: {
    ownChildMsg() {
      return this.forChildMsg + &quot;---ownChildMsg&quot;;
    }
  }
};
</code></pre>
<ul>
<li>更加妥帖的方式是<code>使用变量存储</code> prop 的初始值，并用<code>watch</code>来观察 prop 值得<code>变化</code>。发生变化时，更新变量的值。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return {
      ownChildMsg: this.forChildMsg
    };
  },
  watch: {
    forChildMsg() {
      this.ownChildMsg = this.forChildMsg;
    }
  }
};
</code></pre>
<!-- more -->
<!-- more -->
<h2 id="emit-子组件向父组件传值通过事件形式所以是v-on也就是符号">$emit 子组件向父组件传值（通过事件形式,所以是v-on也就是@符号）</h2>
<pre><code class="language-html">// 父组件    @xxx=&quot;zzz&quot;    methods:{zzz(q){ this.qq = q }}    //q就是接收到的子组件值
// 子组件   this.$emit('xxx',yyy);    //yyy是值
</code></pre>
<p>子组件通过 $emit 事件向父组件发送消息，将自己的数据传递给父组件。<br>
应用：搜索框 ，在searchTab（子组件）中将用户输入的搜索内容传到search（父组件）中</p>
<p><strong>$emit 传递一个参数</strong><br>
子组件：</p>
<pre><code class="language-js">this.$emit('closeChange',false);
</code></pre>
<p>父组件：</p>
<pre><code class="language-js">&lt;posilCom @closeChange=&quot;closeCom($event)&quot;&gt;&lt;/posilCom&gt;
closeCom(msg) {
  this.msg = msg;
}
</code></pre>
<p><strong>$emit传递多个参数</strong><br>
子组件：</p>
<pre><code class="language-js">this.$emit('closeChange',false,true);
</code></pre>
<p>父组件：</p>
<pre><code class="language-js">&lt;posilCom @closeChange=&quot;closeCom(arguments)&quot;&gt;&lt;/posilCom&gt;
closeCom(msg) {
  this.msg1 = msg[0];
  this.msg2 = msg[1];
}
</code></pre>
<!-- more -->
<h1 id="二-emit-on-事件总线bus或者叫eventbus-适用于-父子-隔代-兄弟组件通信">二、 <code>$emit / $on</code>    事件总线：$bus或者叫EventBus     适用于 父子、隔代、兄弟组件通信</h1>
<h2 id="写法一将bus总线挂载到原型上用的时候直接thisbus即可使用发送-接收">写法一：将<code>$bus</code>总线挂载到原型上，用的时候直接this.$bus即可使用（发送、接收）</h2>
<pre><code class="language-js">写法一：
main.js
    Vue.prototype.$bus = new Vue()
发送：
    this.$bus.$emit('事件名称',参数)
接收
    this.$bus.$on('事件名称'，function(参数){
    })
</code></pre>
<p>Vue中的 事件总线：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">者</mi><mi mathvariant="normal">叫</mi><mi>E</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>B</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">—</mi><mi mathvariant="normal">—</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mi mathvariant="normal">到</mi><mi mathvariant="normal">非</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">适</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">于</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">子</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">隔</mi><mi mathvariant="normal">代</mi><mi mathvariant="normal">、</mi><mi mathvariant="normal">兄</mi><mi mathvariant="normal">弟</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">信</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi mathvariant="normal">‘</mi><mi mathvariant="normal">创</mi><mi mathvariant="normal">建</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">空</mi><mi mathvariant="normal">的</mi><mi>v</mi><mi>u</mi><mi>e</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">例</mi><mi mathvariant="normal">‘</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">做</mi><mi mathvariant="normal">‘</mi></mrow><annotation encoding="application/x-tex">bus或者叫EventBus    —— 通过事件总线获取到非父子组件通信， 适用于 父子、隔代、兄弟组件通信。
这个方法是通过`创建了一个空的 vue 实例`，当做 `</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord cjk_fallback">叫</span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord" style="margin-right:0.02778em;">—</span><span class="mord" style="margin-right:0.02778em;">—</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mord cjk_fallback">到</span><span class="mord cjk_fallback">非</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">适</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">于</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">隔</span><span class="mord cjk_fallback">代</span><span class="mord cjk_fallback">、</span><span class="mord cjk_fallback">兄</span><span class="mord cjk_fallback">弟</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">信</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord">‘</span><span class="mord cjk_fallback">创</span><span class="mord cjk_fallback">建</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">空</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">例</span><span class="mord">‘</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">做</span><span class="mord">‘</span></span></span></span>emit 事件的处理中心（事件总线）`，通过他来触发以及监听事件。</p>
<h2 id="写法二将事件总线event创建在父组件中通过父子组件传值的方式props将事件event传给子组件123并在子组件123中通过-thisevent使用">写法二：将事件总线Event创建在父组件中，通过父子组件传值的方式（props）将事件Event传给子组件123，并在子组件123中通过 this.Event使用。</h2>
<pre><code class="language-js">写法二：
//父组件中：
 事件总线：
     const Event = new Vue();
        data(){
            return{ 
                Event:Event 
                }
            }
 //子组件们:   
:Evnet=&quot;Event&quot;
</code></pre>
<pre><code class="language-js">//子组件1   将事件总线传到组件1中
props: {
        Event:Object
  },
    this.Event.$emit(&quot;xxx&quot;,this.name)   //    this.Event.$emit传值
</code></pre>
<pre><code class="language-js">//子组件2   将事件总线传到组件2中
props: {
    Event:Object
  },
    this.Event.$emit(&quot;yyy&quot;,this.age)    //    this.Event.$emit传值
</code></pre>
<pre><code class="language-js">//子组件3  将事件总线传到组件3中
  props: {
    Event:Object
  },
this.Event.$on(&quot;xxx&quot;,name=&gt;{    //this.Event.$on取值
    this.name = name 
})
this.Event.$on(&quot;yyy&quot;,age=&gt;{     //this.Event.$on取值
    this.age= age
})
</code></pre>
<!-- more -->
<h1 id="三-vuex">三、vuex</h1>
<p>应用：购物车（购物车中的数据信息是要被多个组件共享的）<br>
Vuex状态管理模式。<br>
它采用集中式存储 管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>
Vuex 实现了一个<strong>单项数据流</strong>。 每一个 Vuex 应用的核心就是 store（仓库）。<br>
“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>Vuex 的状态存储是<strong>响应式的</strong>。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到<code>高效更新</code>。</li>
<li>改变 store 中的状态的<code>唯一</code>途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</li>
</ul>
<pre><code class="language-js">// store
import Vue from 'vue';
import Vuex from 'vuex';

Vue.use(Vuex);

const store = new Vuex.Store({      //组件中数据状态存储管理的容器
state: {                    //3. 读取数据状态
    count: 1
},
mutations: {            //2. 修改status状态——唯一可进行修改的，是同步的
    increment(state) {
        state.count++;
    },
    reduce(state) {
        state.count--;
    }
},
actions: {                  //1. 提交数据给mutations,是异步的
    actIncrement({ commit }) {
        commit('increment');
    },
    actReduce({ commit }) {
        commit('reduce');
    }
},
getters: {               //4 读取数据，并对数据进行计算，最终读取数据
doubleCount: state =&gt; state.count*2
}
});

export default store;
</code></pre>
<pre><code class="language-html">// vue文件
&lt;template&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;p&gt;我的count：{{count}}&lt;/p&gt;
&lt;p&gt;doubleCount:{{doubleCount}}&lt;/p&gt;
&lt;button @click=&quot;this.actIncrement&quot;&gt;增加&lt;/button&gt;
&lt;button @click=&quot;this.actReduce&quot;&gt;减少&lt;/button&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-js">import { mapGetters, mapActions, mapState } from &quot;vuex&quot;;

export default {
name: &quot;demo&quot;,
data: function() {
    return {};
},
components: {},
props: {},
computed: {
    ...mapState([&quot;count&quot;]),
    ...mapGetters([&quot;doubleCount&quot;])
},
methods: {
    ...mapActions([&quot;actIncrement&quot;, &quot;actReduce&quot;])
}
};
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596764710488.png" alt="" loading="lazy"><br>
mapxxx是<code>辅助函数</code>，将方法<code>映射</code>过来<br>
如：mapMutations ，将组件中的 methods 映射为 store.commit 调用</p>
<pre><code class="language-js">methods:{
 ...mapMutations(['addAge'])
}
</code></pre>
<p>mapMutations(['addAge'])这一句就相当于下面的代码</p>
<pre><code class="language-js">addAge(payLoad){
  this.$store.commit('addAge',payLoad)
}
</code></pre>
<!-- more -->
<h1 id="四-attrs-listeners-适用于-隔代组件通信">四、$attrs / $listeners    （ 适用于 隔代组件通信）</h1>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">不</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">为</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">被</mi><mi mathvariant="normal">识</mi><mi mathvariant="normal">别</mi><mo>(</mo><mi mathvariant="normal">且</mi><mi mathvariant="normal">获</mi><mi mathvariant="normal">取</mi><mo>)</mo><mi mathvariant="normal">的</mi><mi mathvariant="normal">特</mi><mi mathvariant="normal">性</mi><mi mathvariant="normal">绑</mi><mi mathvariant="normal">定</mi><mo>(</mo><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">和</mi><mi>S</mi><mi>t</mi><mi>y</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">外</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">当</mi><mi mathvariant="normal">一</mi><mi mathvariant="normal">个</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">没</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">声</mi><mi mathvariant="normal">明</mi><mi mathvariant="normal">任</mi><mi mathvariant="normal">何</mi><mi>P</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">这</mi><mi mathvariant="normal">里</mi><mi mathvariant="normal">会</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">绑</mi><mi mathvariant="normal">定</mi><mo>(</mo><mi>C</mi><mi>l</mi><mi>a</mi><mi>s</mi><mi>s</mi><mi mathvariant="normal">和</mi><mi>S</mi><mi>t</mi><mi>y</mi><mi>l</mi><mi>e</mi><mi mathvariant="normal">除</mi><mi mathvariant="normal">外</mi><mo>)</mo><mi mathvariant="normal">，</mi><mi mathvariant="normal">并</mi><mi mathvariant="normal">且</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi>v</mi><mo>−</mo><mi>b</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">attrs： 包含了父作用域中不作为 Prop 被识别 (且获取) 的特性绑定(Class 和  Style 除外。
当一个组件没有声明任何 Prop 时，这里会包含所有父作用域的绑定 (Class 和 Style 除外)，并且可以通过 v-bind=&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">为</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">被</span><span class="mord cjk_fallback">识</span><span class="mord cjk_fallback">别</span><span class="mopen">(</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">获</span><span class="mord cjk_fallback">取</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">性</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">外</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">当</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">没</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">声</span><span class="mord cjk_fallback">明</span><span class="mord cjk_fallback">任</span><span class="mord cjk_fallback">何</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">这</span><span class="mord cjk_fallback">里</span><span class="mord cjk_fallback">会</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">绑</span><span class="mord cjk_fallback">定</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">和</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">除</span><span class="mord cjk_fallback">外</span><span class="mclose">)</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">并</span><span class="mord cjk_fallback">且</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span></span></span></span>attrs&quot; 传入内部组件——在创建高级别的组件时非常有用。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">：</mi><mi mathvariant="normal">包</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">了</mi><mi mathvariant="normal">父</mi><mi mathvariant="normal">作</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">域</mi><mi mathvariant="normal">中</mi><mi mathvariant="normal">的</mi><mo>(</mo><mi mathvariant="normal">不</mi><mi mathvariant="normal">含</mi><mi mathvariant="normal">.</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi mathvariant="normal">修</mi><mi mathvariant="normal">饰</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">的</mi><mo>)</mo><mi>v</mi><mo>−</mo><mi>o</mi><mi>n</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">监</mi><mi mathvariant="normal">听</mi><mi mathvariant="normal">器</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">可</mi><mi mathvariant="normal">以</mi><mi mathvariant="normal">通</mi><mi mathvariant="normal">过</mi><mi>v</mi><mo>−</mo><mi>o</mi><mi>n</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">listeners： 包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。
它可以通过 v-on=&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">包</span><span class="mord cjk_fallback">含</span><span class="mord cjk_fallback">了</span><span class="mord cjk_fallback">父</span><span class="mord cjk_fallback">作</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">域</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">的</span><span class="mopen">(</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">含</span><span class="mord">.</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord cjk_fallback">修</span><span class="mord cjk_fallback">饰</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">的</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">监</span><span class="mord cjk_fallback">听</span><span class="mord cjk_fallback">器</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">可</span><span class="mord cjk_fallback">以</span><span class="mord cjk_fallback">通</span><span class="mord cjk_fallback">过</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span></span></span></span>listeners&quot; 传入内部组件<br>
<img src="https://cutezhangq.github.io/post-images/1596765958655.png" alt="" loading="lazy"><br>
父组件:</p>
</li>
</ul>
<pre><code class="language-html">// 父组件
&lt;template&gt;
    &lt;div class=&quot;container&quot;&gt;
        &lt;button style=&quot;backgroundColor:lightgray&quot; @click=&quot;reduce&quot;&gt;减dd&lt;/button&gt;
        &lt;child1 :aa=&quot;aa&quot; :bb=&quot;bb&quot; :cc=&quot;cc&quot; :dd=&quot;dd&quot; @reduce=&quot;reduce&quot;&gt;&lt;/child1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Child1 from './component/child1.vue';
export default {
    name: 'demo',
    data: function() {
        return {
            aa: 1,
            bb: 2,
            cc: 3,
            dd: 100
    };
},
components: {
    Child1
},
methods: {
    reduce() {
        this.dd--;
    }
}
};
&lt;/script&gt;
</code></pre>
<p>// 子组件1 &quot; v-on=&quot;$listeners”    $attrs</p>
<pre><code class="language-html">// 子组件1
&lt;template&gt;
&lt;div&gt;
&lt;div class=&quot;center&quot;&gt;
&lt;p&gt;aa:{{aa}}&lt;/p&gt;
&lt;p&gt;child1的$attrs:{{$attrs}}&lt;/p&gt;
&lt;button @click=&quot;this.reduce1&quot;&gt;组件1减dd&lt;/button&gt;
&lt;/div&gt;
&lt;child2 v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/child2&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import child2 from './child2.vue';
export default {
name: 'demo1',
data() {
return {};
},
props: {
aa: Number
},
components: {
child2
},
methods: {
reduce1() {
this.$emit('reduce');
}
}
};
&lt;/script&gt;
</code></pre>
<p>//子组件2 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>t</mi><mi>t</mi><mi>r</mi><mi>s</mi><mi>v</mi><mo>−</mo><mi>b</mi><mi>i</mi><mi>n</mi><mi>d</mi><mo>=</mo><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">attrs   v-bind=&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span></span></span></span>attrs&quot;</p>
<pre><code class="language-html">// 子组件2
&lt;template&gt;
&lt;div&gt;
&lt;div class=&quot;center&quot;&gt;
&lt;p&gt;bb:{{bb}}&lt;/p&gt;
&lt;p&gt;child2的$attrs:{{$attrs}}&lt;/p&gt;
&lt;button @click=&quot;this.reduce2&quot;&gt;组件2减dd&lt;/button&gt;
&lt;/div&gt;
&lt;child3 v-bind=&quot;$attrs&quot;&gt;&lt;/child3&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import child3 from './child3.vue';
export default {
name: 'demo1',
data() {
return {};
},
props: {
bb: Number
},
components: {
child3
},
methods: {
reduce2() {
this.$emit('reduce');
}
}
};
&lt;/script&gt;
</code></pre>
<p>//子组件3    $attrs</p>
<pre><code class="language-html">// 子组件3
&lt;template&gt;
&lt;div class=&quot;center&quot;&gt;
&lt;p&gt;child3的$attrs:{{$attrs}}&lt;/p&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
name: 'demo3',
data() {
return {};
},
props: {
dd: String
},
};
&lt;/script&gt;
</code></pre>
<p>简单来说，<code>$attrs 里存放的是父组件中绑定的非 props 属性，$listeners 里面存放的是父组件中绑定的非原生事件。</code></p>
<h1 id="五-provide-inject-适用于-隔代组件通信">五、Provide / Inject     适用于 隔代组件通信</h1>
<p>Vue 2.2 版本以后新增了这两个 API ，<br>
这对选项需要<strong>一起使用</strong>，以允许<code>一个祖先</code>组件向其<code>所有子孙后代</code> 注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里<strong>始终生效</strong>。</p>
<ul>
<li>就是父组件通过 Provide 传入变量，任意子孙组件通过 Inject 来拿到变量。</li>
</ul>
<p>它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。<br>
需要注意的是： Provide 和 Inject 绑定并<code>不是可响应的</code>。这是刻意为之的。然而，如果你<code>传入了一个可监听的对象</code>，那么其对象的属性还是<code>可响应</code>的。<br>
所以，如果采用的是代码中注释的方式，父级的 name 如果改变了，子组件this.name 是不会改变的，仍然是 zxx ，而当采用代码中传入一个监听对象，修改对象中属性值，是可以监听到修改的。<br>
Provider / Inject 在项目中需要有较多公共传参时使用还是颇为方便的。</p>
<ul>
<li>小总结：传输数据父级一次注入，子孙组件一起共享的方式。</li>
</ul>
<p>//Provide<br>
data: function() {<br>
return {<br>
name: 'zxx'<br>
};<br>
},<br>
provide() {<br>
return {<br>
obj: this    //响应式的方式<br>
};<br>
},</p>
<pre><code class="language-html">// 父组件
&lt;template&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;button @click=&quot;this.changeName&quot;&gt;我要改名字了&lt;/button&gt;
&lt;p&gt;我的名字：{{name}}&lt;/p&gt;
&lt;child1&gt;&lt;/child1&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-js">
import Child1 from './component/child1.vue';
export default {
name: 'demo',
data: function() {
return {
name: 'zxx'
};
},
// provide() {
// return {
// name: this.name //这种绑定方式是不可响应的
// };
// },
provide() {
return {
obj: this
};
},
components: {
Child1
},
methods: {
changeName() {
this.name = '政采云前端';
}
}
};

</code></pre>
<p>//Inject<br>
inject: {<br>
obj: {<br>
default: () =&gt; {<br>
return {};<br>
}<br>
}<br>
},<br>
this.obj.name</p>
<pre><code class="language-html">// 子组件
&lt;template&gt;
&lt;div&gt;
&lt;div class=&quot;center&quot;&gt;
&lt;!-- &lt;p&gt;子组件名字:{{name}}&lt;/p&gt; --&gt;
&lt;p&gt;子组件名字:{{this.obj.name}}&lt;/p&gt;
&lt;/div&gt;
&lt;child2&gt;&lt;/child2&gt;
&lt;/div&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="language-js">import child2 from './child2.vue';

export default {
name: 'demo1',
data() {
return {};
},
props: {},
// inject: [&quot;name&quot;],
inject: {
obj: {
default: () =&gt; {
return {};
}
}
},
components: {
child2
},
};
</code></pre>
<h1 id="六-parent-children-refs-父子组件间通信">六、$parent / $children &amp; $refs               父子组件间通信</h1>
<ul>
<li>
<p><code>$parent / $children</code>： 指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code>访问父实例，子实例被推入父实例的<code>$children</code>数组中。</p>
</li>
<li>
<p><code>$refs</code>： 一个对象，持有注册过 ref  的所有 DOM 元素和组件实例。ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code>对象上。<br>
如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件。</p>
</li>
</ul>
<blockquote>
<p>// 父组件<br>
<child1 ref="comp1"></child1><br>
<child2 ref="comp2"></child2></p>
</blockquote>
<pre><code>data: function() {
return {
    title: null,
    name: null,
    content: '就是我'
    };
},

const comp1 = this.$refs.comp1;
this.title = comp1.title;
this.$children[1].title
</code></pre>
<pre><code class="language-html">// 父组件
&lt;template&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;p&gt;我的title：{{title}}&lt;/p&gt;
&lt;p&gt;我的name：{{name}}&lt;/p&gt;
&lt;child1 ref=&quot;comp1&quot;&gt;&lt;/child1&gt;
&lt;child2 ref=&quot;comp2&quot;&gt;&lt;/child2&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Child1 from './component/child1.vue';
import Child2 from './component/child2.vue';
export default {
name: 'demo',
data: function() {
return {
title: null,
name: null,
content: '就是我'
};
},
components: {
Child1,
Child2
},
mounted() {
const comp1 = this.$refs.comp1;
this.title = comp1.title;
comp1.sayHello();
this.name = this.$children[1].title;
},
};
&lt;/script&gt;
</code></pre>
<blockquote>
<p>// 子组件1-ref方式<br>
// 子组件1-ref方式<br>
this.$parent.content</p>
</blockquote>
<pre><code class="language-html">// 子组件1-ref方式
&lt;template&gt;
&lt;div&gt;
&lt;div class=&quot;center&quot;&gt;我的父组件是谁:{{content}}&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
name: 'demo1',
data() {
return {
title: '我是子组件',
content: null
};
},
mounted() {
this.content = this.$parent.content;
},
methods: {
sayHello() {
window.alert('Hello');
}
}
};
&lt;/script&gt;
</code></pre>
<p>// 子组件2-children方式</p>
<pre><code class="language-html">// 子组件2-children方式
&lt;template&gt;
&lt;div&gt;
&lt;div class=&quot;center&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default{
name: 'demo1',
data() {
return {
title: '我是子组件2'
};
},
};
&lt;/script&gt;
</code></pre>
<p>通过例子可以看到这两种方式都可以父子间通信，而缺点也很统一，就是都不能跨级以及兄弟间通信。<br>
小总结：父子组件间共享数据以及方法的便捷实践之一。<br>
👉如果子组件是公共组件，会被多个父组件调用，那么$parent会怎么获取？<br>
👉改变他们的属性将会怎么变化？<br>
👉父组件中没有这个属性怎么办？</p>
<pre><code>1. 针对不同父组件调用，子组件会每次都会生成一个实例，这也是Vue的重要机制。$parent会获取每个调用它的父组件实例。
2. 子组件中通过$parent会改变每个调用它的父组件中的对应属性。
</code></pre>
<!-- more -->
<h1 id="总结">总结</h1>
<p>组件间不同的使用场景可以分为 3 类，对应的通信方式如下：</p>
<p>• 父子通信：Props / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">emit，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">，</span></span></span></span>emit / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>n</mi><mi mathvariant="normal">即</mi><mi>B</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">，</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">on即Bus事件总线方式，Vuex，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">即</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">，</span></span></span></span>attrs / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>r</mi><mi>s</mi><mi mathvariant="normal">，</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">listeners，provide/inject，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">，</span></span></span></span>parent / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>c</mi><mi>h</mi><mi>i</mi><mi>l</mi><mi>d</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi mathvariant="normal">＆</mi></mrow><annotation encoding="application/x-tex">children＆</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">＆</span></span></span></span>refs</p>
<p>• 兄弟通信：$emit / $on即Bus事件总线方式，Vuex</p>
<p>• 隔代（跨级）通信：$emit / <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>o</mi><mi>n</mi><mi mathvariant="normal">即</mi><mi>B</mi><mi>u</mi><mi>s</mi><mi mathvariant="normal">事</mi><mi mathvariant="normal">件</mi><mi mathvariant="normal">总</mi><mi mathvariant="normal">线</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">式</mi><mi mathvariant="normal">，</mi><mi>V</mi><mi>u</mi><mi>e</mi><mi>x</mi><mi mathvariant="normal">，</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>v</mi><mi>i</mi><mi>d</mi><mi>e</mi><mi mathvariant="normal">/</mi><mi>i</mi><mi>n</mi><mi>j</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi mathvariant="normal">，</mi></mrow><annotation encoding="application/x-tex">on即Bus事件总线方式，Vuex，provide / inject，</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">即</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">事</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">总</span><span class="mord cjk_fallback">线</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">式</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">，</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord">/</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord cjk_fallback">，</span></span></span></span>attrs / $listeners</p>
<!-- more -->
<h1 id="七-消息订阅与发布-任意组件间的信息传递">七、消息订阅与发布        任意组件间的信息传递</h1>
<p>详情见相关文章<br>
安装pubsub-js</p>
<pre><code class="language-cmd"> npm install pubsub-js --save
</code></pre>
<p>优点：<code>可以进行任意组件间的信息传递。</code></p>
<p>1、发布消息</p>
<pre><code class="language-js">    PubSub.publish('msg', data)
</code></pre>
<p>下面的例子中，msg为‘type’ , data为communicateType<br>
<img src="https://cutezhangq.github.io/post-images/1596769897505.png" alt="" loading="lazy"></p>
<p>2、订阅消息</p>
<pre><code class="language-js">    PubSub.subscribe('msg', function(msg, data){})
</code></pre>
<p>第一个msg为‘type’ （必须与发布消息中的msg一样才能实现通信）,第二个msg就是与第一个msg一样，第二个msg必须得有（语法规定的）<br>
<img src="https://cutezhangq.github.io/post-images/1596769944793.png" alt="" loading="lazy"></p>
<!-- more -->
<h1 id="八-slot">八、slot</h1>
<p>详情见相关文章</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ new运算符的执行过程]]></title>
        <id>https://cutezhangq.github.io/post/new-yun-suan-fu-de-zhi-xing-guo-cheng/</id>
        <link href="https://cutezhangq.github.io/post/new-yun-suan-fu-de-zhi-xing-guo-cheng/">
        </link>
        <updated>2020-08-06T12:45:01.000Z</updated>
        <content type="html"><![CDATA[<p>new运算符的执行过程<br>
* 创建一个空对象obj<br>
* 并将这个空对象obj的__proto__连接到构造函数的原型上。链接到原型: obj.<strong>proto</strong> = Con.prototype<br>
* 绑定this:  apply，创建属性和方法。  用apply绑定对象的this指向（obj作为this的上下文）Con.apply(obj,arguments)<br>
* 返回新对象this或者叫创建的对象obj(如果构造函数有自己 retrun 时，则返回该值)</p>
<pre><code class="language-js">  // 传参 New(obj, ...args)
  function New123() {  
      let obj = new Object();  // 提取第一个参数并作为构造函数; 
      let construction = [].shift.call(arguments);  // 新对象的__prop__要链接到原型链  
      obj.__proto__ = construction.prototype;  // 改变this指向    
      construction.apply(obj, arguments);   //obj作为this的上下文
      return obj;   // 返回新对象 
}
</code></pre>
<p>下面对自定义的New方法进行验证：</p>
<pre><code class="language-js">function People(name,age){
  this.name = name;
  this.age = age;
}
People.prototype.say = function () {
  console.log(`My name is ${this.name}.`);
}
//通过new创建构造实例
let people1 = new People('Jack',20);
console.log(people1.name)  // Jack
console.log(people1.say()) // My name is Jack.
 
//通过New方法创造实例
let people2 = New123(People,'Rose',18);
console.log(people2.name)  //Rose
console.log(people2.say())  //My name is Rose.
</code></pre>
<p>过输出结果可以看出来，我们自己定义的New方法，是可以实现跟new运算符同等作用的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON.stringify与"环"问题]]></title>
        <id>https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/</id>
        <link href="https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/">
        </link>
        <updated>2020-08-06T10:50:32.000Z</updated>
        <content type="html"><![CDATA[<p>JSON.stringify的功能是，讲一个js字面量对象转化为一个JSON格式的字符串，例如：</p>
<pre><code class="language-js">const obj = {a:1,b:2}
JSON.stringify(obj)     //  ‘ {“a”:1,“b”:2}’
</code></pre>
<p>当要转化的对象有**“环”**存在时（<strong>子节点属性赋值了父节点的引用</strong>），为了避免死循环，JSON.stringify 会抛出异常，例如：</p>
<pre><code class="language-js">const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
JSON.stringify(obj) // =&gt; TypeError: Converting circular structure to JSON 类型错误:将循环结构转换为JSON
</code></pre>
<p>请完善以下“环”检查器函数 cycleDetector，当入参对象中有环时返回 true，否则返回 false。</p>
<pre><code class="language-js">function cycleDetector(obj) {   
  // 请添加代码
}
</code></pre>
<p>“环”的形成是因为对象的子节点属性赋值了父节点的引用，所以我们需要记录下父节点的地址，然后再拿其子节点的属性与之前记录下的父节点地址做一个比较，当结果一致时，就形成了“环”。</p>
<p>那么，在“环”检测器函数中，我们首先需要遍历这个对象的属性，前面提到了引用，那么我们只需对Object类型的属性进行处理即可（简单数据类型不存在引用关系）。对于Objcet类型的属性，我们先与记录下来的父节点地址做一个对比，如无匹配项，将当前属性地址记录下来，然后遍历其子节点属性，一层一层找下去。下面开始上代码：</p>
<pre><code class="language-js">function cycleDetector(obj){
    var hasCircle = false,  //  定义一个变量，标志是否有环
    cache = [];          //  定义一个数组，来保存对象类型的属性值
    (function(obj){
        var keys = Object.keys(obj);    //获取当前对象的属性数组——key是获取属性
             for (var i = 0; i &lt; keys.length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (typeof value == 'object' &amp;&amp; value !== null) {
                var index = cache.indexOf(value)
                if (index !== -1) {
                    hasCircle = true
                    break
                } else {
                    cache.push(value)
                    arguments.callee(value)
                    cache.pop()      //  注意：这里要推出数据，因为递归返回，后面遍历的属性不是这个数据的子属性
                }
            }
        }
    })(obj)
}

</code></pre>
<p>补充：<br>
<strong>Object.keys</strong> 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。<br>
<strong>测试用例</strong></p>
<pre><code class="language-js">/* 测试一 */

const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
</code></pre>
<pre><code class="language-js">/* 测试二 */

var obj = {
    foo: {
        name: 'foo',
        bar: {
            name: 'bar',
            baz: {
                name: 'baz',
                aChild: null
            }
        }
    },
    aaa: {
        name: &quot;test&quot;,
        bbb: null
    }
}
obj.aaa.bbb = obj.foo;   //  aaa-&gt;bbb-&gt;bar-&gt;baz-&gt;aChild-&gt;null 不形成环
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vuex中mutations和actions的区别]]></title>
        <id>https://cutezhangq.github.io/post/vuex-zhong-mutations-he-actions-de-qu-bie/</id>
        <link href="https://cutezhangq.github.io/post/vuex-zhong-mutations-he-actions-de-qu-bie/">
        </link>
        <updated>2020-08-06T01:55:07.000Z</updated>
        <content type="html"><![CDATA[<p><strong>Vuex</strong> 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p>
<p>Mutation 更改 Vuex 的 store 中的状态的<strong>唯一</strong>方法是提交 mutation。事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。</p>
<ul>
<li>
<p>Action <strong>提交的是 mutation</strong>，而不是直接变更状态。最后<strong>是mutation去修改store里的state</strong></p>
</li>
<li>
<p>Action 可以包含任意<strong>异步</strong>操作。</p>
</li>
<li>
<p><strong>mutation只能进行同步操作</strong>。为什么？请参考下面的例子：</p>
</li>
</ul>
<pre><code class="language-js">mutations: {
 someMutation (state) {
   api.callAsyncMethod(() =&gt; {
     state.count++
   })
 }
}
</code></pre>
<p>现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。<br>然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，<br>devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的。</p>
<p>mutation的触发通过store.commit来进行</p>
<p>action的触发通过store.dispatch进行</p>
<h1 id="安装">安装</h1>
<blockquote>
<p>npm install vuex --save</p>
</blockquote>
<h1 id="用法一">用法一</h1>
<pre><code class="language-js">
/**
 * 创建完文件后需要去到main.js中引入成全局
 */
import Vue from &quot;vue&quot;;
import Vuex from &quot;vuex&quot;;
//使用vuex
Vue.use(Vuex);
const state = {
  targetUser: {} //用户详细资料数据
};
 
const getters = {
  //获取到用户状态,//实时监听state值的变化(最新状态)
  targetUser: state =&gt; state.targetUser
};
 
const mutations = {
  //自定义改变state初始值的方法
  SET_TARGET_USER(state, targetUser) {
    if (targetUser) {
      state.targetUser = targetUser; //如果targetUser有内容就赋给状态信息
    } else {
      //如果没内容就给targetUser赋空对象
      state.targetUser = {};
    }
  }
};
 
const actions = {
  //这里面的方法是用来异步触发mutations里面的方法,context与store 实例具有相同方法和属性
  // 页面定义的setGargetUser,targetUser为页面传过来的值
  setGargetUser({ commit }, targetUser) {
    commit(&quot;SET_TARGET_USER&quot;, targetUser);
  }
};
</code></pre>
<p>存储页面:</p>
<pre><code class="language-js">
this.$store.dispatch('setGargetUser',friend)
</code></pre>
<p>获取页面:</p>
<pre><code class="language-js"> computed:{
        //  提示vuex中存入的用户详细资料
        targetUser(){
            return this.$store.getters.targetUser
        }
     },
</code></pre>
<p>以上方法有一个问题就是如果多人开发;会出现不利于管理,下面用一个方法定义一个常量<br>
存储:</p>
<pre><code class="language-js">  this.$store.dispatch('setUser',decode)
</code></pre>
<p>store.js</p>
<pre><code class="language-js">
/**
 * 创建完文件后需要去到main.js中引入成全局
 */
import Vue from &quot;vue&quot;;
import Vuex from &quot;vuex&quot;;
// 持久存储插件
import createPersistedState from &quot;vuex-persistedstate&quot;;
 
//使用vuex
Vue.use(Vuex);
 
/**
 * 在需要多人协作的项目中，我们可以使用常量代替mutation 事件类型。这在各种 Flux 实现中是很常见的模式。同时把这些常量放在单独的文件中可以让协作开发变得清晰。
 *  定义存储信息
 *
 *    */
 
const types = {
  SET_TARGET_USER: &quot;SET_TARGET_USER&quot; //详细资料
};
 
const state = {
  //用户初始化的状态
  targetUser: {} //用户详细资料数据
};
const getters = {
  //获取到用户状态,//实时监听state值的变化(最新状态)
  targetUser: state =&gt; state.targetUser
};
const mutations = {
  //自定义改变state初始值的方法
 
  [types.SET_TARGET_USER](state, targetUser) {
    if (targetUser) {
      state.targetUser = targetUser; //如果targetUser有内容就赋给状态信息
    } else {
      //如果没内容就给targetUser赋空对象
      state.targetUser = {};
    }
  }
};
 
const actions = {
  //这里面的方法是用来异步触发mutations里面的方法,context与store 实例具有相同方法和属性
  setGargetUser({ commit }, targetUser) {
    commit(types.SET_TARGET_USER, targetUser);
    // localStorage.setItem(&quot;SET_TARGET_USER&quot;, JSON.stringify(targetUser));
  }
};
export default new Vuex.Store({
  state,
  mutations,
  getters,
  actions,
});

</code></pre>
<p>取值:</p>
<pre><code class="language-js">this.$store.getters.targetUser
</code></pre>
<p>想要获取对应的状态你就可以直接使用this.$store.state获取，当然，也可以利用vuex提供的mapState辅助函数将state映射到计算属性中去，如.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mpvue性能优化技巧]]></title>
        <id>https://cutezhangq.github.io/post/mpvue-xing-neng-you-hua-ji-qiao/</id>
        <link href="https://cutezhangq.github.io/post/mpvue-xing-neng-you-hua-ji-qiao/">
        </link>
        <updated>2020-08-05T15:42:43.000Z</updated>
        <content type="html"><![CDATA[<p>优化前后的图：<br>
<img src="https://cutezhangq.github.io/post-images/1596642240799.webp" alt="" loading="lazy"></p>
<p>可以看到打包后的代码量从813KB减少到387KB,Audits体验评分从B到A，效果还是比较明显的。其实这个指标说明不了什么，而且轻易就可以做到，更重要的是优化小程序运行过程中的卡顿感，请耐心往下看。</p>
<p>常规优化<br>
常规的Web端优化方法在小程序中也是适用的，而且不可忽视。</p>
<h1 id="一-压缩图片">一、压缩图片</h1>
<p>这一步最简单，但是容易被忽视。在tiny上在线压缩，然后下载替换即可。</p>
<h1 id="二-移除无用的库">二、移除无用的库</h1>
<p>在项目中使用了Vant Weapp，在static目录下引入了整个库，但实际上我只使用了button,field,dialog等几个组件，实在是没必要。</p>
<p>所以干脆移除掉了，微信小程序自身提供的button，wx.showModal等一些组件基本可以满足需求，自己手写一下样式也不用花什么时间。<br>
在微信小程序中，<strong>尽量避免使用过多的依赖库</strong>。</p>
<h1 id="小程序的优化">小程序的优化</h1>
<h1 id="一-开启vueconfig_mptrace-true">一、开启Vue.config._mpTrace = true</h1>
<p>首先得看一下<a href="https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html">官方优化</a>建议，大多是围绕这个建议去做。</p>
<blockquote>
<p>这个是mpvue性能优化的一个黑科技<br>
具体做法是在<code>/src/main.js</code>添加<code>Vue.config._mpTrace = true</code>，如：</p>
</blockquote>
<pre><code class="language-js">Vue.config._mpTrace = true
Vue.config.productionTip = false
App.mpType = 'app'
</code></pre>
<p>添加了<code>Vue.config._mpTrace</code>属性，这样就可以看到console里会打印每500ms更新的数据量。如图：<br>
<img src="https://cutezhangq.github.io/post-images/1596676060778.webp" alt="" loading="lazy"></p>
<p>**如果数据更新量很大，会明显感觉小程序运行卡顿，反之就流畅。**因此我们可以根据这个指标，逐步找出性能瓶颈并解决掉。</p>
<h1 id="二-精简data">二、精简data</h1>
<h3 id="1-过滤api返回的冗余数据">1. 过滤api返回的冗余数据</h3>
<p>后端的api可能是需要同时为iOS，Android，H5等提供服务的，往往会有些冗余的数据小程序是用不到的。比如api返回的一个<code>文章列表</code>数据有很多字段：</p>
<pre><code class="language-js">this.articleList = [
    {
        articleId: 1,
        desc: 'xxxxxx',
        author: 'fengxianqi',
        time: 'xxx',
        comments: [
            {
                userId: 2,
                conent: 'xxx'
            }
        ]
    },
    {
        articleId: 2
        // ...
    },
    // ...
]
</code></pre>
<p>假设我们在小程序中只需要用到列表中的部分字段，如果不对数据做处理，将整个articleList都setData进去，是不明智的。</p>
<blockquote>
<p>小程序官方文档： 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。</p>
</blockquote>
<p>可以看出，内存是很宝贵的，当articleList数据量非常大超过1M时，某些机型就会爆掉(在iOS可能遇到过很多次）</p>
<p>因此，需要将接口返回的数据剔除掉不需要的，再setData，回到我们上面的articleList例子，假设我们只需要用articleId和author这两个字段，可以这样：</p>
<pre><code class="language-js">import { getArticleList } from '@/api/article'
export default {
    data () {
        return {
            articleList: []
        }
    }
    methods: {
        getList () {
            getArticleList().then(res =&gt; {
                let rawList = res.list
                this.articleList = this.simplifyArticleList(rawList)
            })
        },
        simplifyArticleList (list) {
            return list.map(item =&gt; {
                return {
                    articleId: item.articleId,
                    author: item.author
                    // 需要哪些字段就加上哪些字段
                }
            })
        }
    }
}
</code></pre>
<p>这里我们将返回的数据通过simplifyArticleList来精简数据，此时过滤后的articleList中的数据类似：</p>
<pre><code class="language-json">[
    {articleId: 1, author: 'fengxianqi'},
    {articleId: 2, author: 'others'}
    // ...
]
</code></pre>
<p>当然，如果你的需求中是所有数据都要用到（或者大部分数据），就没必要做一层精简了，收益不大。毕竟精简数据的函数中具体的字段，是会增加维护成本的。</p>
<blockquote>
<p>PS： 有时，做数据过滤虽然增加了维护的成本，但一般收益都很大，因次这个方法比较推荐。</p>
</blockquote>
<h3 id="2-data中只放需要的数据">2. data()中只放需要的数据</h3>
<pre><code class="language-js">import xx from 'xx.js'
export default {
    data () {
        return {
            xx,
            otherXX: '2'
        }
    }
}
</code></pre>
<p>有些同学可能会习惯将import的东西都先放进data中，再在methods中使用，在小程序中可能是个不好的习惯。</p>
<p>因为通过Vue.config._mpTrace = true在更新某个数据时，我对比放进data和不放进data中的两种情况会有差别。</p>
<p>所以猜测可能是data是会一起更新的，比如只是想更新otherXX时，会同时将xx也一起合起来setData了。</p>
<h3 id="静态图片放进static">静态图片放进static</h3>
<p>这个问题和上面的问题其实是一样的，有时候我们会通过import的方式引入，比如这样：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;img :src=&quot;UserIcon&quot;&gt;
&lt;/template&gt;
&lt;script&gt;
import UserIcon from '@/assets/images/user_icon.png'
export default {
    data () {
        return {
            UserIcon
        }
    }
}
&lt;/script&gt;
</code></pre>
<p>这样会导致打包后的代码，图片是base64形式（很长的一段字符串）存放在data中，不利于精简data。同时当该组件多个地方使用时，每个组件实例都会携带这一段很长的base64代码，进一步导致数据的冗余。</p>
<p>因此，建议将静态图片放到static目录下，这样引用：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;img src=&quot;/static/images/user_icon.png&quot;&gt;
&lt;/template&gt;

</code></pre>
<p>代码也更简洁清爽。</p>
<p>看一下做了上面操作的前后对比图，使用体验上也流畅了很多。</p>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596676687989.webp" alt="" loading="lazy"></figure>
<h1 id="三-swiper优化">三、swiper优化</h1>
<p>小程序自身提供的<code>swiper</code>组件性能上不是很好，使用时要注意。参考着两个思路：</p>
<ul>
<li><a href="https://developers.weixin.qq.com/community/develop/doc/000068ff25ccf0bae4e76eab156c04">【优化】解决swiper渲染很多图片时的卡顿</a></li>
</ul>
<p>在我使用时，由于需求原因，动态删掉swiper-item的思路不可行（手滑时会造成抖动）。因此只能作罢。但仍然可以优化一下：</p>
<ul>
<li>将未显示的<code>swiper-item</code>中的图片用<code>v-if隐藏到</code>，当判断到current时才显示，防止大量图片的渲染导致的性能问题。</li>
</ul>
<h1 id="四-vuex使用注意事项">四、vuex使用注意事项</h1>
<p>一篇<a href="https://juejin.im/post/6844903793964875784#heading-8">mpvue开发音频类小程序踩坑和建议</a>里面有讲如何在小程序中使用vuex。但遇到了个比较严重的性能问题。</p>
<h3 id="1-问题描述">1. 问题描述</h3>
<p>我开发的是一个音频类的小程序，所以需要将播放列表playList,当前索引currentIndex和当前时长currentTime放进state.js中：</p>
<pre><code class="language-js">const state = {
  currentIndex: 0, // playList当前索引
  currentTime: 0, // 当前播放的进度
  playList: [], // {title: '', url: '', singer: ''}
}
</code></pre>
<p>每次用户点击播放音频时，都会先加载音频的播放列表playList,然后播放时更新当前时长currentTime，发现有时候播音频时整个小程序非常卡顿。</p>
<blockquote>
<p>注意到，音频需每秒就得更新一次currentTime,即每秒就做一次setData操作，稍微有些卡顿是可以理解的。但我发现是播放列表数据比较多时会特别卡，比如playList的长度是100条以上时。</p>
</blockquote>
<h3 id="2-问题原因">2. 问题原因</h3>
<p>开启Vue.config._mpTrace = true后发现一个规律：</p>
<p>当palyList数据量小时，console显示造成的数据量更新数值比较小；当playList比较大时，console显示造成的数据量更新数值比较大。(尝试将playList数据量增加到200条，每500ms的数据量更新达到800KB左右。)<br>
到这里基本可以确定一个事实就是：**更新state中的任何一个字段，将导致整个state全量一起setData。**在我这里的例子，虽然我每次只是更新currentTime这个字段的值，但依然导致将state中的其他字段如playList,currentIndex都一起做了一次setData操作。</p>
<h3 id="3-解决问题">3. 解决问题</h3>
<p>有两个思路：</p>
<ul>
<li>精简state中保存的数据，即限制playList的数据不能太多，可将一些数据暂存在storage中</li>
<li>vuex采用Module的写法能改善这个问题，虽然使用时命名空间造成一定的麻烦。</li>
</ul>
<p>一般情况下，推荐使用后者。我在项目中尝试使用了前者，同样能达到很好的效果，请继续看下面的分享。</p>
<h1 id="五-善用storage">五、善用storage</h1>
<h2 id="1为什么说要善用storage">1.为什么说要善用storage</h2>
<p>由于小程序的内存非常宝贵，占用内存过大会非常卡顿，因此最好尽可能少的将数据放到内存中，即vuex存的数据要尽可能少。而小程序的storage支持单个 key允许存储的最大数据长度为 1MB，所有数据存储上限为 10MB。<br>
所以可以将一些相对取用不频繁的数据放进storage中，需要时再将这些数据放进内存，从而缓解内存的紧张，有点类似Windows中虚拟内存的概念。</p>
<h2 id="2storage换内存的实例">2.storage换内存的实例</h2>
<p>上面讲到playList数据量太多，播放一条音频时其实只需要最多保证3条数据在内存中即可，即上一首，播放中的，下一首,我们可以将多余的播放列表存放在storage中。</p>
<blockquote>
<p>PS: 为了保证更平滑地连续切换下一首，我们可以稍微保存多几条，比如我这里选择保存5条数据在vuex中，播放时始终保证当前播放的音频前后都有两条数据。</p>
</blockquote>
<pre><code class="language-js">// 首次播放背景音频的方法
async function playAudio (audioId) {
    // 拿到播放列表，此时的playList最多只有5条数据。getPlayList方法看下面
    const playList = await getPlayList(audioId)
    // 当前音频在vuex中的currentIndex
    const currentIndex = playList.findIndex(item =&gt; item.audioId === audioId)
    
    // 播放背景音频
    this.audio = wx.getBackgroundAudioManager()
    this.audio.title = playList[currentIndex].title
    this.audio.src = playList[currentIndex].url
    
    // 通过mapActions将播放列表和currentIndex更新到vuex中
    this.updateCurrentIndex(index) 
    this.updatePlayList(playList) 
    // updateCurrentIndex和updatePlayList是vuex写好的方法
}

// 播放音频时获取播放列表的方法，将所有数据存在storage，然后返回当前音频的前后2条数据，保证最多5条数据
import { loadPlayList } from '@/api/audio'
async function getPlayList (courseId, currentAudioId) {
    // 从api中请求得到播放列表
    // loadPlayList是api的方法, courseId是获取列表的参数,表示当前课程下的播放列表
    let rawList = await loadPlayList(courseId)
    // simplifyPlayList过滤掉一些字段
    const list = this.simplifyPlayList(rawList)
    // 将列表存到storage中
    wx.setStorage({
        key: 'playList',
        data: list
    })
    return subPlayList(list, currentAudioId)
}
</code></pre>
<p>重点是subPlayList方法，这个方法保证了拿到的播放列表是<strong>最多5条数据</strong>。</p>
<pre><code class="language-js">function subPlayList(playList, currentAudioId) {
  let tempArr = [...playList]
  const count = 5 // 保持vuex中最多5条数据
  const middle = parseInt(count / 2) // 中点的索引
  const len = tempArr.length
  // 如果整个原始的播放列表本来就少于5条数据，说明不需要裁剪，直接返回
  if (len &lt;= count) {
    return tempArr
  }
  // 找到当前要播放的音频的所在位置
  const index = tempArr.findIndex(item =&gt; item.audioId === currentAudioId)
  // 截取当前音频的前后两条数据
  tempArr = tempArr.splice(Math.max(0, Math.min(len - count, index - middle)), count)
  return tempArr
}
</code></pre>
<p>tempArr.splice(Math.max(0, index - middle), count)可能有些同学比较难理解，需要仔细琢磨一下。假设playList有10条数据：<br>
当前音频是列表中的第1条（索引是0）,截取前5个：playList.splice(0, 5)，此时currentAudio在这5个数据的索引是0,没有上一首，有4个下一首<br>
当前音频是列表中的第2条（索引是1）,截取前5个：playList.splice(0, 5)，此时currentAudio在这5个数据的索引是1，有1个上一首，3个下一首<br>
当前音频是列表中的第3条（索引是2）,截取前5个：playList.splice(0, 5)，此时currentAudio在这5个数据的索引是2，有2个上一首，2个下一首<br>
当前音频是列表中的第4条（索引是3）,截取第1到6个：playList.splice(1, 5)<br>
，此时currentAudio在这5个数据的索引是2，有2个上一首，2个下一首<br>
当前音频是列表中的第5条（索引是4），截取第2到7个：playList.splice(2, 5)，此时currentAudio在这5个数据的索引是2，有2个上一首，2个下一首<br>
...<br>
当前音频是列表中的第9条（索引是8），截取后5个：playList.splice(4, 5)，此时currentAudio在这5个数据的索引是3，有3个上一首，1个下一首<br>
当前音频是列表中的最后1条（索引是9），截取后的5个：playList.splice(4, 5)，此时currentAudio在这5个数据的索引是4，有4个上一首，没有下一首</p>
<p>无论当前音频在哪，都始终保证了拿到当前音频前后的最多5条数据。<br>
接下来就是维护播放上一首或下一首时保证当前vuex中的playList始终是包含当前音频的前后2条。<br>
<strong>播放下一首</strong></p>
<pre><code class="language-js">function playNextAudio() {
    const nextIndex = this.currentIndex + 1
    if (nextIndex &lt; this.playList.length) {
        // 没有超出数组长度，说明在vuex的列表中，可以直接播放
        this.audio = wx.getBackgroundAudioManager()
        this.audio.src = this.playList[nextIndex].url
        this.audio.title = this.playList[nextIndex].title
        this.updateCurrentIndex(nextIndex)
        // 当判断到已经到vuex的playList的边界了，重新从storage中拿数据补充到playList
        if (nextIndex === this.playList.length - 1 || nextIndex === 0) {
          // 拿到只有当前音频前后最多5条数据的列表
          const newList = getPlayList(this.playList[nextIndex].courseId, this.playList[nextIndex].audioId)
          // 当前音频在这5条数据中的索引
          const index = newList.findIndex(item =&gt; item.audioId === this.playList[nextIndex].audioId)
          // 更新到vuex
          this.updateCurrentIndex(index)
          this.updatePlayList(newList)
        }
    }
}
</code></pre>
<p>这里的getPlayList方法是上面讲过的，本来是从api中直接获取的，为了避免每次都从api直接获取，所以需要改一下，先读storage，若无则从api获取：</p>
<pre><code class="language-js">import { loadPlayList } from '@/api/audio'
async function getPlayList (courseId, currentAudioId) {
    // 先从缓存列表中拿
    const playList = wx.getStorageSync('playList')
    if (playList &amp;&amp; playList.length &gt; 0 &amp;&amp; courseId === playList[0].courseId) {
      // 命中缓存，则从直接返回
      return subPlayList(playList, currentAudioId)
    } else {
      // 没有命中缓存，则从api中获取
      const list = await loadPlayList(courseId)
      wx.setStorage({
        key: 'playList',
        data: list
      })
      return subPlayList(list, currentAudioId)
    }
}
</code></pre>
<p>播放上一首也是同理，就不赘述了。</p>
<blockquote>
<p>将vuex中的数据精简后，小程序在播放音频时刷其他页面已经非常流畅啦，效果非常好。</p>
</blockquote>
<h1 id="六-动画优化">六、动画优化</h1>
<p>这个问题在mpvue开发音频类小程序踩坑和建议已经讲过了，感兴趣的可以移步看一眼，这里只写下概述:</p>
<ul>
<li>如果要使用动画，尽量用css动画代替wx.createAnimation</li>
<li>使用css动画时建议开启硬件加速</li>
</ul>
<h1 id="最后">最后</h1>
<p>大致总结一下上面所讲的几个要点：</p>
<ul>
<li>开发时打开Vue.config._mpTrace = true。</li>
<li>谨慎引入第三方库，权衡收益。</li>
<li>添加数据到data中时要克制，能精简尽量精简。</li>
<li>图片记得要压缩，图片在显示时才渲染。</li>
<li>vuex保持数据精简，必要时可先存storage。</li>
</ul>
]]></content>
    </entry>
</feed>