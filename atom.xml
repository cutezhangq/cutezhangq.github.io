<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-09-07T13:04:36.414Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[笔试-题目整理3-2019百度校招 ]]></title>
        <id>https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-3-2019-bai-du-xiao-zhao/</id>
        <link href="https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-3-2019-bai-du-xiao-zhao/">
        </link>
        <updated>2020-09-03T01:32:52.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录了部分百度 2019的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录了部分百度 2019的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
<!-- more -->
<h1 id="1-tcp和udp说法错误的是">1、TCP和UDP说法错误的是（）</h1>
<h2 id="答案udp是面向字节流的协议">答案：UDP是面向字节流的协议</h2>
<p>其他说法是正确的：</p>
<ul>
<li>TCP的头部消息较UDP来说更全面</li>
<li>TCP是端对端的不支持广播、多播</li>
<li>TCP可以用在远程登陆方面，UDP可以用在语音通话方面</li>
</ul>
<h2 id="解析">解析：</h2>
<p>tcp才是面向字节流的协议，UDP 为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。Internet 的传输层有两个主要协议，互为补充。<code>无连接的是 UDP，它除了给应用程序发送数据包功能并允许它们在所需的层次上架构自己的协议之外，几乎没有做什么特别的事情。面向连接的是 TCP，该协议几乎做了所有的事情。</code></p>
<h1 id="2-下面关于进程三态模型说法错误的是">2、下面关于进程三态模型说法错误的是（）</h1>
<h2 id="答案阻塞状态可以直接转换为执行状态">答案：阻塞状态可以直接转换为执行状态</h2>
<p>其他说法是正确的：</p>
<ul>
<li>就绪状态和执行状态可以互相转换</li>
<li>就绪状态转换为执行状态进行了进程调度</li>
<li>阻塞状态可以直接转换为就绪状态</li>
</ul>
<p><code>就绪→执行(调度发生)，执行→就绪(中断) 执行→阻塞(发生等待) 阻塞→就绪</code></p>
<h1 id="3-http是hyper-text-transfer-protocol超文本传输协议的缩写-以下那个不是http协议的请求方法">3、HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。以下那个不是HTTP协议的请求方法（）。</h1>
<h2 id="分析">分析：</h2>
<p>可以通过 <code>GET、 POST、 PUT、 PATCH、 DELETE</code>等方式对服务端的资源进行操作。其中，GET 用于查询资源，POST 用于创建资源，PUT 用于更新服务端的资源的全部信息，PATCH 用于更新服务端的资源的部分信息，DELETE 用于删除服务端的资源。</p>
<h1 id="4-序列912173050206065419构造为堆后堆所对应的的中序遍历序列可能为">4、序列{9,12,17,30,50,20,60,65,4,19}构造为堆后，堆所对应的的中序遍历序列可能为（）</h1>
<h2 id="答案651230950194201760">答案：65,12,30,9,50,19,4,20,17,60</h2>
<p>先将序列构造成堆（最大堆或最小堆），根据堆的特点可知，这是一个完全二叉树，再中序遍历这个完全二叉树</p>
<h3 id="堆大顶堆小顶堆中序遍历前序遍历后续遍历序列">堆（大顶堆，小顶堆），中序遍历，前序遍历，后续遍历序列</h3>
<p><strong>堆的概念：</strong></p>
<ul>
<li>堆中某个节点的值总是不大于或不小于其父节点的值；</li>
<li>堆总是一棵完全二叉树。</li>
</ul>
<h5 id="一-序列构造成堆">一、序列构造成堆：</h5>
<p><strong>堆构造原则：</strong> 先固定已稳定的堆，再 安照从上到下，从左到右的原则堆积。<br>
<strong>小顶堆原理：</strong> 每个结点的值都小于其左孩子和右孩子结点的值</p>
<p><img src="https://cutezhangq.github.io/post-images/1599103887418.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1599113363569.png" alt="" loading="lazy"></p>
<p>大顶堆</p>
<p>原理与小顶堆相似：每个结点的值都大于其左孩子和右孩子结点的值</p>
<h5 id="二-堆所对应的的中序遍历序列">二、堆所对应的的中序遍历序列</h5>
<p>中序遍历：<code>左中右</code>     对构造成功的 小顶堆<br>
<img src="https://cutezhangq.github.io/post-images/1599115030579.png" alt="" loading="lazy"></p>
<h2 id="二叉树遍历先序-中序-后序">二叉树遍历(先序、中序、后序)</h2>
<p>先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。<code>(根左右)</code></p>
<p>中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。<code>(左根右)</code></p>
<p>后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。<code>(左右根)</code></p>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1599115339852.png" alt="" loading="lazy"></figure>
<p>如图1所示，三种遍历方法(人工)得到的结果分别是：(x序中的x决定的是<code>根</code>的位置)</p>
<ul>
<li>先序：1 2 4 6 7 8 3 5</li>
<li>中序：4 7 6 8 2 1 3 5</li>
<li>后序：7 8 6 4 2 5 3 1</li>
</ul>
<h1 id="5-下面程序的时间复杂度为多少">5、下面程序的时间复杂度为多少</h1>
<pre><code class="language-js">int i,j,a;
for(i=1;i&lt;n.i++)
{
   for(j=1;j&lt;n;j*=2)
   {
       a = i+j;
       cout&lt;&lt;a&lt;&lt;endl;
    }
}
</code></pre>
<h2 id="答案onlog2n">答案：O(n*log2(n))</h2>
<h1 id="6-数据结构中如果存在二维数组qq的行下标取值为2-5q的列下标取值为1-8对于q中的元素用相邻的6个字节存储存储器按字节编址数组q的字节为">6、数据结构中，如果存在二维数组Q，Q的行下标取值为2-5，Q的列下标取值为1-8，对于Q中的元素用相邻的6个字节存储，存储器按字节编址，数组Q的字节为（）</h1>
<h2 id="答案204">答案：204</h2>
<h1 id="7-前缀表达式ab-cdefgh的中缀表达式是">7、前缀表达式+^A*B-CD/E/F+GH的中缀表达式是（）。</h1>
<h2 id="答案abc-defgh">答案：A^(B*(C-D))+(E⁄F)⁄((G+H))</h2>
<p>可用栈实现。若为字母就入栈；若为运算符就将栈顶两个字母弹出，加上运算符计算后再将得到的代数表达式入栈，依次进行，最后栈中留下中缀表达式形式。</p>
<h1 id="8-嵌入多媒体文本的html的写法正确的是">8、嵌入多媒体文本的HTML的写法正确的是()</h1>
<h2 id="答案">答案：</h2>
<p><code>&lt;embed src=”#”&gt;&lt;/embed&gt;</code></p>
<p>src: 一般是把资源嵌入到文本里<br>
href： 一般是与某个资源建立连接<br>
<code>&lt;embed&gt;</code>标签定义嵌入的内容，比如插件。</p>
<pre><code class="language-html">&lt;embed src=&quot;/i/helloworld.swf&quot; /&gt;
</code></pre>
<h1 id="9-ahtml文档扩展名为html或htm-bhtml文档必须包括head和body部分以下说法正确的是">9、a:HTML文档扩展名为.html或.htm; b:HTML文档必须包括head和body部分,以下说法正确的是（）</h1>
<h2 id="答案只有a说法正确">答案：只有a说法正确；</h2>
<h2 id="html文档可以省略这三个htmlheadbody标签">html文档可以省略这三个html,head,body标签！！！</h2>
<ol>
<li>例子</li>
</ol>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
ddd

</code></pre>
<ul>
<li><code>虽然缺少了html标签，body标签，head标签，依旧会被正确解析</code>为:</li>
</ul>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
    &lt;/head&gt;
    &lt;body&gt;
        ddd
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h1 id="11-关于html的描述不推荐的是">11、关于HTML的描述，不推荐的是</h1>
<h2 id="答案可以使用center标签来设置元素居中">答案：可以使用center标签来设置元素居中；</h2>
<p>其他说法是正确的：</p>
<ul>
<li>在页面顶部必须加入DOCTYPE声明；</li>
<li>尽量将js引用放到HTML页面底部；</li>
<li>使用table标签来处理数据相关的展示；</li>
</ul>
<h1 id="12-svg图形与canvas的区别错误的是">12、SVG图形与canvas的区别错误的是</h1>
<h2 id="答案canvas绘制的图形能被搜索引擎抓取">答案：canvas绘制的图形能被搜索引擎抓取；</h2>
<p>其他说法是正确的：</p>
<ul>
<li>canvas是HTML5提供的新元素;</li>
<li>canvas绘制的是标量图，svg绘制的是矢量图；</li>
<li>canvas绘制图形通常是JavaScript实现，svg图形通常通过html标签来实现；</li>
</ul>
<h1 id="13-html5新增的表单元素不包括">13、HTML5新增的表单元素不包括</h1>
<h2 id="答案password">答案：password；</h2>
<p>其他说法是正确的：</p>
<ul>
<li>color；</li>
<li>data；</li>
<li>number;</li>
</ul>
<p>**表单控：**color ,  calendar  ,  date ,  datetime, datetime-local,  time, mouth , week, email, url , search,range, tel<br>
**新的表单元素： **datalist ， keygen， output</p>
<h1 id="14-transition与animation的区别说法错误的是">14、transition与animation的区别说法错误的是</h1>
<h2 id="答案animation需要事件触发来达到动画的效果">答案：animation需要事件触发来达到动画的效果；</h2>
<p>其他说法是正确的：</p>
<ul>
<li>transition着重属性的变化，而animation重点是在创建帧，让不同帧在不同时间点发生不同变化；</li>
<li>animation可以实现复杂的动画；</li>
<li>animation通过@keyframe控制当前帧的属性；<br>
解析：<br>
animation可以一帧一帧执行 不需要事件的触发</li>
</ul>
<h1 id="15-在面向对象技术中多态性是指">15、在面向对象技术中，多态性是指（）</h1>
<h2 id="答案针对一消息不同对象可以以适合自身的方式加以响应">答案：针对一消息，不同对象可以以适合自身的方式加以响应</h2>
<p><strong>多态</strong>是面向对象的重要特性,简单点说:“一个接口，多种实现”，指一个基类中派生出了不同的子类，且每个子类在继承了同样的方法名的同时又对父类的方法做了不同的实现，这就是同一种事物表现出的多种形态。<br>
在面向对象方法中一般是这样表述多态性：向不同的对象发送<strong>同一条消息</strong>，不同的对象在接收时会产生不同的行为（即方法）。 也就是说，<strong>每个对象可以用自己的方式去响应共同的消息。</strong></p>
<h1 id="16-replacenew-regexp-gi-的执行结果是">16、'\\\'.replace(new RegExp('\\\\', 'gi'), '/') 的执行结果是？</h1>
<h2 id="答案-2">答案：/\</h2>
<p>在字符串里面， 字符串\ 是需要进行转义的，所以字符串\得写为'\'<br>
在正则表达式中，正则表达式\也是需要进行转义的，所以正则表达式表达式\得写为/\/<br>
所以，题目得意思是：<br>
在字符串\\中全局匹配，忽略大小写，把匹配到的字符串\换成字符串/<br>
<img src="https://cutezhangq.github.io/post-images/1599204430768.png" alt="" loading="lazy"></p>
<pre><code class="language-js">  let a = '\\\\\\'.replace(new RegExp('\\\\\\\\', 'gi'), '/');
  console.log('题目结果：',a);   //  结果：  /\
  let b = '\\\\\\';
  //在字符串里面， 字符串\ 是需要进行转义的，所以字符串\得写为'\\';所以 6个\的结果表示的是 \\\
  console.log('\\\\\\结果：',b) //  结果： \\\
//   在正则表达式中，正则表达式\也是需要进行转义的，所以正则表达式表达式\得写为/\\/
//   所以，题目得意思是：
//   在字符串\\\中全局匹配，忽略大小写，把匹配到的字符串\\换成字符串/
  let c = '\\\\\\\\';
  console.log('\\\\\\\\结果：',c) //  结果： \\\\

  let reg = new RegExp(c,'gi');     
            //  /.../g: global 的意思，找到之後會繼續往後配對
            //  /.../i: case insensitive不区分大小写 的意思
  console.log(reg);    // 结果： /\\\\/gi
  let newa = a.replace(reg, '/');   // 把匹配到的字符串\\换成字符串/  ,/\\\\/表示正则\\
  console.log(newa);  //  结果：  /\
</code></pre>
<h1 id="17-执行下列语句后变量name的值为">17、执行下列语句后，变量name的值为</h1>
<pre><code class="language-js">var name = '1';
new Promise(function (resolve, reject) {
    resolve();
    reject();
}).then(function () {
    name = '2';
}).catch(function () {
    name = '3';
});
    name = '4';
</code></pre>
<h2 id="答案2">答案：2</h2>
<p>new Promise是异步的，所以它会在最后执行。然后resolve和reject两种状态只会触发一种，先调用resolve方法，就不会调用reject方法，接着执行then后面的回调函数，所以最后name为2；看顺序效果的话可以在每个name后面打印一下即可，代码如下</p>
<pre><code class="language-js">  var name = '1';
  console.log(name);
  new Promise(function (resolve, reject) {
    resolve();
    reject();
  }).then(function () {
    name = '2';
    console.log(name);

  }).catch(function () {
    name = '3';
    console.log(name);

  });
  name = '4';
  console.log(name);

  // 1
  // 4
  // 2
</code></pre>
<p>先执行宏任务<br>
var name = 1<br>
resolve() // 我理解为return，所以reject不会执行<br>
然后 name = 4<br>
然后是微任务<br>
name = 2<br>
所以最后name为2</p>
<!-- more -->
<p>先执行宏任务<br>
var name = 1<br>
resolve() // 我理解为return，所以reject不会执行<br>
然后 name = 4<br>
然后是微任务<br>
name = 2<br>
所以最后name为2</p>
<h1 id="18-执行下列语句后变量a的值为">18、执行下列语句后，变量a的值为</h1>
<pre><code class="language-js">var a = [].push(...[1, 2, 3]);
</code></pre>
<h2 id="答案3">答案：3</h2>
<p>push() 方法可向数组的末尾添加一个或多个元素，并<code>返回新的长度</code>。</p>
<h1 id="19-根据如下代码setsize的值为">19、根据如下代码，set.size的值为</h1>
<pre><code class="language-js">var set = new Set([0, 2, 2, 0, 0, 5, 9, {}, {}, NaN, NaN]);
</code></pre>
<h2 id="答案7">答案：7</h2>
<p>两个空值为不同元素，NaN为相同元素，还有四个不同的数字。</p>
<p>ES6 提出“Same-value equality”<code>（同值相等）</code>算法<br>
不同之处只有两个：一是<code>+0不等于-0</code>，二是<code>NaN等于自身</code>。<br>
set使得NaN和NaN对比是相等的，解决了===在NaN上的bug</p>
<pre><code class="language-js">  var set = new Set([0, 2, 2, 0, 0, 5, 9, {}, {}, NaN, NaN,[],[],undefined,undefined,String,String,Number,Number,null,null,Boolean,Boolean]);
  console.log(set);
// 0: 0
// 1: 2
// 2: 5
// 3: 9
// 4: Object
// 5: Object
// 6: NaN

// 7: Array(0)
// 8: Array(0)
// 9: undefined
// 10: function String() { [native code] }
// 11: function Number() { [native code] }
// 12: null
// 13: function Boolean() { [native code] }
</code></pre>
<p>注意<code>NaN</code>特殊：为相同元素，<code>{ }</code>和<code>[ ]</code>特殊：为不同元素，其余的（基本类型，包括Object，Array）都为相同元素，被去重了</p>
<pre><code class="language-js">var set2 = new Set([Array,Array,Object,Object])
console.log(set2);
// 0: function Array() { [native code] }
// 1: function Object() { [native code] }
</code></pre>
<pre><code class="language-js">console.log(NaN === NaN)  //false
console.log({} === {} )   //false
console.log([] === [])    //false
console.log(undefined === undefined)  //true
console.log(null === null)            //true
console.log(Number === Number)        //true
console.log(String === String)        //true
console.log(Boolean === Boolean)      //true

console.log(Object === Object)    //true
console.log(Array === Array)      //true
</code></pre>
<h1 id="20-下列说法中错误的是">20、下列说法中错误的是</h1>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1599210844901.png" alt="" loading="lazy"></figure>
<p>事件触发顺序则是先捕获后冒泡.</p>
<h1 id="21-下列说法中正确的是">21、下列说法中正确的是</h1>
<h2 id="答案调用date构造函数而不传参数时得到的对象自动获得当前时间">答案：调用Date构造函数而不传参数时，得到的对象自动获得当前时间</h2>
<p>其他错误的描述：</p>
<ul>
<li>JSONP不是一种跨域技术</li>
<li>调用setInterval方法后得到的返回值为undefined</li>
<li>所有的RegExp实例对象都可以调用match方法</li>
</ul>
<p>SetInterval返回的是定时器的ID，可以利用clearInterval（定时器Id）来清除这个定时器</p>
<pre><code class="language-js">var intervalID = window.setInterval(myCallback, 500, 'Parameter 1', 'Parameter 2');
var intervalID2 = window.setInterval(myCallback, 1500, 'Parameter 1', 'Parameter 2');
function myCallback(a, b)
{
 // Your code here
 // Parameters are purely optional.
 console.log(a);
 console.log(b);
}
console.log(intervalID)  // 1
console.log(intervalID)  // 1
console.log(intervalID2) // 2
</code></pre>
<pre><code class="language-js">'a1b2c3'.search(/\d/g);  
var r = 'aaa123456'.match(/\d/);
var r = 'aaa123456'.match(/\d/g);
</code></pre>
<p><strong>match()<strong>方法将检索</strong>字符串</strong>，以找到一个或多个与regexp匹配的文本。但<strong>regexp</strong><code>是否具有标志 g</code>对结果影响很大。</p>
<p>如果regexp<code>没有</code>标志g，那么match()方法就只能在字符串中<code>执行一次</code>匹配。如果没有找到任何匹配的文本，match() 将返回null。否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。</p>
<p>如果regexp具有标志g则match()方法将执行全局检索，找到字符串中的所有匹配子字符串<br>
若没有找到任何匹配的子串，则返回 null。</p>
<h1 id="23-执行下列语句后变量name1的值为">23、执行下列语句后，变量name1的值为</h1>
<pre><code class="language-js">var name = 'tom';
function getMethod() {
var result = function () {
return name;
};
var name = 'jerry';
return result;
}
var getName = getMethod();
var name1 = getName();
</code></pre>
<h2 id="答案jerry">答案：jerry</h2>
<p>这道题考的是闭包，赋给getName的事指向函数result的指针，result是闭包，可以读取getMethod的私有变量，因此返回值为jerry</p>
<h1 id="24-以下关于os的说法正确的是">24、以下关于OS的说法正确的是</h1>
<h2 id="答案-3">答案：</h2>
<ul>
<li>多道批处理系统的特点：资源利用率高、系统吞吐量大、平均周转时间长、无交互能力</li>
<li>分时系统具有多路性、独立性、及时性、交互性</li>
<li>操作系统的基本特征：并发、共享、虚拟、异步</li>
</ul>
<p>在OS中通过<code>时分复用</code>和<code>空分复用</code>实现“虚拟”<br>
复用和虚拟相比较，复用所分割的是实际存在的物理资源，而虚拟则实现假想的同类资源。虚拟技术解决某类物</p>
<h1 id="25-下面说法不正确的是">25、下面说法不正确的是？</h1>
<h2 id="答案-4">答案：</h2>
<ul>
<li>若(u，v)是连通网络的一条最小权值的边，则不论采用何种方法构造该网络的最小生成树， 所构造出最小生成树一定包含(u，v)这条边。</li>
<li>单向哈希表的特征包括：把固定的信息转化成任意长度信息输出</li>
<li>树的后序遍历序列等同于该树对应的二叉树的后序序列，先序遍历序列等同于该树先序序列</li>
</ul>
<p>表述正确的是：对于静态表的顺序查找法，若在表头设置监视哨，则正确的查找方式为从第n个元素往开始前查找该数据元素</p>
<p>解析：<br>
任意长度计算成固定长度的哈希值<br>
A.如果(u，v)是连通网络的唯一的一条最小权值的边，那么一定包含(u，v)这条边<br>
D.树的先序对应二叉树的先序，树的后序对应二叉树的中序</p>
<h1 id="26-面向对象程序设计方法的优点包含">26、面向对象程序设计方法的优点包含：</h1>
<h2 id="答案可重用性-可扩展性-易于管理和维护">答案：可重用性、可扩展性、易于管理和维护</h2>
<h1 id="27-假定需要在-nodejs-环境中执行一些用户上传的自定义代码在没有做任何沙盒等安全措施的前提下存在哪些安全隐患">27、假定需要在 node.js 环境中执行一些用户上传的自定义代码，在没有做任何沙盒等安全措施的前提下，存在哪些安全隐患？</h1>
<h2 id="答案-5">答案：</h2>
<ul>
<li>大量的同步计算造成进程卡死</li>
<li>执行 process.exit(1) 造成进程直接退出</li>
<li>执行 require('child_process').spwan()，直接调用系统程序，造成系统层面的危害</li>
</ul>
<p>不存在的隐患：<br>
自定义代码抛出的异常无法被捕获</p>
<h1 id="28-关于-nodejs-中的模块化规范以下说法正确的有哪些">28、关于 node.js 中的模块化规范，以下说法正确的有哪些？</h1>
<h2 id="答案-6">答案：</h2>
<ul>
<li>require 加载模块是一个同步的过程</li>
<li>require 函数可以在代码的任意位置执行</li>
<li>exports 或 module.exports 其中一个一旦重新赋值，exports 将失效</li>
</ul>
<p>不正确的：模块最终导出的是 exports，而不是 module.exports<br>
<strong>解析：</strong><br>
ES6标准发布后，module成为标准，标准的使用时以export指令导出接口，以import引入模块，但是在以往的node模块中，我们采用的是CommonJS规范，使用require引入模块，使用module.exports导出接口<br>
exports和module.exports都对</p>
<pre><code class="language-js">  // { foo:'bar' }
  exports.foo = 'bar'

  // { foo:'bar',a:123 }
  module.exports.a = 123

  // 将exports的引用改变了
  exports = {
    a: 456
  }

  // { foo:'foo',a:123 }
  module.exports.foo = 'foo'

  // 无效
  exports.a = 567

  exports = module.exports

  // { foo: 'foo', a: 123, c: 789 }
  exports.c = 789
</code></pre>
<h1 id="29-下面选项中属于node定时器的是">29、下面选项中属于Node定时器的是？</h1>
<h2 id="答案-7">答案：</h2>
<ul>
<li>setTimeout()</li>
<li>setInterval()</li>
<li>setImmediate()</li>
<li>process.nextTick()</li>
</ul>
<h1 id="30-以下代码能在不同环境下不考虑兼容性问题正确判断变量a-是数组的有">30、以下代码能在不同环境下（不考虑兼容性问题）正确判断变量a = [] 是数组的有：</h1>
<h2 id="答案arrayisarraya-objectprototypetostringcalla-object-array">答案：Array.isArray(a)、Object.prototype.toString.call(a) === '[object Array]'</h2>
<p>不能判断的：a instanceof Array、typeof a === 'array'<br>
instanceof操作符的问题在于，它假定只有一个全局环境。如果网页中包含多个框架，那实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。<br>
如果你从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p>
<pre><code class="language-js">  var iframe = document.createElement('iframe');
  document.body.appendChild(iframe);

  var arr = [1, 2, 3];
  xArray = window.frames[0].Array; //iframe中的构造函数
  var arrx = new xArray(4, 5, 6);

  console.log(arrx instanceof Array); //false
  console.log(arrx.constructor == Array); // false

  console.log(Array.prototype == xArray.prototype); //false
  console.log(arr instanceof xArray); //false

  console.log(arrx.constructor === Array); // false
  console.log(arr.constructor === Array); // true
  console.log(arrx.constructor === xArray); // true
  console.log(Array.isArray(arrx)); //true
</code></pre>
<h1 id="31-用js实现一个用户行收集器功能如下">31、用js实现一个用户行收集器，功能如下：</h1>
<p>1，收集用户在页面中的所有click行为，并使用log方法发送日志，包含触发事件的节点xpath信息</p>
<p>2，xpath需包含tagName、id、class、同级同名节点索引(从1开始)，如</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;div id=“container”&gt;
    &lt;p&gt;something&lt;/p&gt;
    &lt;a id=“link1” class=“link-class”&gt;&lt;/a&gt;
    &lt;a id=“link2” class=“link-class current”&gt;target link&lt;/a&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>点击target link时，xpath为 <code>body[1]/div[1][@id=“container”]/a[2][@id=“link2”][contains(@class, “link-class&quot;)][contains(@class, “current&quot;)]</code><br>
3，不侵入、不影响其他业务代码的执行</p>
<!-- more -->
<pre><code class="language-cmd">回答得分占比：
写出根节点全局捕获阶段代理事件（20%）
写出由目标找到根节点递归方法（20%）
写出获取id、className方法（20%）
写出获取同级同名阶段索引方法（20%）
写出拼接xpath方法（20%）
</code></pre>
<h2 id="答案-8">答案：</h2>
<pre><code class="language-js">  // 遍历深度树形结构
  var obody = document.getElementsByTagName('body')[0];
  obody.addEventListener('click', function (e) {
    console.log(getXPath(e.target));
  })
  function getXPath(target) {
            if (target.nodeName == 'BODY') return 'body[1]';
            var index = 1;
             
            var str = '';
            var tempTarget = target;
            var nodeName = target.nodeName;
            var id = target.id;
            var classList = target.classList;
            // 这是在前面一个才可以，如果前面不是一样的标签，再前面有就不可以了
            // while (tempTarget.previousElementSilbling != null &amp;&amp; tempTarget.previousElementSilbling.nodeName == nodeName) {
            //     index++;
            //     // 当前一个节点存在且和自己是同一个标签，index++
            //     // 然后把target转到前面的标签（即计算有多少个相同的标签）
            //     tempTarget = tempTarget.previousElementSilbling;
            // }
            
            // 当前面有兄弟节点时，就可以往前
            while(tempTarget.previousElementSibling!=null)
            {
                 //如果前一个节点的node和要找的nodeName一样则index++，把target赋予前一个点
                if(tempTarget.previousElementSibling.nodeName == nodeName)
                {
                    index++;
                    console.log(index);
                } 
                // 无论前面的标签是否和自身一样，但是一直往前，比较是否和自身的nodeName一样
                tempTarget = tempTarget.previousElementSibling;
            }
             
            // 然后就str就是所在的位置
            str = '/' + nodeName.toLowerCase() + '[' + index + '][@id=&quot;' + id + '&quot;]';
            classList.forEach(function (ele, index, self) {
                str += '[contains(@class,&quot;' + ele + '&quot;)]';
            })
            return getXPath(target.parentNode) + str;
        }
</code></pre>
<h1 id="32-web-worker为web内容在后台线程中运行脚本提供了一种简单的方法-请列举出web-worker的常用api并列举至少1个web-worker的常见用途">32、Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。请列举出Web worker的常用API并列举至少1个Web Worker的常见用途。</h1>
<h2 id="答案-9">答案：</h2>
<pre><code class="language-cmd">回答得分占比：

能回答出Web Worker常用API（2个以上），得50%；

能例举多个Web Worker的应用场景，根据例举情况：1个得30%，2个及以上得50%。
</code></pre>
<p>postMessage(data) -&gt; 子线程与主线程之间互相通信使用的方法，传递的data为任意值;<br>
terminate() -&gt; 主线程中终止worker，此后无法再利用其进行消息传递;<br>
onmessage -&gt; 当有消息发送时，触发该事件；并且消息发送是双向，消息内容可通过data来获取;<br>
大数据的处理：这里所说的大数据处理，并不是指数据量非常大，而是要从计算量来看，通常用时不能控制在毫秒级内的运算都可以考虑放在web worker中执行。<br>
高频的用户交互：高频的用户交互适用于根据用户的输入习惯、历史记录以及缓存等信息来协助用户完成输入的纠错、校正功能等类似场景，用户频繁输入的响应处理同样可以考虑放在web worker中执行。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法（下）]]></title>
        <id>https://cutezhangq.github.io/post/pai-xu-suan-fa-xia/</id>
        <link href="https://cutezhangq.github.io/post/pai-xu-suan-fa-xia/">
        </link>
        <updated>2020-09-01T07:03:26.000Z</updated>
        <summary type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<h1 id="八计数排序算法">（八）：计数排序算法</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法（中）]]></title>
        <id>https://cutezhangq.github.io/post/pai-xu-suan-fa-zhong/</id>
        <link href="https://cutezhangq.github.io/post/pai-xu-suan-fa-zhong/">
        </link>
        <updated>2020-08-30T07:01:58.000Z</updated>
        <summary type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<h1 id="四希尔排序">（四）：希尔排序</h1>
<h3 id="算法介绍">算法介绍</h3>
<p>希尔排序，也称<code>递减增量排序</code>算法，是插入排序的一种更高效的改进版本。<br>
希尔排序算法的步骤描述如下：<br>
选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；按增量序列个数 k，对序列进行 k 趟排序；<br>
每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。<br>
仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
<h3 id="思路">思路</h3>
<p>通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。</p>
<h3 id="算法阐释">算法阐释</h3>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1598771169898.png" alt="" loading="lazy"></figure>
<h3 id="算法图解">算法图解</h3>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598771176444.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://cutezhangq.github.io/post-images/1598771191151.png" alt="" loading="lazy"></figure>
<pre><code class="language-js"> //希尔排序
    function shellSort(arr) {
      var len = arr.length,
        temp,
        gap = 1; //增量因子——————步长
      while (gap &lt; len / 3) { //动态定义间隔序列
        gap = gap * 3 + 1;
      }
      //逐步缩小增量
      for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) {
        //类直接插入排序算法
        for (var i = gap; i &lt; len; i++) {
          temp = arr[i];
          for (var j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) {
            arr[j + gap] = arr[j];    //记录后裔，查找插入位置
          }
          arr[j + gap] = temp;     //插入
        }
      }
      return arr;
    }

  const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
  console.log('————希尔排序——————',shellSort(testArr));
  //————希尔排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
</code></pre>
<p>第一层循环里面的两层嵌套循环算法，其实就是「直接插入排序」，<br>
不同就在于多了一个变量 gap，但其实当 gap === 1 时，那就跟上一节的算法，是完全一样的。</p>
<h3 id="算法实现总结">算法实现总结</h3>
<p>希尔排序的关键不是简单地按 1 为增量进行分组排序后，再合并整体排序；<br>
而是<code>选好一个初始化增量，不断地递减增量，每次递减之间都需要经过一次直接插入排序，使得排序的效率提高。</code><br>
另外只要最终增量为 1，则任何增量序列都可以工作，因为最终当增量为 1 时，算法就变为「直接插入排序」，这就保证了数据一定会被排序。</p>
<p><img src="https://cutezhangq.github.io/post-images/1598771270434.png" alt="" loading="lazy"><br>
综上所述，希尔排序算法的出现，我们终于突破了慢速排序的时代，也即超越了时间复杂度为 O(n²)。</p>
<h3 id="性能比较">性能比较</h3>
<p>在数据量相当的情况下：发现 拆半插入排序 &gt;= 单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 插入排序 &gt; <code>希尔排序</code> &gt;选择排序 &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h1 id="五归并排序">（五）：归并排序</h1>
<h3 id="算法介绍-2">算法介绍</h3>
<p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。归并排序算法的步骤描述如下：<br>
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；<br>
设定两个指针，最初位置分别为两个已经排序序列的起始位置；<br>
比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；<br>
重复步骤 3 直到某一指针达到序列尾；<br>
将另一序列剩下的所有元素直接复制到合并序列尾。</p>
<h3 id="思路-2">思路</h3>
<p>递归将数组分为两个序列，有序合并这两个序列。作为一种典型的<code>分而治之（拆分、合并）</code>思想的算法应用，归并排序的实现由两种方法：</p>
<ol>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）。</li>
<li>自下而上的迭代。</li>
</ol>
<p><a href="https://user-gold-cdn.xitu.io/2020/7/19/17364df73ad8a5fc?imageslim">动画演示</a></p>
<p>总结：</p>
<ul>
<li>将两个已排好序的数组合并成一个有序的数组,称之为归并排序</li>
<li>步骤：遍历两个数组，比较它们的值。谁比较小，谁先放入大数组中，直到数组遍历完成</li>
</ul>
<pre><code class="language-js">function mergeSort(arr) { // 采用自上而下的递归方法
  var len = arr.length;
  if(len &lt; 2) {
      return arr;
  }
  var middle = Math.floor(len / 2),
  left = arr.slice(0, middle),
  right = arr.slice(middle);
  return merge(mergeSort(left), mergeSort(right));    //拆分
}

function merge(left, right){
  var result = [];

  while (left.length &amp;&amp; right.length) {
    if (left[0] &lt;= right[0]) {
      result.push(left.shift());
    } else {
      result.push(right.shift());
    }
  }
  while (left.length)
    result.push(left.shift());        //合并
  while (right.length)
    result.push(right.shift());      //合并
  return result;
}


const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————归并排序——————',mergeSort(testArr));

//————归并排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://cutezhangq.github.io/post-images/1598872437803.png" alt="" loading="lazy"></figure>
<h3 id="二-归并排序前提分析分治法">二、归并排序前提分析(分治法)</h3>
<p>归并排序的前提是需要两个已经排好顺序的数组，那往往不会有两个已经排好顺序的数组给我们的呀(一般是杂乱无章的一个数组)，<br>
那这个算法是不是很鸡肋的呢？？<br>
其实并不是的，首先假设题目给出的数组是这样子的：int[] arr = {2, 7, 8, 1, 4, 9};<br>
当我们要做归并的时候就以arr[3]也就元素为1的那个地方分开。是然后用一个指针L指向arr[0]，一个指针M指向arr[3]，用一个指针R指向arr<a href="%E6%95%B0%E7%BB%84%E6%9C%80%E5%90%8E%E4%B8%80%E4%BD%8D">5</a>。有指针的帮助，我们就可以将这个数组切割成是两个有序的数组了（操作的方式就可以和上面一样了）<br>
可是上面说了，一般给出的是杂乱无章的一个数组，现在还是达不到要求。<br>
比如给出的是这样一个数组：int[] arrays = {9, 2, 5, 1, 3, 2, 9, 5, 2, 1, 8};<br>
此时，我们就得用到分治的思想了：<br>
*<br>
那么我们也可以这样想将int[] arr = {2, 7, 8, 1, 4, 9};数组分隔成一份一份的，arr[0]它是一个有序的&quot;数组&quot;,arr[1]它也是一个有序的&quot;数组&quot;,利用指针(L,M,R)又可以像操作两个数组一样进行排序。最终合成{2,7}.......再不断拆分合并，最后又回到了我们的arr = {1,2,4,7,8,9}，因此归并排序是可以排序杂乱无章的数组的</p>
<p>#（六）：快速排序</p>
<h3 id="算法介绍-3">算法介绍</h3>
<p>它是处理大数据最快的排序算法之一。快速排序是一种分而治之思想在排序算法上的典型应用。<br>
本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序算法的步骤描述如下：<br>
从数列中挑出一个元素，称为 “基准”（pivot）;<br>
重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。<br>
在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；<br>
递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br>
递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。<br>
虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p>
<figure data-type="image" tabindex="5"><img src="https://cutezhangq.github.io/post-images/1598872508940.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">  //分而治之

    function quickSort(arr, left, right) {
      var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;

      if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex - 1);
        quickSort(arr, partitionIndex + 1, right);
      }
      return arr;
    }

    function partition(arr, left, right) { // 分区操作
      var pivot = left, // 设定基准值（pivot）
        index = pivot + 1;
      for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
          swap(arr, i, index);
          index++;
        }
      }
      swap(arr, pivot, index - 1);
      return index - 1;
    }

    function swap(arr, i, j) {
      var temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    function paritition2(arr, low, high) {
      let pivot = arr[low];
      while (low &lt; high) {
        while (low &lt; high &amp;&amp; arr[high] &gt; pivot) {
          --high;
        }
        arr[low] = arr[high];
        while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) {
          ++low;
        }
        arr[high] = arr[low];
      }
      arr[low] = pivot;
      return low;
    }

    function quickSort2(arr, low, high) {
      if (low &lt; high) {
        let pivot = paritition2(arr, low, high);
        quickSort2(arr, low, pivot - 1);
        quickSort2(arr, pivot + 1, high);
      }
      return arr;
    }


  const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
  console.log('————快速排序算法——————',quickSort(testArr));
  console.log('————快速排序算法2——————',quickSort2(testArr));
  //————快速排序算法—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
  //————快速排序算法2—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="性能比较-2">性能比较</h3>
<p>在数据量相当的情况下：发现拆半插入排序 &gt;= 单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 插入排序 &gt; 希尔排序 &gt; 归并排序 &gt; 选择排序 &gt;= 快速排序1 &gt; 快速排序2 &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="注意">注意</h3>
<p>快排实现方法1，虽然代码相对看起来简单，但是在数据量较大时，会出现溢出问题。</p>
<h1 id="七堆排序算法">（七）：堆排序算法</h1>
<h3 id="算法介绍-4">算法介绍</h3>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。<br>
堆排序算法的步骤描述如下：<br>
创建一个堆 H[0……n-1]；<br>
把堆首（最大值）和堆尾互换；把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；<br>
重复步骤 2，直到堆的尺寸为 1。<br>
JavaScript实现堆排序算法的代码如下：<br>
var len;      // 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</p>
<h3 id="思路-3">思路</h3>
<p>说到堆排序，首先需要了解一种数据结构——堆。堆是一种完全二叉树，这种结构通常可以用数组表示。在实际应用中，堆又可以分为最小堆和最大堆，两者的区别如下：</p>
<ul>
<li>-max-heap property ：对于所有除了根节点（root）的节点 i，A[Parent(i)]≥A[i]</li>
<li>-min-heap property ：对于所有除了根节点（root）的节点 i，A[Parent(i)]≤A[i]</li>
</ul>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://cutezhangq.github.io/post-images/1598872660192.png" alt="" loading="lazy"></figure>
<pre><code class="language-js">    
    // 建立大顶堆
    function buildMaxHeap(arr) {
      len = arr.length;
      for (var i = Math.floor(len / 2); i &gt;= 0; i--) {
        heapify(arr, i);
      }
    }

    // 堆调整
    function heapify(arr, i) {
      var left = 2 * i + 1,
        right = 2 * i + 2,
        largest = i;

      if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) {
        largest = left;
      }

      if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) {
        largest = right;
      }

      if (largest != i) {
        swap(arr, i, largest);
        heapify(arr, largest);
      }
    }

    function swap(arr, i, j) {
      var temp = arr[i];
      arr[i] = arr[j];
      arr[j] = temp;
    }

    //堆排序
    function heapSort(arr) {
      buildMaxHeap(arr); // 建立大顶堆

      for (var i = arr.length - 1; i &gt; 0; i--) {
        swap(arr, 0, i); //交互
        len--;
        heapify(arr, 0); // 堆调整
      }
      return arr;
    }


    const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
    console.log('————堆排序——————',heapSort(testArr));
    //————堆排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="性能比较-3">性能比较</h3>
<p>在大数量量和小数据量不用的情况下，堆排序的相对性能排序表动比较大。和他本身的特点有关，虽然堆排序在实践中不常用，经常被快速排序的效率打败，但堆排序的优点是与输入的数据无关，时间复杂度稳定在O(N*lgN),不像快排，最坏的情况下时间复杂度为O(N2)。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[排序算法（上）]]></title>
        <id>https://cutezhangq.github.io/post/pai-xu-suan-fa-shang/</id>
        <link href="https://cutezhangq.github.io/post/pai-xu-suan-fa-shang/">
        </link>
        <updated>2020-08-27T02:18:15.000Z</updated>
        <summary type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<p><img src="https://cutezhangq.github.io/post-images/1598754120978.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1598754150521.png" alt="" loading="lazy"></p>
<h1 id="一冒泡排序">（一）：冒泡排序</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1598754182443.png" alt="" loading="lazy"></figure>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。冒泡排序算法的步骤描述如下：（<strong>相邻元素 比较 交换位置</strong>）</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="具体实现">具体实现：</h3>
<pre><code class="language-js"> //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}  

</code></pre>
<p>案例：</p>
<pre><code class="language-js">  //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
  var bubbleSort = function(arr){
    var i,j,m;
    var len = arr.length;
    if(len &lt;= 1){
      return arr;
    }

    for(i = 0;i&lt;len - 1;i++){ //循环2层：两两比较
      for(j=0;j&lt;len-1;j++){
        if(arr[j] &gt; arr[j+1]){  //当前一个比后一个大了
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
      console.log(`第${i+1}次循环————`, arr);
    }
    return arr;
  }
const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————冒泡排序——————',bubbleSort(testArr));
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598754314075.png" alt="" loading="lazy"></figure>
<h2 id="优化单向冒泡实现">优化：单向冒泡实现</h2>
<p>如果数组原本的顺序就是冒泡的，又或者仅做完前面寥寥几次就已经达到效果了，那后续的比较工作就显得有些多余了，如何对以上算法进行改进？<br>
我们可以在某一轮的循环比较结束后，<strong>如果没有发生任何的元素交换，则可以认为该数组已经达到预期效果，不必再继续下一轮的比较了</strong>。</p>
<pre><code class="language-js">var bubbleSort2 = function(arr){
  var start = + new Date();
  var i,j,m,noswap; //noswap没有交换
  var len = arr.length;
  if(len &lt;= 1){
    return arr;
  }

  for(i=0;i&lt;len-1;i++){
    noswap = true;  //未交换
    for(j=0;j&lt;len-1;j++){
      if(arr[j] &gt; arr[j+1]){  
          m = arr[j];         
          arr[j] = arr[j+1];
          arr[j+1] = m;
          noswap = false; //交换了
        }
    }
    if(noswap){
      break;
    }
  }
  // 当 arr 的长度越长，时间差越明显
  console.log(+new Date() - start);
  return arr;
}
const testArr2 = [11,4,6,52,3,20,1,9,2,5,19,3,6,21,105,22,33,44,88,22,1,2,0,3,9,4,100,103,98]
console.log('————改进版冒泡排序——————',bubbleSort2(testArr2));
// 0
// ————改进版冒泡排序—————— (29) [0, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 6, 9, 9, 11, 19, 20, 21, 22, 22, 33, 
44, 52, 88, 98, 100, 103, 105]

</code></pre>
<h2 id="优化双向冒泡实现">优化：双向冒泡实现</h2>
<p>普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，双向冒泡排序则是<code>多一轮的筛选</code>，即找出<code>最大值也找出最小值</code>。</p>
<pre><code class="language-js"> //算法改进————————双向冒泡实现
    // 普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，
    // 双向冒泡排序则是多一轮的筛选，即找出最大值也找出最小值。
  let testArr3 = [1, 6, 7, 4, 5, 8, 9, 0, 2, 3];
  let res = bubbleSortTow(testArr3)
  console.log(res);

  function bubbleSortTow(arr) {
    let low = 0;
    let high = arr.length - 1;
    while(low &lt; high){
      let mark = true;
      // 找到最大值放到右边
      for (let i = low; i &lt; high; i++) {
        if (arr[i] &gt; arr[i + 1]) {
          [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
          mark = false;
        }
      }
      high--;
      // 找到最小值放到左边
      for (let j = high; j &gt; low; j--) {
        if (arr[j] &lt; arr[j - 1]) {
          [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
          mark = false;
        }
      }
      low++;
      console.log(mark);
      console.log(`第${low}次循环`, arr);
      if (mark) 
        return arr;
    }
  }
</code></pre>
<h3 id="性能比较">性能比较</h3>
<p>对三种排序的算法进行性能的比较：发现<br>
<code>单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 大于普通冒泡性能。</code>（产生时间具体取决于所使用的系统）</p>
<h3 id="时间度复杂度分析">时间度复杂度分析:</h3>
<figure data-type="image" tabindex="3"><img src="https://cutezhangq.github.io/post-images/1598754429691.png" alt="" loading="lazy"></figure>
<!-- more -->
<h1 id="二选择排序">（二）：选择排序</h1>
<h3 id="算法介绍">算法介绍</h3>
<p>打个比方，喜欢短线炒股的朋友，习惯短时间内不断地买进卖出，通过价差来实现盈利。<br>
但是通常如此频繁操作，即使失误不多，也会因为操作的手续费和印花税而获利较少。<br>
另外一种长线炒股的朋友，习惯长时间持有，不断地观察和判断，时机一到便果断买进或卖出，交易次数少，收益颇丰。<br>
上一节说的冒泡排序就类似于短线炒股，不断地比较之后进行交换，完成排序。<br>
而本节所要讲解的简单选择排序，类似于长线炒股，虽然也在不断地观察比较，但是会在合适的时机进行交换，并且只移动一次就完成相应关键字的排序定位工作。这就是选择排序法的初步思想。<br>
<code>依次找到剩余元素的 最小值或者最大值，放置在 末尾或者开头。</code></p>
<h3 id="算法图示">算法图示：</h3>
<ul>
<li>第一趟：如下图，先选择1和9，比较，1&lt;9，所以将1放在前面，9放在后面，然后再拿着9和剩下的数组中比较；</li>
<li>第二趟：在剩下的数组中找到最小值，是2，拿2和9比较，2&lt;9，将2放前面，9放在原来2的位置，然后再拿着9和剩下的数组中比较；</li>
<li>第三趟：在剩下的数组中找到最小值，是3，拿3和9比较，3&lt;9，将3放前面，9放在原来3的位置，然后再拿着3和剩下的数组中比较；</li>
<li>第四趟：在剩下的数组中找到最小值，是4，拿4和3比较，4&gt;3，依旧将3放前面，4放在3的后面位置，然后再拿着4和剩下的数组中比较；</li>
<li>第五趟：在剩下的数组中找到最小值，是5，拿5和4比较，5&gt;4，依旧将4放前面，5放在4的后面位置（与7交互），然后再拿着7和剩下的数组中比较；</li>
<li>第六趟： 在剩下的数组中找到最小值，是5，拿5和7比较，5&lt;7，将5放前面，7放在原来5的位置，然后再拿着5和剩下的数组中比较；</li>
<li>第七趟：在剩下的数组中找到最小值，是6，拿6和5比较，6&gt;5，依旧将5放前面，6放在5的后面位置，然后再拿着6和剩下的数组中比较；</li>
<li>第八趟：在剩下的数组中找到最小值，是7，拿7和6比较，7&gt;6，依旧将6放前面，7放在6的后面位置，然后再拿着8和剩下的数组中比较；</li>
<li>第九趟：在剩下的数组中找到最小值，是9，拿9和8比较，9&gt;8，依旧将8放前面，9放在8的后面位置，剩下数组为空</li>
<li>排序结束.....</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://cutezhangq.github.io/post-images/1598770578518.png" alt="" loading="lazy"></figure>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。选择排序算法的步骤描述如下：</p>
<ul>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第二步，直到所有元素均排序完毕。</li>
</ul>
<pre><code class="language-js">//选择排序算法
  function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i; //最小数的索引
        for (var j = i + 1; j &lt; len; j++) {   //依次查找剩余元素
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];    //将选出的元素放到末尾
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}   


const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————选择排序——————',selectionSort(testArr));
 //(14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="复杂度分析">复杂度分析</h3>
<figure data-type="image" tabindex="5"><img src="https://cutezhangq.github.io/post-images/1598770628327.png" alt="" loading="lazy"></figure>
<h3 id="性能比较-2">性能比较</h3>
<p>对于等量的数据进行性能比价，发现单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; <code>选择排序</code> &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="提示">提示</h3>
<p>选择排序是时间复杂度上表现最稳定的算法之一，因为最快、最慢时间复杂度都是O(n²)，用选择排序数据量越小越好</p>
<!-- more -->
<h1 id="三直接插入排序">（三）：直接插入排序</h1>
<h3 id="算法介绍-2">算法介绍</h3>
<p>我们都应该玩过扑克牌了，游戏期间玩家们基本上都是一边摸牌一边理牌，会把牌面值小的牌放到左边，牌面值大的牌放到右边，以升序进行排序（当然也有喜欢降序排序的玩家）。<br>
而理牌期间，我们习惯从左往右看牌面值大小，两两比较，将牌抽出，插入到合理的位置。<br>
这里我们理牌的方法，就是「直接插入排序法」。<br>
直接插入排序法的基本操作是<code>将一个元素插入到已经排好序的数组中，从而得到一个新的、Unicode 值递增的数组。</code></p>
<h3 id="算法图示-2">算法图示：</h3>
<figure data-type="image" tabindex="6"><img src="https://cutezhangq.github.io/post-images/1598770756271.png" alt="" loading="lazy"></figure>
<h3 id="分析">分析：</h3>
<p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。<br>
插入排序算法的步骤描述如下：<br>
将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。<br>
从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。<br>
（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
<pre><code class="language-js">  //插入排序
  function insertionSort(arr){
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
      preIndex = i - 1;   //前一个元素下标
      current = arr[i];   //当前元素
      while(preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
        arr[preIndex+1] = arr[preIndex];  //将前一个元素往后挪动一位
        preIndex--;     //继续循环遍历
      }
      arr[preIndex+1] = current;    //之前preIndex--了，所以这里要+1
    }
    return arr;
  }


 const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
 console.log('————选择排序——————',insertionSort(testArr));
 //————选择排序—————— (14) [1, 2, 3, 3, 4, 5, 6, 6, 9, 11, 19, 20, 21, 52]
</code></pre>
<pre><code class="language-js"> var insertSort2 = function(arr){
  var i, j, m, mCnt=0;    //m:更小的元素    mCnt:移动的次数
  var len = arr.length;

  for (i=1; i&lt;len; i++) {
    if (arr[i] &lt; arr[i-1]) {    //后面的元素比前面的更小
      // 将更小的那个元素保存起来
      m = arr[i];
      for (j=i-1; arr[j]&gt;m; j--) {
        //将前一个元素往后挪动一位
        arr[j+1] = arr[j];
        mCnt++;
      }
      // console.log('移动了 '+mCnt+' 次');
      mCnt = 0;
      // 直接插入
      arr[j+1] = m;
    }
  }

  return arr;
};


console.log(insertSort2([5,4,3,2,1])) 
//(5) [1, 2, 3, 4, 5]
console.log(insertSort2([3, 2, 1, 7, 8, 9, 0]))
//(7) [0, 1, 2, 3, 7, 8, 9]
</code></pre>
<h3 id="复杂度分析-2">复杂度分析</h3>
<figure data-type="image" tabindex="7"><img src="https://cutezhangq.github.io/post-images/1598770822597.png" alt="" loading="lazy"></figure>
<h2 id="优化拆半插入排序">优化：拆半插入排序</h2>
<pre><code class="language-js">//优化：拆半插入排序实现
  //在直接插入排序的基础上，在插入的时候运用了折半查找法查找要插入的位置，再进行插入。
  let array = [11,4,6,52,3,20,1,9,2,5,19,3,6,21];
  for (let i = 0; i &lt; 10; i++) {
      let number = Math.floor(Math.random() * 10);
      array.push(number);
  }
  let res = this.binsertSort(array);
  console.log(res);
   /**
     * 拆半插入排序
     */
  function binsertSort(arr) {
      let low, high, j, temp;
      for (let i = 1; i &lt; arr.length; i++) {
          if (arr[i] &lt; arr[i - 1]) {
              temp = arr[i];
              low = 0;
              high = i - 1;
              while (low &lt;= high) {
                  let mid = Math.floor((low + high) / 2);
                  if (temp &gt; arr[mid]) {
                      low = mid + 1;
                  } else {
                      high = mid - 1;
                  }
              }
              for (j = i; j &gt; low; --j) {
                  arr[j] = arr[j - 1];
              }
              arr[j] = temp;
          }
          console.log(`第${i}次循环`, arr);
      }
      return arr;
  }

//(24) [0, 1, 2, 2, 3, 3, 3, 4, 4, 5, 5, 5, 6, 6, 6, 7, 8, 8, 9, 11, 19, 20, 21, 52]

</code></pre>
<h3 id="性能比较表示性能相差不大">性能比较&gt;=表示性能相差不大</h3>
<p>在数据量相当的情况下：发现拆半插入排序 &gt;= 单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; <code>插入排序</code> &gt; 选择排序 &gt; 大于普通冒泡性能。（产生时间具体取决于所使用的系统）</p>
<h3 id="提示-2">提示</h3>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逻辑题]]></title>
        <id>https://cutezhangq.github.io/post/luo-ji-ti/</id>
        <link href="https://cutezhangq.github.io/post/luo-ji-ti/">
        </link>
        <updated>2020-08-21T07:37:32.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录一些小的逻辑题或算法题👀，啊啊啊，血的教训😰，思考方式很重要</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录一些小的逻辑题或算法题👀，啊啊啊，血的教训😰，思考方式很重要</p>
<!-- more -->
<h1 id="关于取火柴棒问题取胜方法的一些思考">关于取火柴棒问题取胜方法的一些思考</h1>
<p>取火柴棒游戏的问题叙述:<br>
桌上有<strong>n根</strong>火柴棒,甲乙<strong>两人</strong>按照如下规则轮流取走这些火柴棒:</p>
<ul>
<li>1.<code>每次只允许取走1~2根火柴棒</code>;</li>
<li>2.<code>最后一次取走火柴棒的人获胜</code>;</li>
</ul>
<p>若甲先取,且甲想要取胜,那么可以考虑如下一种策略(我们姑且就称之为<code>策略A</code>吧):</p>
<pre><code class="language-cmd">甲先取,之后乙取,若乙取1个火柴棒,那么之后甲就取2个火柴棒;若乙取2个火柴棒,则甲取1个火柴棒,
总之就是保证甲+乙=3,那么,就产生了如下3种情况:
</code></pre>
<h2 id="1n3k1k是整数">1)n=3k+1,k是整数:</h2>
<p>这种情况下,甲要取胜,方法为:<code>先取1个火柴棒</code>(这是最后一个1),那么还剩下3k个火柴棒,之后采取策略A.这样,就能<code>保证每回合都取走3个</code>,且甲取后一次.以此类推,甲就一定能取胜.</p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
</tr>
<tr>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
</tr>
</tbody>
</table>
<h2 id="2n3k2k是整数">2)n=3k+2,k是整数:</h2>
<p>这种情况下,甲要取胜,方法为:<code>先取2个火柴棒</code>,那么还剩下3k个火柴棒,之后采取策略A.这样,就能<code>保证每回合都取走3个</code>,且甲取后一次.以此类推,甲就一定能取胜.</p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
</tr>
<tr>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
</tr>
</tbody>
</table>
<h2 id="3n3kk是整数">3)n=3k,k是整数;</h2>
<p>这种情况下,<code>甲要么先取1个,要么先取2个</code>.剩下的就是:<code>3k-1或者3k-2</code>;而3k-1=(3k+2)-3; 3k-2=(3k+1)-3 在这种情况下,甲是必输的.因为这个问题可以<code>等价于</code><strong>乙先取3k-1或3k-2个火柴棒</strong>,也就是3k+2或3k+1个火柴棒,这与上述1),2)的情况是一样的.所以,这种情况下,<code>甲必输</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结:</h3>
<p>在甲先取的情况下,胜负如下</p>
<ul>
<li>1)若n=3k+1或者n=3k+2</li>
</ul>
<p>甲采取策略A必胜</p>
<ul>
<li>2)若n=3k</li>
</ul>
<p>乙一定能用策略A取得胜利,亦即乙必胜.</p>
<h2 id="进一步推广取火柴棒问题描述如下">进一步推广取火柴棒问题,描述如下:</h2>
<p>桌上有<code>n个</code>火柴棒,甲乙两人按照如下规则轮流取走这些火柴棒:</p>
<p><code>1)每次只允许取走1~m个火柴棒;</code></p>
<p><code>2)最后一次取走火柴棒的人获胜;</code></p>
<p>我们可以从上面的推理中类推出此问题的解,取胜方法策略为(我们姑且称之为<code>策略B</code>):</p>
<p>若甲先取,且甲想取胜</p>
<p>甲先取若干个火柴棒,之后乙取,若乙取1个火柴棒,那么之后甲就取m个火柴棒;若乙取2个火柴棒,则甲取m-1个火柴棒......总之就是保证<code>甲+乙=m+1</code>,那么,就产生了如下m+1种情况:</p>
<h2 id="1nm1k1k是整数">1)n=(m+1)*k+1,k是整数;</h2>
<p>甲先取1个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<h2 id="2nm1k2k是整数">2)n=(m+1)*k+2,k是整数:</h2>
<p>甲先取2个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<h2 id="">......</h2>
<h2 id="mnm1kmk是整数">m)n=(m+1)*k+m,k是整数:</h2>
<p>甲先取m个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<p>m+1)n=(m+1)*k,k是整数:</p>
<p>这种情况下,甲要么先取1个,要么先取2个,要么先取3个,......要么先取m个,那么分别还剩下:(m+1)*k-1,(m+1)*k-2,(m+1)*k-3,......,(m+1)*k-m个火柴棒,亦即<code>[(m+1)*k+m]-(m+1),......,[(m+1)*k+1]-(m+1)</code>个火柴棒.这相当于上面的1)~m)这m种情况,只不过先取的是乙,这种情况下,乙必胜.</p>
<h3 id="总结-2">总结:</h3>
<p>甲先取,且甲想取胜</p>
<ul>
<li>1)若n=(m+1)*k+1,(m+1)*k+2,......,(m+1)*k+m</li>
</ul>
<p>采取上述策略,甲一定能取得胜利</p>
<ul>
<li>2)若n=(m+1)*k</li>
</ul>
<p>乙采取上述策略,乙一定能取得胜利.</p>
<blockquote>
<p>从上面的结论,我们可以看到,只有一种情况下,乙是必胜的,那就是n=(m+1)*k,其余都是甲必胜,可见,甲必胜的概率随着m的增加而不断变大,同时,我们也可以看出,先手者胜率高.</p>
</blockquote>
<p>👉考察了<code>逆向来思考</code>能力【反向逆推法】，数据之间产生关系（相加）规律，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔试-题目整理2-2020bilibili ]]></title>
        <id>https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/</id>
        <link href="https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/">
        </link>
        <updated>2020-08-14T07:18:46.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
<!-- more -->
<h1 id="1关于domcontentloaded和load事件说法正确的是">【1.】关于DOMContentLoaded和load事件说法正确的是？</h1>
<p>A DOMContentLoaded事件比load事件更早执行<br>
B load事件比DOMContentLoaded事件更早执行<br>
C 按监听代码从上到下先后执行<br>
D dom文档完全加载完后执行load事件</p>
<h2 id="答案a-domcontentloaded事件比load事件更早执行">答案：A DOMContentLoaded事件比load事件更早执行</h2>
<p><strong>DOMContentLoaded</strong>：DOM解析完成之后。<br>
当纯HTML被完全加载以及解析时，DOMContentLoaded事件会被触发，而不必等待样式表，图片或者子框架完成加载。</p>
<pre><code class="language-cmd">MDN
当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。
</code></pre>
<p><strong>load</strong>：页面HTML、CSS、JS..及图片等外链资源加载完成之后，才会执行load。<br>
当一个资源及其依赖资源已完成加载时，将触发load事件。</p>
<h1 id="2如何在-div-容器里展示-divdiv-这几个字符">【2.】如何在 div 容器里展示 <div></div> 这几个字符？</h1>
<h2 id="答案documentqueryselectordivinnertext-divdiv">答案：document.querySelector('div').innerText = &quot;<div></div>&quot;</h2>
<pre><code class="language-html">  &lt;!--  innerHTML：设置或获取标签所包含的HTML与文本信息。（不含标签本身）
        innerText：设置或获取标签所包含的文本信息。（不含标签本身）
        outerHTML：设置或获取标签本身以及所包含的HTML与文本信息。（包含标签本身）
        outerText：设置或获取标签本身以及所包含的文本信息。（包含标签本身） --&gt;

&lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
&lt;/div&gt;
    &lt;script&gt;
        var div=document.getElementsByTagName(&quot;div&quot;);
        console.log(div[0].innerHTML);      //  &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
        console.log(div[0].innerText);         //  this is text
        console.log(div[0].outerHTML);     // &lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;&lt;/div&gt;
        console.log(div[0].outerText);        //  this is text
    &lt;/script&gt;
</code></pre>
<h1 id="3以下不是box-sizing的属性是">【3.】以下不是box-sizing的属性是？</h1>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>content-box</td>
<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>
</tr>
<tr>
<td>border-box</td>
<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应从父元素继承 box-sizing 属性的值。</td>
</tr>
</tbody>
</table>
<h2 id="box-sizing">box-sizing</h2>
<p>box-sizing 最主要的用法是规定容器元素的<strong>最终尺寸计算方式。</strong></p>
<p>如果你创造了一个 <code>&lt;div&gt;</code> 没有设置 <code>box-sizing</code>属性为<code>border-box</code>(不设置的话默认值为 <code>content-box</code>)，同时你设置 <code>width:100px; border:10px solid red; padding:10px;</code>那么最终 div 容器的实际宽度为：</p>
<pre><code class="language-js">100px(width)+2*10px*(padding)+2*10px(border)=140px
</code></pre>
<p>所以你会得到一个比你预期（100px）还要更大的容器，结果就是会破坏网页布局。<br>
注意：容易 margin 的尺寸不会被计算入最终容器宽度，因为对他的定义为对这个容器的留白，但不属于容器本身。</p>
<p>如果当我们定义一个容器的 <code>box-sizing</code>属性为<code>border-box</code>时<br>
（表达式：<code>br{box-sizing:border-box}</code>），那么我们创建一个和上段中相同设置的<code>&lt;div&gt;</code>容器时，那么他的最终宽度即为 100px, 那么它的内容部分（content）的有效宽度变成了</p>
<pre><code class="language-js">100px-2*10px-2*10px =60px; 
</code></pre>
<p>所以你会得到一个你预期大小的盒子容器，但是只是被压缩了内容部分尺寸而已，但是对于整体布局而言益处颇多。</p>
<p>所以要合理利用好这个属性，这个属性十分重要。</p>
<!-- more -->
<h1 id="4-1-32-的值为">【4.】‘-1 &gt;&gt;&gt; 32 的值为(  )’</h1>
<p>emm...知识盲区😳😳😳</p>
<h2 id="答案232-1">答案：2^32-1</h2>
<pre><code class="language-cmd">&gt;&gt;这个是带符号右移
&gt;&gt;&gt; 这个是无符号右移
无符号右移运算符（&gt;&gt;&gt;）
</code></pre>
<p><code>按二进制形式把所有的数字向右移动对应位数，低位移出(舍弃)，高位的空位补零。对于正数来说和带符号右移（&gt;&gt;） 相同，但是对于负数来说不同。</code><br>
<strong>正数</strong><br>
例：20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为0001 0100<br>
2、<code>将二进制数向右移两位，高位补符号位（0）</code>，得到0000 0101<br>
3、最后<code>将二进制数转化成十进制数</code>，0000 0101转化为十进制为5<br>
所以，20 &gt;&gt; 2 = 5</p>
<p><strong>负数</strong><br>
例：-20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为1110 1100   //<code>取反加1</code>  20的二进制为0001 0100 取反得到1110 1011 加1后得到1110 1100<br>
2、将<code>二进制数向右移两位，高位补符号位（1）</code>，得到1111 1011<br>
3、最后<code>将二进制数转化成十进制数</code>，1111 1011转化为十进制为-5  //取反 0000 0100 加1   0000 0101 因为是负数，也就是1000 0101也就是2的2次方加2的零次方 等于-5<br>
所以，-20 &gt;&gt; 2 = -5</p>
<p><code>1</code>的二进制 00000000 00000000 00000000 00000001<br>
<code>-1</code>的二进制 10000000 00000000 00000000 00000001 取反加1得到补码 11111111 11111111 11111111 11111111  //首位不变，其余为取反<br>
右移32位（高位补符号位1） 也就是11111111 11111111 11111111 11111111  //32位<br>
假设该数值加上一也就是变成<br>
1 00000000 00000000 00000000 00000000  //1后面有32个0<br>
那就把刚才加上的1减掉<br>
也就是结果<br>
2^32-1<br>
<img src="https://cutezhangq.github.io/post-images/1597476991984.png" alt="" loading="lazy"></p>
<h1 id="51-2-3mapparseint">【5.】['1', '2', '3'].map(parseInt) ( )</h1>
<h2 id="答案1-nan-nan">答案：[1, NaN, NaN]</h2>
<pre><code class="language-js">['1', '2', '3'].map((item, index) =&gt; {
    return parseInt(item, index)
})
parseInt('1', 0) // 1  默认十进制的1
parseInt('2', 1) // NaN 1进制没有2
parseInt('3', 2) // NaN,2进制逢2进1
</code></pre>
<p>ps 啥是parseInt<br>
parseInt('11',2) //二进制的11 转换成十进制应该是 3</p>
<p>['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4]<br>
意思是0(默认0是十进制)进制的十转换成十进制是多少 1进制的十转换成十进制是多少 二进制的10转换成十进制是多少...</p>
<pre><code class="language-js">['1','2','3'].map((a,b,arr)=&gt;{  //a:循环得到的那一项的值；b:循环时的索引; arr整个数组的值
    parseInt(a,b);  //a代表那一项； b代表进制
})
// parseInt(string, radix)   
// 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。
parseInt('1', 0) // radix 为 0，默认以十进制解析字符串，返回 1 

parseInt('2', 1) // radix 为 1，不在 2 ~ 36 之间，返回 NaN 

parseInt('3', 2) // radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN
//2 进制只有0和1，，，3超出范围了
</code></pre>
<h1 id="6计算结果">【6.】计算结果</h1>
<pre><code class="language-js">console.log(1);
setTimeout(() =&gt; {console.log(2)}, 0);
console.log(3);
Promise.resolve(4).then(b =&gt; {
console.log(b);
});
console.log(5);
</code></pre>
<h2 id="答案1-3-5-4-2">答案：1 3 5 4 2</h2>
<p><code>console.log()</code> -&gt; <code>同步</code><br>
<code>promise</code>-&gt; <code>异步，微任务</code><br>
<code>setTimeout</code> -&gt; <code>异步，宏任务</code><br>
执行顺序:<code>同步</code> &gt;<code>异步,微任务</code> &gt; <code>异步，宏任务</code></p>
<h1 id="7mathabs-6666-的结果是多少">【7.】Math.abs(-6.666) 的结果是多少?</h1>
<h2 id="答案6666">答案：6.666</h2>
<p><code>Math.abs()</code>转为为绝对值</p>
<p><code>parseInt(7/2)</code>丢弃小数部分,保留整数部分</p>
<p><code>Math.ceil(7/2)</code>向上取整,有小数就整数部分加1</p>
<p><code>Math.round(7/2)</code>四舍五入</p>
<p><code>Math.floor(7/2)</code>向下取整</p>
<h1 id="812345-的数组的基础上-删除第一个-和-最后一位">【8.】[1,2,3,4,5] 的数组的基础上 删除第一个 和 最后一位</h1>
<p>[1,2,3,4,5].replace(1, -1)<br>
[1,2,3,4,5].reverse(1，-1)<br>
[1,2,3,4,5].toString(-1，1)<br>
[1,2,3,4,5].slice(1, -1)</p>
<h2 id="答案12345slice1-1">答案：[1,2,3,4,5].slice(1, -1)</h2>
<p><code>slice(1,-1)</code>  slice不会操作原数组，会返回一个新数组 。 表示从索引为0开始截取，-1表示截取到倒数第二个，并将这个新数组返回。</p>
<p><code>replace</code>方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。原字符串不会改变。</p>
<p><code>reverse</code>方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p>
<h1 id="9计算结果">【9.】计算结果</h1>
<pre><code class="language-js">function setname(name){
 this.name = name
}
setname.prototype.printName = function(){ console.log(this.name) }
let a = new setname(&quot;cc&quot;)
a.name = &quot;dd&quot;
a.__proto__.name = &quot;ee&quot;

a.__proto__.printName()  // ?
a.printName() // ?
</code></pre>
<h2 id="答案ee-dd">答案：ee dd</h2>
<p>首先定义了一个函数 setname（）接下来定义了一个方法printname<br>
调用new 方法生成对象传参 “cc” 此时a对象上面的name属性为cc<br>
<img src="https://cutezhangq.github.io/post-images/1597559456328.png" alt="" loading="lazy"><br>
接下来通过a.name修改属性 此时a对象的name属性为 dd<br>
<img src="https://cutezhangq.github.io/post-images/1597559495746.png" alt="" loading="lazy"><br>
最后修改通过a修改构造函数中的属性 --proto--<br>
<img src="https://cutezhangq.github.io/post-images/1597559529281.png" alt="" loading="lazy"></p>
<h1 id="输入">输入</h1>
<pre><code class="language-js">    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    rl.on('line',(line)=&gt;{
      console.log();
    })
</code></pre>
<h1 id="10找出有序数组从小到大排列中和为sum的两个数要求复杂度为on找到一组即可">【10.】找出有序数组（从小到大排列）中和为sum的两个数，要求复杂度为O(n)，找到一组即可</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1597739669645.png" alt="" loading="lazy"></figure>
<p>可以采用<code>暴力枚举</code>,即2层for循环——但是<code>复杂度</code>就不符合了<br>
<strong>从小到大排列</strong>——想起<strong>二分查找</strong>的思想（从数组的第一个查找i；从数组的最后一个查找j）</p>
<pre><code class="language-js">//[1    3   4   6       8]
//13    14  16  18  34  36  46  48  
//10
//头 i
//尾 j
//  1+8 = 9 &lt;10 数组从小到大排列的，需要挪动数组，考虑移动i还是j，因为从小到大排列，所以i++
//  3+8 = 11 &gt;10 比目标值大了，要想办法减小，j--
//  3+6 = 9 &lt;10 进行i++
//  4+6 = 10 = 10 找到了，返回4和6
</code></pre>
<p>答案：</p>
<pre><code class="language-js">   //没找到，i往后走，j往前走
    //javascript(node)运行
    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    const maxLine = 3;
    let input = []; //放数组的
    function solution(input){
      //input[1].split(' ')取出第一个输入的数字，以空格将其分开
      //.map(e =&gt; parseInt(e))将切出的字符串转换为数字
      const arr = input[1].split(' ').map(e =&gt; parseInt(e));  
      //sum拿到数组的最后一项
      const sum = parseInt(input[2]);
      const len = arr.length;
      let i = 0;  //头指针
      let j = len - 1;  //尾指针
      while(i&lt;j){
        let res = arr[i] + arr[j];
        //如果找到了
        if(res === sum) return `${arr[i]} ${arr[j]}`
        //如果没找到
        if(res &lt; sum){
          i++;
        }
        if(res &gt; sum){
          j--;
        }
      }
      return 'notfound' //数组中没找到
    }
    rl.on('line',(line)=&gt;{
      input.push(line);
      if(input.length === maxLine){
        console.log(solution(input));
        rl.close();
      }
    })
</code></pre>
<h1 id="11判断由6种括号组成的字符串是否合法">【11.】判断由&quot;()[]{}&quot;6种括号组成的字符串是否合法</h1>
<ol>
<li>所有括号必须闭合</li>
<li>左括号必须在正确的位置闭合<br>
<img src="https://cutezhangq.github.io/post-images/1597739560221.png" alt="" loading="lazy"></li>
</ol>
<h1 id="12有n级台阶每一步可以走1级或2级问一共有多少种走法">【12.】有n级台阶，每一步可以走1级或2级，问一共有多少种走法</h1>
<p><img src="https://cutezhangq.github.io/post-images/1597739843040.png" alt="" loading="lazy"><br>
答案：</p>
<pre><code class="language-js">   //20 走法(18走法+19走法)
      //18走法 + 2 = 20 或 
      //19走法 + 1 = 20
    //19
      //17 + 2 = 19 或 18 + 1 = 19

    //1
      //1
    //2
      //1 或 2
    //3
      //1走法+2走法
    //...


    //1 2 3 4 ... 18  19  20  ——————后面的走法为前两个走法之 和 ——————斐波那契数列
    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    function solution(step){
      step = parseInt(step);
      function walk(n){
        if(n &lt; 1){    //没有台阶
          return 0
        }
        if(n === 1) return 1; //只有一个台阶
        if(n === 2) return 2;
        return walk(n-1) + walk(n-2);
      }
      return walk(step);
    }
    rl.on('line',(line)=&gt;{
      console.log();
    })
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇淫巧技]]></title>
        <id>https://cutezhangq.github.io/post/qi-yin-qiao-ji/</id>
        <link href="https://cutezhangq.github.io/post/qi-yin-qiao-ji/">
        </link>
        <updated>2020-08-11T01:49:25.000Z</updated>
        <summary type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
<!-- more -->
<h1 id="对数据进行奇偶判断">对数据进行奇偶判断</h1>
<p>普通选手：</p>
<pre><code class="language-js">const n = 11;
if(n%2 == 1){
   console.log('奇数')
}else{
    console.log('偶数')
}
</code></pre>
<p>种子选手：&amp; 位运算符的妙用，相“与”</p>
<pre><code class="language-js">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="判断类型-封装可判断所有类型">判断类型 封装（可判断所有类型）</h1>
<p>普通选手：</p>
<pre><code class="language-js">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>种子选手：<br>
判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。<br>
因此要真正完美判断时，我们需要区分对待:<br>
* 基本类型( null ): 使用String( )，如：String(null)<br>
* 基本类型(string / number / boolean / undefined) + function + symbol: 直接使用 typeof 即可<br>
* 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断，本质上还是调用 valueof 进行判断。</p>
<pre><code class="language-js"> let class2type = {}
  'Array Date RegExp Object Error'.split(' ').forEach(e =&gt; class2type['[object ' + e + ']'] = e.toLowerCase())

  function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[Object.prototype.toString.call(obj)] || 'object' : typeof obj
  }
</code></pre>
<p>这里的.call是绑定this对象指向当前的Object对象<br>
**RegExp：**是正则表达式（regular expression）的简写。</p>
<h1 id="判断是否存在">判断是否存在</h1>
<pre><code class="language-js">  if(typeof a!=&quot;undefined&quot;){     //不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错
      xxx
    }
</code></pre>
<h1 id="检测-某个对象-是不是-另一个对象-的-实例">检测 某个对象 是不是 另一个对象 的 实例</h1>
<p>（测试一个对象在其原型链中是否存在一个构造函数的prototype属性）</p>
<pre><code class="language-js">  function test(){};
  var b = new test();
  var c = new test();
  console.log(b instanceof test); //true   可用来判断一个变量是否是某个对象的实例
  console.log(c == b);  //false
</code></pre>
<h1 id="判断一个-实例-是否属于它的-父类型">判断一个 实例 是否属于它的 父类型</h1>
<p>instanceof 可以在 继承关系 中用来判断一个 实例 是否属于它的 父类型。</p>
<pre><code class="language-js"> var a = new Array();  
 console.log(a instanceof Array);  //true
 console.log(a instanceof Object); //true  因为 Array 是 Object的 子类
</code></pre>
<h1 id="判断-对象是否为空-的三种方法">判断 对象是否为空 的三种方法：</h1>
<pre><code class="language-js">  //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }


  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象


  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
    //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
  t = {};
  if(Object.keys(t).length == 0){
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="apply的使用">.apply（）的使用</h1>
<h2 id="1找出数组最大元素">（1）找出数组最大元素</h2>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>
<pre><code class="language-js">var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
</code></pre>
<h2 id="2将数组的空元素变为undefined">（2）将数组的空元素变为undefined</h2>
<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>
<pre><code class="language-js">Array.apply(null, ['a', ,'b'])
// [ 'a', undefined, 'b' ]
</code></pre>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。<br>
因此，遍历内部元素的时候，会得到不同的结果。</p>
<pre><code class="language-js">var a = ['a', , 'b'];

function print(i) {
console.log(i);
}

a.forEach(print)
// a
// b

Array.apply(null, a).forEach(print)
// a
// undefined
// b
</code></pre>
<h1 id="如何判断是否是数组">如何判断是否是数组？</h1>
<p>es6中加入了新的判断方法：<code>.isArray()</code></p>
<pre><code class="language-js">  value = []
  if (Array.isArray(value)) {
    console.log('是数组')
  } else {
    console.log('NO')
  }
</code></pre>
<p>在考虑兼容性的情况下可以用toString的方法：</p>
<pre><code class="language-js">  if (!Array.isArray) {
    Array.isArray = function (arg) {
      return Object.prototype.toString.call(arg) === '[object Array]'
    }
  }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[slot插槽]]></title>
        <id>https://cutezhangq.github.io/post/slot-cha-cao/</id>
        <link href="https://cutezhangq.github.io/post/slot-cha-cao/">
        </link>
        <updated>2020-08-07T03:04:18.000Z</updated>
        <summary type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
<!-- more -->
<p>由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>两大类。<br>
非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；<br>
插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p>
<h1 id="单个插槽-默认插槽-匿名插槽">单个插槽 | 默认插槽 | 匿名插槽</h1>
<p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。<br>
单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。<br>
下面通过一个例子来展示。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;h3&gt;这里是父组件&lt;/h3&gt;
        &lt;child&gt;
            &lt;div class=&quot;tmpl&quot;&gt;
              &lt;span&gt;菜单1&lt;/span&gt;
              &lt;span&gt;菜单2&lt;/span&gt;
              &lt;span&gt;菜单3&lt;/span&gt;
              &lt;span&gt;菜单4&lt;/span&gt;
              &lt;span&gt;菜单5&lt;/span&gt;
              &lt;span&gt;菜单6&lt;/span&gt;
            &lt;/div&gt;
        &lt;/child&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;child&quot;&gt;
        &lt;h3&gt;这里是子组件&lt;/h3&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p>
<pre><code class="language-html">&lt;div class=&quot;tmpl&quot;&gt;
  &lt;span&gt;菜单1&lt;/span&gt;
  &lt;span&gt;菜单2&lt;/span&gt;
  &lt;span&gt;菜单3&lt;/span&gt;
  &lt;span&gt;菜单4&lt;/span&gt;
  &lt;span&gt;菜单5&lt;/span&gt;
  &lt;span&gt;菜单6&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>最终的渲染结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892088251.png" alt="" loading="lazy"></p>
<h1 id="具名插槽">具名插槽</h1>
<p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个<strong>具名插槽</strong>和<strong>单个插槽</strong>的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;child&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt;
        &lt;span&gt;菜单1&lt;/span&gt;
        &lt;span&gt;菜单2&lt;/span&gt;
        &lt;span&gt;菜单3&lt;/span&gt;
        &lt;span&gt;菜单4&lt;/span&gt;
        &lt;span&gt;菜单5&lt;/span&gt;
        &lt;span&gt;菜单6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt;
        &lt;span&gt;菜单-1&lt;/span&gt;
        &lt;span&gt;菜单-2&lt;/span&gt;
        &lt;span&gt;菜单-3&lt;/span&gt;
        &lt;span&gt;菜单-4&lt;/span&gt;
        &lt;span&gt;菜单-5&lt;/span&gt;
        &lt;span&gt;菜单-6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot;&gt;
        &lt;span&gt;菜单-&gt;1&lt;/span&gt;
        &lt;span&gt;菜单-&gt;2&lt;/span&gt;
        &lt;span&gt;菜单-&gt;3&lt;/span&gt;
        &lt;span&gt;菜单-&gt;4&lt;/span&gt;
        &lt;span&gt;菜单-&gt;5&lt;/span&gt;
        &lt;span&gt;菜单-&gt;6&lt;/span&gt;
      &lt;/div&gt;
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
    // 具名插槽
    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 具名插槽
    &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt;
    // 匿名插槽
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596892200490.png" alt="" loading="lazy"><br>
可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。</p>
<h1 id="作用域插槽-带数据的插槽">作用域插槽 | 带数据的插槽</h1>
<p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p>
<pre><code class="language-cmd">匿名插槽
&lt;slot&gt;&lt;/slot&gt;
具名插槽
&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
</code></pre>
<p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p>
<pre><code class="language-html">&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;
 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    },
}
</code></pre>
<p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p>
<pre><code class="language-cmd">&lt;child&gt;
   html模板
&lt;/child&gt;
</code></pre>
<p>可以说是子组件暴露的一个让父组件传入自定义内容的接口。<br>
写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。<br>
OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？<br>
<code>正因为作用域插槽绑定了一套数据，父组件可以拿来用。</code>于是，情况就变成了这样：<code>样式父组件说了算，但内容可以显示子组件插槽绑定的。</code><br>
我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。<br>
下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;!--第一次使用：用flex展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;div class=&quot;tmpl&quot;&gt;
          &lt;span v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第二次使用：用列表展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第三次使用：直接显示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;              &lt;!--通过slot-scope获取子组件的信息--&gt;
       {{user.data}}
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;
    &lt;child&gt;
      我就是模板
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;

</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;

    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 作用域插槽
    &lt;slot  :data=&quot;data&quot;&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    }
}
</code></pre>
<p>结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892616696.png" alt="" loading="lazy"></p>
<h1 id="slot-scope">slot-scope</h1>
<p><strong>父组件中在使用时：</strong></p>
<ul>
<li>默认插槽的话直接在子组件的标签内写入内容即可</li>
<li>具名插槽是在默认插槽的基础上加上slot属性，值为子组件插槽name属性值</li>
<li>作用域插槽则是通过<code>slot-scope获取子组件的信息</code>，在内容中使用。这里可以用解构语法去直接获取想要的属性</li>
</ul>
<h1 id="v-slot">v-slot</h1>
<pre><code class="language-cmd">在vue2.6中，上述的API被软废弃（3.0正式废弃），取而代之的是内置指令v-slot，可以缩写为【#】
</code></pre>
<p>**子组件用法保持不变，**父组件中</p>
<ul>
<li>slot属性弃用，具名插槽通过指令参数<code>v-slot:插槽名</code>的形式传入，可以简化为 <code>#插槽名。</code></li>
<li><code>slot-scope</code>属性弃用，作用域插槽通过<code>v-slot:xxx=&quot;slotProps&quot;</code>的slotProps来获取子组件传出的属性</li>
<li>v-slot属性只能在 <code>&lt;template&gt;</code>上使用，但在**【只有默认插槽时】**可以在组件标签上使用</li>
</ul>
<pre><code class="language-html">//Parent
&lt;template&gt;
  &lt;child&gt;
   &lt;!--默认插槽--&gt;
   &lt;template v-slot&gt;
     &lt;div&gt;默认插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--具名插槽--&gt;
   &lt;template #header&gt;
     &lt;div&gt;具名插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--作用域插槽--&gt;
   &lt;template #footer=&quot;slotProps&quot;&gt;
     &lt;div&gt;
      {{slotProps.testProps}}
     &lt;/div&gt;
   &lt;/template&gt;
  &lt;child&gt;
&lt;/template&gt;
</code></pre>
<h1 id="拓展用法">拓展用法：</h1>
<ol>
<li>同样可以通过解构获取v-slot={user},<br>
还可以重命名v-slot=&quot;{user: newName}&quot;和定义默认值v-slot=&quot;{user = '默认值'}&quot;</li>
<li>插槽名可以是动态变化的 v-slot:[slotName]</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>默认插槽名为<code>default</code>，可以省略default直接写<code>v-slot</code>，<br>
缩写为#时不能不写参数，写成<code>#default</code>（这点所有指令都一样，v-bind、v-on）</li>
<li>多个插槽混用时，v-slot不能省略default</li>
</ol>
<h1 id="作用域插槽的原理">作用域插槽的原理</h1>
<p>slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过<br>
<code>template &gt;&gt; render function &gt;&gt; VNode &gt;&gt; DOM</code>过程。 组件挂载的本质就是执行渲染函数得到VNode，至于data/props/computed这些属性都是给VNode提供数据来源。<br>
在2.5之前，如果是普通插槽就<strong>直接是VNode</strong>的形式了，而如果是作用域插槽，由于子组件需要在父组件访问子组件的数据，所以父组件下是一个<strong>未执行的函数</strong><code>(slotScope) =&gt; return h('div', slotScope.msg)</code>，接受子组件的slotProps参数，在子组件渲染实例时会调用该函数传入数据。<br>
在2.6之后，两者合并，普通插槽也变成一个函数，只是不接受参数了。</p>
<h1 id="总结">总结</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596938553804.png" alt="" loading="lazy"></figure>
<h1 id="slot的使用场景">slot的使用场景</h1>
<ul>
<li>布局组件、</li>
<li>表格列、</li>
<li>下拉选项</li>
</ul>
<h1 id="slot-scope的使用场景">slot-scope的使用场景</h1>
<p>想象一个场景：<br>
<strong>当你要给同事封装一个列表组件，你就需要使用作用域插槽（注意是列表或者类似列表的组件）</strong><br>
你开发的这个列表组件要如何使用呢？<br>
一般来说作为列表组件的调用者，你的同事先做ajax请求，拿到一个这样的数组</p>
<pre><code class="language-json">   todos: [
        {
          id: 0,
          text: 'ziwei0',
          isComplete: false
        },
        {
          text: 'ziwei1',
          id: 1,
          isComplete: true
        },
        {
          text: 'ziwei2',
          id: 2,
          isComplete: false
        },
        {
          text: 'ziwei3',
          id: 3,
          isComplete: false
        }
      ]
</code></pre>
<p>之后会把todso传递给列表组件吧，那么列表组件内部做什么事情呢？<br>
列表内部肯定会v-for去帮你的同事渲染这个数组嘛。 就类似element-ui里的table组件一样<br>
问题的关键就在这里<br>
<strong>列表组件的循环，是发生在组件内部的，所以通过 v-for=&quot;todo in todos&quot; ,列表组件很容易拿到一项todo，但列表拿到数据没用呀，列表只是一个瓜皮，它又不懂业务逻辑这个数据是你同事的业务数据，</strong><br>
<strong>所以这个数据必须得交给组件的调用者，也就是把数据交给你的同事才对。</strong></p>
<p>那么你怎样才能把每一项的todo数据给传递出去呢？<br>
你会发现没有办法！</p>
<p>无论是用$emit、vuex还是localStorage，可以考虑一下，会发现没有合适的时机，能让你把todo传递出去</p>
<p>所以为了应对这个场景下，发明了<code>作用域插槽</code>，列表组件可以通过<code>&lt;slot :todo=&quot;todo&quot;&gt;&lt;/slot&gt;</code>传递todo出去<br>
你的同事可以通过 slot-scope=&quot;slotsProps&quot;<code>拿到todo</code>。<br>
回答几个疑问，其实如果你看懂上面的问题，应该可以回答下面的问题。这也是我曾经的疑问</p>
<ul>
<li>疑问1：一般不是我们传参数来调用组件吗？为什么组件还把数据传递回来？</li>
</ul>
<pre><code class="language-cmd">的确，调用ui组件时一般是我们传递配置参数给他们。

但是就像elemnt-ui的table组件，你把数组传递给table后，是不是有时候需要拿到某一行的row对象

并根据row对象里的字段，来判断一些内容的显示隐藏？

因为循环的过程发生在table组件内部，所以table组件可以方便的获取到每一项数据，但是这些数据最终不是给组件的，而是我们自己要用的业务数据。所以也需要一个方式，让调用者能拿到自己想要的数据
</code></pre>
<ul>
<li>疑问2： 既然子组件最终还要把我给他的数据，再返还给我，那我当初还干嘛给它，能不能就自己在父组件里玩？</li>
</ul>
<pre><code class="language-cmd">如果你不把数据给子组件当然可以。但是就等于抛弃掉了子组件的封装，只能你直接在父组件自己写一个列表

毕竟你不把数据给子组件，子组件还渲染个锤子？没有父子关系的话，也就不用什么插槽了。

但是咱不是为了封装后，可以复用嘛，总不能永远不用组件嘛
</code></pre>
<ul>
<li>疑问3： 父组件需要子组件的数据？那不会有$emit和vuex嘛，为什么要有slot-scope？</li>
</ul>
<pre><code class="language-cmd">$emit和vuex是数据传递的一种方法，但是你可以尝试用$emit和vuex把todo传递给父组件。

你会发现的确没有合适的钩子、时机来$emit数据
</code></pre>
<h1 id="26新增用法">2.6新增用法</h1>
<h2 id="动态插槽名260新增">动态插槽名(2.6.0新增)</h2>
<p>动态指令参数(需要自己了解)也可以用在v-slot上，来定义动态的插槽名：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<h2 id="具名插槽的缩写260新增">具名插槽的缩写(2.6.0新增)</h2>
<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：<br>
原来是这样写的：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;  
</code></pre>
<p>现在可以这样写：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;
</code></pre>
<p>如果希望使用缩写的话，必须始终以明确插槽名取而代之：</p>
<pre><code class="language-html">&lt;test #default=&quot;{ usertext }&quot;&gt;
  {{ usertext.firstName }}
&lt;/test&gt;
</code></pre>
<h1 id="其他示例">其他示例</h1>
<p>插槽 prop 允许我们将插槽转换为<code>可复用</code>的模板，这些模板可以基于输入的 <code>prop</code>渲染出不同的内容。 这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。<br>
例如，我们要实现一个 <code>&lt;todo-list&gt;</code>组件，它是一个列表且包含布局和过滤逻辑：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>我们可以将每个<code>todo</code>作为父级组件的插槽，以此通过父级组件对其进行控制，然后将<code>todo</code> 作为一个插槽<code>prop</code>进行绑定：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    &lt;!--
    我们为每个 todo 准备了一个插槽，
    将 `todo` 对象作为一个插槽的 prop 传入。
    --&gt;
    &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code>组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code>作为替代方案，并且可以从子组件获取数据：</p>
<pre><code class="language-html">&lt;todo-list v-bind:todos=&quot;todos&quot;&gt;
  &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
&lt;/todo-list&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[computed，watch，method执行的先后顺序]]></title>
        <id>https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/</id>
        <link href="https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/">
        </link>
        <updated>2020-08-06T13:57:16.000Z</updated>
        <summary type="html"><![CDATA[<p>👉他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>👉他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
<!-- more -->
<h1 id="computed">computed：</h1>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<h1 id="methods">methods：</h1>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<h1 id="watch">watch：</h1>
<p>是一种更通用的方式来观察和响应 Vue 实例上的数据变动。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
<p>通俗来讲，</p>
<p>computed是在HTML DOM加载后马上执行的，如赋值；</p>
<p>而methods则必须要有一定的触发条件才能执行，如点击事件；</p>
<p>watch呢？它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。</p>
<p>所以他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
<p>下面的例子可以做为说明。</p>
<p>computed 属性 vs watched 属性：Vue 确实提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：watch 属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的想法是使用 computed 属性而不是命令式的 watch 回调。</p>
<h1 id="computed与watch的区别">computed与watch的区别</h1>
<p>在很多情况下, computed会比watch使用起来更加方便,但是当需要在数据变化时执行异步或者开销比较大的情况下,用watch会更加合适。<br>
例如官网提供的例子(问与答。watch观察question的值,若值有改变会执行方法getAnswer,并且根据question不同的值, answer会给出不同的回答,并且会异步调用API返回相应的值,这些都是计算属性做不到的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>目的</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>computed</td>
<td>依赖变动实时更新数据</td>
<td>更新数据</td>
</tr>
<tr>
<td>watch</td>
<td>观察某一特定的值，执行特定的函数</td>
<td>观察数据</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">&lt;divid=&quot;demo&quot;&gt;{{ fullName }}&lt;/div&gt;

使用watch方法观察数据（单个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar',
fullName: 'Foo Bar'
},
watch: {
firstName: function (val) {
this.fullName = val + ' ' + this.lastName
},
lastName: function (val) {
this.fullName = this.firstName + ' ' + val
}
}
})

使用computed方法计算数据（多个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar'
},
computed: {
fullName: function () {
return this.firstName + ' ' + this.lastName
}
}
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON.stringify与"环"问题]]></title>
        <id>https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/</id>
        <link href="https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/">
        </link>
        <updated>2020-08-06T10:50:32.000Z</updated>
        <summary type="html"><![CDATA[<p>JSON.stringify在解析接口数据时，我们经常使用到，那么它为什么会产生“环“呢，啥是”环“和？😨<br>
🙄博主酱的脑海中一堆问号，赶快来了解下了！</p>
]]></summary>
        <content type="html"><![CDATA[<p>JSON.stringify在解析接口数据时，我们经常使用到，那么它为什么会产生“环“呢，啥是”环“和？😨<br>
🙄博主酱的脑海中一堆问号，赶快来了解下了！</p>
<!-- more -->
<p>JSON.stringify的功能是，将一个js字面量对象转化为一个JSON格式的字符串，例如：</p>
<pre><code class="language-js">const obj = {a:1,b:2}
JSON.stringify(obj)     //  ‘ {“a”:1,“b”:2}’
</code></pre>
<!-- more -->
<p>当要转化的对象有**“环”**存在时（<strong>子节点属性赋值了父节点的引用</strong>），为了避免死循环，JSON.stringify 会抛出异常，例如：</p>
<pre><code class="language-js">const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
JSON.stringify(obj) // =&gt; TypeError: Converting circular structure to JSON 类型错误:将循环结构转换为JSON
</code></pre>
<p>请完善以下“环”检查器函数 cycleDetector，当入参对象中有环时返回 true，否则返回 false。</p>
<pre><code class="language-js">function cycleDetector(obj) {   
  // 请添加代码
}
</code></pre>
<p>“环”的形成是因为对象的子节点属性赋值了父节点的引用，所以我们需要记录下父节点的地址，然后再拿其子节点的属性与之前记录下的父节点地址做一个比较，当结果一致时，就形成了“环”。</p>
<p>那么，在“环”检测器函数中，我们首先需要遍历这个对象的属性，前面提到了引用，那么我们只需对Object类型的属性进行处理即可（简单数据类型不存在引用关系）。对于Objcet类型的属性，我们先与记录下来的父节点地址做一个对比，如无匹配项，将当前属性地址记录下来，然后遍历其子节点属性，一层一层找下去。下面开始上代码：</p>
<pre><code class="language-js">function cycleDetector(obj){
    var hasCircle = false,  //  定义一个变量，标志是否有环
    cache = [];          //  定义一个数组，来保存对象类型的属性值
    (function(obj){
        var keys = Object.keys(obj);    //获取当前对象的属性数组——key是获取属性
             for (var i = 0; i &lt; keys.length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (typeof value == 'object' &amp;&amp; value !== null) {
                var index = cache.indexOf(value)
                if (index !== -1) {
                    hasCircle = true
                    break
                } else {
                    cache.push(value)
                    arguments.callee(value)
                    cache.pop()      //  注意：这里要推出数据，因为递归返回，后面遍历的属性不是这个数据的子属性
                }
            }
        }
    })(obj)
}

</code></pre>
<p>补充：<br>
<strong>Object.keys</strong> 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。<br>
<strong>测试用例</strong></p>
<pre><code class="language-js">/* 测试一 */

const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
</code></pre>
<pre><code class="language-js">/* 测试二 */

var obj = {
    foo: {
        name: 'foo',
        bar: {
            name: 'bar',
            baz: {
                name: 'baz',
                aChild: null
            }
        }
    },
    aaa: {
        name: &quot;test&quot;,
        bbb: null
    }
}
obj.aaa.bbb = obj.foo;   //  aaa-&gt;bbb-&gt;bar-&gt;baz-&gt;aChild-&gt;null 不形成环
</code></pre>
]]></content>
    </entry>
</feed>