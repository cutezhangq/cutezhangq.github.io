<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-07-24T03:26:27.745Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[笔试题]]></title>
        <id>https://cutezhangq.github.io/post/bi-shi-ti/</id>
        <link href="https://cutezhangq.github.io/post/bi-shi-ti/">
        </link>
        <updated>2020-07-15T15:04:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="q标准盒子模型与ie怪异盒子模型">Q：标准盒子模型与IE怪异盒子模型</h1>
<p>这个问题主要会出现在笔试题上面，比如：</p>
<pre><code class="language-javascript">&lt;div style=&quot;width:100px;height=&quot;100px;border:10px;padding:10px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这个盒子在w3c标准盒子模型和IE的怪异盒子模型下面它的宽度分别是多少？</p>
<pre><code class="language-javascript">标准盒子模型：总宽度=content100px+border 10px*2+padding 10px*2 //140px
怪异盒子模型: 总宽度=content60px+ border 10px*2+padding 10px*2 //100px
</code></pre>
<p>怪异盒子：box-sizing：border-box将div的width就是width赋值的宽<br>
标准盒子：宽度为width的宽加上border和padding</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js重点整理复习]]></title>
        <id>https://cutezhangq.github.io/post/js/</id>
        <link href="https://cutezhangq.github.io/post/js/">
        </link>
        <updated>2020-06-16T06:05:13.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
<!-- more -->
<p>当然有些可以合并，引用类型部分也可以归为Object类型一种，故也称7种数据类型（5+1+1）<br>
其中，基本数据类型存储的是实际数据的值；引用数据类型存储的是数据的引用（引用存储在<code>栈</code>里，实际内容存储在<code>堆</code>里）<br>
那么，为啥要分几种不同的数据类型呢？因为我们最终的目的是要使用数据来搞事情~😀，面对庞大的数据必然有许多重复，如果不分类的存储不然会造成混乱。这就需要我们对数据进行分类存储了。</p>
<!-- more -->
<ul>
<li>
<p>有的数据是直接存储起来，用的时候直接使用就行了，不需要对数据进行改变，这种类型的往往比较简单，所以统称为<strong>基本数据类型</strong>。</p>
</li>
<li>
<p>有的数据存储了之后，再进行使用需要对数据进行改动，可以原始数据就进行改动，也可只对引用的数据进行改动，这种情况就比较复杂了，所以对数据的结构就分出来栈和堆，栈中的数据指向堆中最终存储的数据。这种统称为<strong>引用数据类型</strong>。</p>
</li>
</ul>
<p>🔶局部变量存放在<code>栈</code>中(该方法中声明的变量随着栈的销毁而结束，局部变量只能在方法中有效)；<br>
🔷全局变量存放在<code>堆</code>中(不会随着某个方法执行结束而销毁)</p>
<!-- more -->
<p>那么分好了存储，接下来还要👊使用数据，一般是定义变量来使用存储的数据。但是因为存储类型不同，所以在使用<code>变量</code>定义数据是也有不同的特性(变量的类型是根据其内部存储的数据类型来决定的)：</p>
<ul>
<li>基本变量类型：一个变量要复制另一个变量时，采用 <code>深拷贝</code> ，会开辟一块新的内存空间进行存储，所以数据改变不影响原始数据。变量存放的就是数据值。</li>
<li>引用变量类型：给变量添加属性，采用 点 的方式。一个变量复制引用类型时，采用 <code>浅拷贝</code> ，所以数据改变会影响原数据的值。变量存放的是数据的引用（指针）。</li>
</ul>
<h1 id="不同数据类型之间的运算及比较">不同数据类型之间的运算及比较</h1>
<h2 id="和-的区别">=== 和 == 的区别</h2>
<p>===这种先比较数据的类型，再比较数据的值。<strong>类型</strong>和<strong>值</strong>要完全一样才相等。（不转换类型）<br>
==这种比较值，当类型不同，可先进行转换，<strong>转换完</strong>再比较<strong>值</strong>。<br>
注：==中转换情况如下几种情况：</p>
<ul>
<li><strong>String和Number</strong>：将String按照ASCII转换为数字再进行比较。</li>
<li><strong>Undefined和Null</strong>：这两个实际的值都是false，它们==是<strong>相等</strong>的。</li>
<li><strong>NaN</strong>：只能使用isNaN来检测类型。</li>
<li><strong>boolean与其他类型</strong>：boolean先转为 0 或 1 再进行比较。</li>
<li>如果是<strong>对象和数字比较</strong>：会将对象先转换为基础数据类型。js中🙆一般valueof优先于tostring类型，采用valueof内置类进行转换，🤷‍♀但在data中是tostring采用转换。</li>
</ul>
<p>😃注：即基本的数据类型间比较时，都是转为数字进行比较（ASCII码转）；涉及到对象这种引用变量时，则是转换为字符串进行比较。</p>
<h2 id="不同数据类型间运算">不同数据类型间运算</h2>
<ul>
<li>执行<code>- 、*、/、%</code> 运算时，都转换为数字进行运算。</li>
<li>执行<code>+</code>运算时，分为几种情况：
<ul>
<li>number + String --&gt;String</li>
<li>number + object --&gt;String ，优先调用tostring转换了
<ul>
<li>如：[1].toString() === '1'</li>
<li>如：{}.toString() === '[object Object]'</li>
</ul>
</li>
<li>number + null/boolean --&gt; <strong>数字</strong></li>
<li>number + undefined --&gt; <strong>NaN</strong></li>
</ul>
</li>
</ul>
<h2 id="和-和">&amp;&amp;和||、&amp;和|</h2>
<p>&amp;&amp;和||是逻辑运算符。</p>
<ul>
<li>
<p>&amp;&amp;表示逻辑与，当左边为真时，才执行右边；左边为假，不执行右边。（会短路）</p>
</li>
<li>
<p>| | 表示逻辑或，当左边为真时，执行左边；左边为假，执行右边。<br>
&amp;和|是位运算符。</p>
</li>
<li>
<p>&amp;表示与运算，转换为二进制逐位进行比较，相同位为1，不同位为0，最后输出的二进制再转为十进制输出最后结果。</p>
</li>
<li>
<p>| 表示或运算，转换为二进制逐位进行比较，只要位上有1就为1，位上都为0则为0，最后输出的二进制再转为十进制输出最后结果。<br>
注：&amp;还可以用来判断 奇偶:</p>
</li>
</ul>
<pre><code class="language-javascript">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="数据类型的判断">数据类型的判断</h1>
<p>👉基本数据类型中<strong>null</strong>：采用 <code>String（）</code> 判断<br>
👉<strong>基本数据类型</strong>中除了null的：采用 <code>typeof()</code> 判断<br>
👉<strong>引用数据类型</strong> 中如object、array、Data等：采用 <code>toString()</code> 判断<br>
一种很稳的判断数据类型方法：💖</p>
<pre><code class="language-javascript">let class2type = {};
'Array Date RegExp Object Error'.splice('').forEach(e =&gt; class2type['[object'+e+']'] = e.toLowerCase())
function type(obj){
    if(obj == null){
        return String(obj)
    }
    return typeof obj ==='object'?  class2type[Object.prototype.toString.call(obj)] || 'object': typeof(obj)
}
</code></pre>
<h1 id="如何判断一个变量是对象还是数组">如何判断一个变量是对象还是数组</h1>
<p>判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。</p>
<pre><code class="language-javascript">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>ps：千万不能使用typeof来判断对象和数组，因为这两种类型都会返回&quot;object&quot;。</p>
<h2 id="判断对象为空的3中方法">判断对象为空的3中方法</h2>
<ul>
<li>JSON.stringify(obj) == ‘{}’</li>
<li>for(var a in obj) == true</li>
<li>Object.keys(obj).length() == 0<br>
具体如下：</li>
</ul>
<pre><code class="language-javascript"> //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }

  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象

  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
  t = {};
  if(Object.keys(t).length == 0){   //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="不同数据类型的保存">不同数据类型的保存</h1>
<ul>
<li>基本数据类型：保存在 <code>堆</code>中</li>
<li>引用数据类型：保存在<code>栈</code>中</li>
<li>变量：可能是基本数据也可能是地址值。</li>
</ul>
<h1 id="内存-变量的生命周期">内存、变量的生命周期</h1>
<p>内存：是内存条通电后产生的一定的存储空间。<br>
变量的生命周期：当js引擎访问变量的时候，要经历：变量声明===》变量初始化===》变量赋值<br>
经历从 产生 到 销毁 的过程。<br>
🌰举例：<br>
<code>var</code>变量的生命周期：其中<strong>变量声明</strong>和<strong>变量初始化</strong>这2个阶段没有间隙，<br>
<code>函数声明</code>的生命周期：<strong>变量声明</strong>和<strong>变量初始化</strong>和<strong>变量赋值</strong>这3个阶段没有间隙，<br>
<code>let</code>:变量的生命周期：每段都有间隙，其中<strong>变量声明</strong>和<strong>变量初始化</strong>之间还有<strong>暂时性死区</strong></p>
<h2 id="为什么-提升-在let的生命周期里无效">为什么 提升 在let的生命周期里无效？</h2>
<p><code>提升：就是变量在作用域顶部进行 声明和初始化。</code><br>
因为let中每个阶段都有间隙，<strong>变量声明</strong>和<strong>变量初始化</strong>是解耦的（解耦让提升这个术语失效了），还存在暂时性死区，在这里，变量不能被访问。</p>
<h2 id="new的执行过程">new的执行过程</h2>
<p>1.创建一个对象<br>
2.将对象挂载到原型上<code>obj.__proto__ = Con.prototype</code><br>
3.this的指向<br>
4.返回新对象(如果构造函数有自己 retrun 时，则返回该值)</p>
<h1 id="对象">对象</h1>
<h2 id="访问对象内部数据的方法">访问对象内部数据的方法</h2>
<p>当访问json数据内部值时，一般采用 <code>点</code>的形式；当访问数组中数据时，一般采用<code>[ ]</code>的形式。<br>
其中，<strong>必须</strong>采用<code>[ ]</code>形式的情况有：属性中有特殊字符，如 - 空格 等的，有关键字的，是未定义的属性的。其余的都可采用这2中方式。</p>
<h2 id="创建对象的四种方法">创建对象的四种方法</h2>
<pre><code class="language-javascript">//1.采用系统的构造函数
var obj = new Object();
obj.name = 'zq';
obj.age = 20;
console.log(obj.name+','+obj.age);//zq,20

//2.自定义构造函数
function stu(name,age){
  this.name = name;
  this.age = age;
  this.mmm = 'koko';  //都是this.的形式，此处的this指代stu对象
  console.log(this.name+','+this.age);  //pk,22
}
var p1 = new stu('pk',22);  
console.log(p1.mmm);  //koko

//3.字面量形式
var tea = {
  name:'bobo',
  age:50,
  say:function(){
    console.log('hello js');
  }
}
console.log(tea.name);  //bobo
tea.say();  //hello js

//4.工厂模式    类似于封装了 系统的构造函数，批量生产对象
function createObject(name,age){
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  return obj; //别忘了返回
} 
var stu1 = createObject('stu1',12);
var stu2 = createObject('stu2',13);
console.log(stu1.name+','+stu1.age);//stu1,12
console.log(stu2.name+','+stu2.age);//stu2,13
</code></pre>
<h1 id="函数">函数</h1>
<h2 id="几种常见的回调函数">几种常见的回调函数</h2>
<p>👉dom中的回调函数</p>
<pre><code class="language-javascript"> //1.dom中时间回调函数，包括Node.js中的
  document.getElementById('btn').onclick = function(){
    console.log('诶呀，被点了!');
  }//诶呀，被点了!
</code></pre>
<p>👉定时器</p>
<pre><code class="language-javascript"> //2.定时器
  setTimeout(function(){
    console.log('我是一个定时器');
  },2000)
  console.log('——————');  
  //——————
  //我是一个定时器
</code></pre>
<p>👉ajax请求中的回调函数（包括promise）</p>
<pre><code class="language-javascript">  $.ajax({
    url:'xxx',
    type:'get',
    data:data,
    success:function(data){
      console.log(data);
    }
  })
</code></pre>
<p>👉生命周期中的回调函数</p>
<pre><code class="language-javascript">//如vue中的

</code></pre>
<h2 id="钩子函数和回调函数">钩子函数和回调函数</h2>
<p>两者都是事件处理函数，不同的是：<br>
<strong>钩子函数</strong>：函数<code>调用时触发</code>，本质上是监听函数。<br>
<strong>回调函数</strong>：函数调用<code>结束时触发</code>。</p>
<h2 id="iife">IIFE</h2>
<p>立即调用函数<br>
形式：<code>( 匿名函数自调用 )( )</code>        或者       <code>( 匿名函数自调用 )(参数)</code><br>
作用：</p>
<ul>
<li>隐藏内部内容代码</li>
<li>防止污染全局（外部）命名空间</li>
<li>进行js编码</li>
<li>解决闭包问题（闭包中变量一直无法释放，占用内存）</li>
</ul>
<p>其他几种也是立即执行函数</p>
<pre><code class="language-javascript">(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) () //用括号把函数包起来
!function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()
</code></pre>
<h2 id="函数声明与函数表达式">函数声明与函数表达式</h2>
<p>一、所能放置的 **位置 ** 不同<br>
函数声明：由于有<code>函数提升</code>，所以可以在任意地方声明</p>
<pre><code class="language-javascript">  fnName();
  //函数声明
  function fnName() { 
  }
  //正常，因为‘提升’了函数声明，函数调用可在函数声明之前
</code></pre>
<pre><code class="language-javascript">var fnName = function () {     
    alert('11');
  }();
    //函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数
</code></pre>
<p>二、是否 可以<strong>进行函数立即调用</strong></p>
<ul>
<li>函数声明不可以，只能以fnName()形式调用 。</li>
<li>函数表达式后面可以加括号立即调用该函数。</li>
</ul>
<h1 id="原型">原型</h1>
<h1 id="数组">数组</h1>
<h2 id="q如何对一个数组去重">Q：如何对一个数组去重？</h2>
<pre><code class="language-javascript">//1、Set结构去重。
let set = new Set([1,2,3,4,3,2,1,6,'1',NaN,NaN]);
console.log(set);
//Set(6)
// 0: 1
// 1: 2
// 2: 3
// 3: 4
// 4: 6
// 5: &quot;1&quot;
//6: NaN

//2、遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果。
let a = ['1','2','3',1,NaN,NaN,undefined,undefined,null,null, 'a','b','b'];
  let unique = arr =&gt;{
    let newA = [];
    arr.forEach(key =&gt; {
      if(newA.indexOf(key)&lt;0){  //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步
        newA.push(key);
      }
    });
    return newA;
  }
  console.log(unique(a)) ;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;]
  //ps:这个方法不能分辨NaN,会出现两个NaN。是有问题的，下面那个方法好一点。

  //3、遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，
  //以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。
//注意：这个方法会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想想还是Set去重最简单也最有效。
  let b = ['1', '2', '3', 1,NaN,NaN,undefined,undefined,null,null, 'a', 'b', 'b'];
  const unique2 = arr =&gt; {
        var obj = {}
        arr.forEach(value =&gt; {
            obj[value] = 0;//这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去
        })
        return Object.keys(obj);//`Object.keys(对象)`返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组
    }
    console.log(unique2(b));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue知识点理解]]></title>
        <id>https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/</id>
        <link href="https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/">
        </link>
        <updated>2020-05-13T08:07:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模板字符串的前世今生">模板字符串的前世今生</h1>
<h2 id="js">JS</h2>
<p>js中，输出模板是这样写的。通过<code>字符串</code>拼接</p>
<pre><code class="language-js">$('#result').append(
 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' +
 'items in your basket, ' +
 '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'
);
</code></pre>
<h2 id="es6">es6</h2>
<p>es6中，输出模板是这样写的。通过<code>${ }嵌入变量</code></p>
<pre><code class="language-js">$('#result').append(`
    There are &lt;b&gt;${basket.count}&lt;/b&gt; items
    in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
    are on sale!
`);
</code></pre>
<h2 id="vue">Vue</h2>
<p>Vue中，输出模板是这样写的。</p>
<pre><code class="language-js">new Vue({
     el:'#replace',
    template:'&lt;p&gt;字符串模板&lt;/p&gt;'
})
</code></pre>
<h2 id="vue20模板的三种写法">Vue2.0模板的三种写法</h2>
<h3 id="第一种利用模板字符串">第一种：利用模板字符串</h3>
<pre><code class="language-js">&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
        el:&quot;#app&quot;,
        data:{ },
        template:`&lt;h1 style=&quot;color:red&quot;&gt;第一种写法&lt;/h1&gt;`
    })
&lt;/script&gt;
</code></pre>
<h3 id="第二种利用template标签实现内容填充通过-id-或者其他的选择器挂载到template上">第二种：利用template标签实现内容填充,通过 id 或者其他的选择器挂载到template上</h3>
<p>通过 id,挂载到template上</p>
<pre><code class="language-js">&lt;template id=&quot;template&quot;&gt;
    &lt;h1&gt;11&lt;/h1&gt;
&lt;/template&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
    ...
    template:&quot;#template&quot;
})
&lt;/script&gt;
</code></pre>
<h3 id="改变script中的type变为typex-template给它id最终挂载到template中">改变script中的type.变为type=&quot;x-template&quot;,给它id,最终挂载到template中</h3>
<p>使用于内容比较多或有公共的模板,可以使用,引入就可以<br>
type=&quot;x-template&quot;，给它id</p>
<pre><code class="language-js">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;x-template&quot; id=&quot;template&quot;&gt;
    &lt;h2&gt;11&lt;/h2&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var app=new Vue({
     ...
    template:&quot;#template&quot;
})
</code></pre>
<h2 id="vue30模板的写法">Vue3.0模板的写法</h2>
<pre><code class="language-js">import Vue from 'vue'
import App from './App.vue'
new Vue({
   ...
    render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue注意点]]></title>
        <id>https://cutezhangq.github.io/post/vue/</id>
        <link href="https://cutezhangq.github.io/post/vue/">
        </link>
        <updated>2020-05-13T07:55:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="注意点">注意点</h1>
<h2 id="路由动画">路由动画</h2>
<p>💥出现问题：动画滑动时，最上面的header元素没有置顶，导致最后动画完成时突然向上移动。<br>
✔️解决：</p>
<pre><code class="language-html">&lt;transition :name=&quot;transitionName&quot;&gt;
    &lt;router-view :Event_Play=&quot;Event_Play&quot; class=&quot;transitionBody&quot;&gt;&lt;router-view&gt;
&lt;/transition&gt;
&lt;style lang=&quot;less&quot;&gt;
.transitionBody {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
 }
 &lt;/style&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题]]></title>
        <id>https://cutezhangq.github.io/post/interview-question/</id>
        <link href="https://cutezhangq.github.io/post/interview-question/">
        </link>
        <updated>2020-04-01T01:22:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第-1-题滴滴-饿了么写-react-vue-项目时为什么要在列表组件中写-key其作用是什么">第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h1>
<p>😅emm..对这个问题有过疑问，但是一直没有探寻原因，现在梳理一下</p>
<h2 id="答案"><strong>答案</strong></h2>
<p>首先在vue循环遍历生成节点中会使用到key，那么到底要不要使用key，参考官网上的描述：<br>
📃VUE文档:</p>
<ul>
<li>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</li>
</ul>
<p>得出结论，多数情况最好使用key!</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;i in dataList&quot; :key=&quot;i&quot;&gt;{{ i }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>key是用来<code>绑定</code>虚拟节点的，给每一个vnode<code>唯一</code>id。<br>
当不使用key的时候，也可以通过v-for实现以下的dom节点数组<br>
🌰 案例：</p>
<pre><code class="language-js">var vm = new Vue({
  el: '#app',
  data: {
    dataList: [1, 2, 3, 4, 5]
  }
})
</code></pre>
<p>为了方便，标记上id加以说明节点。当数组为[1, 2, 3, 4, 5]时，加key与不加key都如下：</p>
<pre><code class="language-html"> [
    '&lt;div&gt;1&lt;/div&gt;',     // id:  A
    '&lt;div&gt;2&lt;/div&gt;',     // id:  B
    '&lt;div&gt;3&lt;/div&gt;',     // id:  C
    '&lt;div&gt;4&lt;/div&gt;',     // id:  D
    '&lt;div&gt;5&lt;/div&gt;'      // id:  E
  ]
</code></pre>
<p>但是，当数组有变化时，两者就有区别了。<br>
改变dataList数据，进行数据位置替换，对比改变后的数据如下：</p>
<pre><code class="language-javascript"> vm.dataList = [4, 1, 3, 5, 2] // 数据位置替换
 // 没有key的情况， 节点位置不变，但是节点innerText内容更新了
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： A
    '&lt;div&gt;1&lt;/div&gt;', // id:  B
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  D
    '&lt;div&gt;2&lt;/div&gt;'  // id:  E
  ]

  // 有key的情况，dom节点位置进行了交换，但是内容没有更新
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： D
    '&lt;div&gt;1&lt;/div&gt;', // id:  A
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;2&lt;/div&gt;'  // id:  B
  ]
</code></pre>
<p>原因：<code>没有绑定key的情况下，节点会进行复用</code>，即呈现出id没变，内容变化了（<code>就地更新</code>），这样<code>有利于diff速度</code>，但是这种模式会带来一些隐藏的副作用。可能不会产生过渡的效果，某些节点绑定数据（表单）状态时，会出现状态错位。没办法追踪到每个节点。<br>
使用key可以：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<pre><code class="language-html">&lt;transition&gt;
  &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;
&lt;/transition&gt;
</code></pre>
<p>当 text 发生改变时，span总是会被替换而不是被修改，因此会触发过渡。</p>
<p>📃VUE文档也说明了</p>
<ul>
<li>不加key时，<a href="https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81">这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</a></li>
</ul>
<p>增删dataList列表项，对比改变后的数据如下：</p>
<pre><code class="language-html">vm.dataList = [3, 4, 5, 6, 7] // 数据进行增删
  // 1. 没有key的情况， 节点位置不变，内容也更新了
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： A
    '&lt;div&gt;4&lt;/div&gt;', // id:  B
    '&lt;div&gt;5&lt;/div&gt;', // id:  C
    '&lt;div&gt;6&lt;/div&gt;', // id:  D
    '&lt;div&gt;7&lt;/div&gt;'  // id:  E
  ]

  // 2. 有key的情况， 节点删除了 A, B 节点，新增了 F, G 节点
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： C
    '&lt;div&gt;4&lt;/div&gt;', // id:  D
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;6&lt;/div&gt;', // id:  F
    '&lt;div&gt;7&lt;/div&gt;'  // id:  G
  ]
</code></pre>
<p>key是给每一个vnode的唯一id,可以依靠key,<code>更准确</code>, <code>更快</code>的拿到oldVnode中对应的vnode节点。<br>
更快 体现在：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。</p>
<h2 id="扩展"><strong>扩展</strong>：</h2>
<h3 id="diff算法">diff算法</h3>
<h3 id="vue源码">vue源码</h3>
<h1 id="第-2-题1-2-3mapparseint-what-why">第 2 题：['1', '2', '3'].map(parseInt) what &amp; why ?</h1>
<p>emm..map是es6中涉及到的方法，是指不重复的Key-value形式的数据，parseInt是....返回整数的，然并卵...orz🤒</p>
<h2 id="答案-2"><strong>答案</strong></h2>
<p>真正的答案是[1, NaN, NaN]<br>
这题的主要考察，还是arr.map（）方法，和parseInt，对它们一定要深入理解。下面附上MDN官方解释：<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()</a></li>
</ul>
<pre><code class="language-javascript">    var new_array = arr.map(function callback(currentValue[, index[, array]]) {     }[, thisArg])
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585987454821.png" alt="" width="400" height="300" loading="lazy"></figure>
<h3 id="map方法定义">map方法定义</h3>
<p>将数组中的值按顺序调用callback函数，然后由callback返回的数按顺序组成新数组；没有赋值或删除掉的索引不会调用。</p>
<h3 id="map方法使用">map方法使用</h3>
<p>map方法针对<code>新数组</code>的，<code>不会修改原数组</code>，若是对原数组进行操作则使用for-of或forEach。<br>
callback 函数会被自动传入三个参数：<code>数组元素</code>，<code>元素索引</code>，<code>原数组本身</code>。</p>
<p>🙄其实这里主要难度是parseInt，下面一起来研究下叭~<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a></li>
</ul>
<pre><code class="language-javascript">parseInt(string, radix);
</code></pre>
<p>将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。</p>
<h1 id="3原生js使用vuejs时的闪现问题">[3.]原生js使用vue.js时的闪现问题</h1>
<p>原生js中在使用到vue.js时，如使用<code>{{}}</code>会出现闪现问题，会先变成<code>{{message}}</code>显示在页面上，然后再变成需要显示的值。<br>
闪现问题是如何产生的？<br>
因为代码的执行顺序，先编译（编译template代码），再进行数据绑定。<br>
解决办法（2种）避免FOUC (Flash of Uncompiled Content)</p>
<h2 id="v-cloak">v-cloak</h2>
<p><code>v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。</code></p>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
    [v-cloak] {
      display: none;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;方法一: v-cloak&lt;/p&gt;
  &lt;!-- 页面加载数据时，原始代码会闪现一下
  加入一段css代码，在view上引用css模块 --&gt;
  &lt;!-- v-cloak 这个指令保持在元素上直到关联实例结束编译。 v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。--&gt;
  &lt;div id=&quot;app&quot; v-cloak&gt;    &lt;!-- &lt;div&gt; 不会显示，直到编译结束。--&gt;
    &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
    &lt;!-- 双括号会被编译成textNode的一个v-text指令 --&gt;
  &lt;/div&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
</code></pre>
<h2 id="v-text-取代">v-text 取代 {{}}</h2>
<pre><code class="language-html">&lt;body&gt;
    &lt;p&gt;方法二: v-text&lt;/p&gt;
    &lt;h1 v-text=&quot;message&quot;&gt;&lt;/h1&gt;
    &lt;h1 v-text=&quot;name&quot;&gt;&lt;/h1&gt;
  &lt;/div&gt;
    &lt;!-- vue中我们会将数据包在两个大括号中，然后放到HTML里，但是在vue内部，所有的双括号会被编译成textNode的一个v-text指令。
  而使用v-text的好处就是永远更好的性能，更重要的是可以避免FOUC (Flash of Uncompiled Content) ，也就是上面与遇到的问题。 --&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h1 id="4v-if-与-v-show">[4.]v-if 与 v-show</h1>
<p>区别：v-if 的那段代码为false就不编译了，为true才编译；而 v-show 的代码是一定会编译的<br>
使用场景：v-show用于标签切换更频繁的地方，v-if用于初始进行判断是否编译</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://cutezhangq.github.io/post/git/</id>
        <link href="https://cutezhangq.github.io/post/git/">
        </link>
        <updated>2020-03-22T06:51:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="定义">定义</h1>
<p>是一个分布式版本控制工具（系统）。</p>
<h1 id="git特点">Git特点</h1>
<p>1.尽可能添加数据而不是删除或修改数据，存储能力强，容易备份</p>
<p>2.完整性保证（对于每次提交做Hash的操作）</p>
<p>3.与linux命令全面兼容</p>
<p>4.良好性能，支持离线（在本地完成）</p>
<p>5.制定工作流</p>
<p>6.分布式仓库</p>
<h1 id="git官网">Git官网</h1>
<p><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<h1 id="git三种状态三个逻辑区域">Git三种状态,三个逻辑区域</h1>
<h2 id="三种状态">三种状态</h2>
<ul>
<li>
<p>modified(已修改)</p>
</li>
<li>
<p>staged(已暂存)</p>
</li>
<li>
<p>committed(已提交)</p>
</li>
</ul>
<h2 id="三种分区">三种分区</h2>
<p>git分为：<code>工作区</code>，<code>暂存区</code>，<code>本地库</code>，<code>远程区</code>  四块大区域</p>
<h2 id="对应关系">对应关系</h2>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585704345724.jpg" alt="" loading="lazy"></figure>
<h1 id="git文件内容结构">.Git文件内容结构</h1>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1585704336057.png" alt="" loading="lazy"></figure>
<h1 id="git命令">Git命令</h1>
<h2 id="搭建git仓库">搭建Git仓库</h2>
<h3 id="两种场景">两种场景：</h3>
<p>使用<code>init</code>初始化，将本地的目录变成git<code>本地仓库</code></p>
<ul>
<li>1.已有项目，将项目纳入Git管理</li>
</ul>
<pre><code class="language-cmd">cd 项目所在文件夹
git init
</code></pre>
<ul>
<li>2.没有项目，新建用Git管理的项目</li>
</ul>
<pre><code class="language-cmd">cd 项目所在文件夹
git init your_project   #会在当前路径下创建和项目名称同名的文件夹
</code></pre>
<h3 id="查看本地目录的状态">查看本地目录的状态</h3>
<pre><code class="language-cmd">git status
</code></pre>
<h3 id="本地仓库与远程仓库关联">本地仓库与远程仓库关联</h3>
<p>与<code>远程仓库</code>关联，（此前已在码云等上注册远程仓库）</p>
<pre><code class="language-cmd">git add origin 远程仓库地址
</code></pre>
<hr>
<h2 id="更新项目">更新项目</h2>
<p>准备上传你的项目之前，最好更新一下项目，确保没有和远程仓库的代码有<code>冲突</code></p>
<pre><code class="language-cmd">git pull --rebase origin master
</code></pre>
<hr>
<h2 id="提交项目">提交项目</h2>
<pre><code class="language-cmd">git add .           #添加目录下所有发生改变的文件
git commit -m           #'注释信息'
git push -u origin master       #本地仓库代码提交至远程仓库(有时候会提交失败，可以尝试git push -u origin master -f 强制提交,只建议在第一次提交中使用)
</code></pre>
<hr>
<h2 id="克隆项目">克隆项目</h2>
<pre><code class="language-cmd">git clone 远程仓库地址
</code></pre>
<hr>
<h2 id="分支相关命令">分支相关命令</h2>
<ul>
<li>查看所有分支</li>
</ul>
<pre><code class="language-cmd">git branch  -a
</code></pre>
<ul>
<li>创建分支</li>
</ul>
<pre><code class="language-cmd">git branch 分支名
</code></pre>
<ul>
<li>切换到某一分支</li>
</ul>
<pre><code class="language-cmd">git checkout  分支名
</code></pre>
<ul>
<li><code>合并分支</code></li>
</ul>
<pre><code class="language-cmd">git merge 分支名
</code></pre>
<ul>
<li><code>创建远程的分支,并且把本地分支推送到远程分支上</code></li>
</ul>
<pre><code class="language-cmd">git push origin 分支名
</code></pre>
<ul>
<li>删除本地分支</li>
</ul>
<pre><code class="language-cmd">git branch -d 分支名
</code></pre>
<ul>
<li>查看本地分支状态</li>
</ul>
<pre><code class="language-cmd">git branch
</code></pre>
<ul>
<li>删除远程分支</li>
</ul>
<pre><code class="language-cmd">git push origin --delete [branch_name]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello]]></title>
        <id>https://cutezhangq.github.io/post/hello-gridea/</id>
        <link href="https://cutezhangq.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎来到我的博客 ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎来到我的博客 ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>