<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-08-04T12:47:15.882Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[进程, 线程, 浏览器内核, js执行顺序 WebWorkers]]></title>
        <id>https://cutezhangq.github.io/post/jin-cheng-xian-cheng-liu-lan-qi-nei-he-js-zhi-xing-shun-xu/</id>
        <link href="https://cutezhangq.github.io/post/jin-cheng-xian-cheng-liu-lan-qi-nei-he-js-zhi-xing-shun-xu/">
        </link>
        <updated>2020-08-02T13:48:44.000Z</updated>
        <content type="html"><![CDATA[<p>进程process ：程序的一次执行，它占有一片独有的内存空间<br>
可以通过windows任务管理器查看进程</p>
<p>线程thread：是进程内的一个独立执行单元<br>
是程序执行的一个完整流程<br>
是CPU的最小的调度单元</p>
<p>多线程：一个进程里面有多个线程，一个程序可以同时启动对个实例运行。<br>
单线程：一个进程里面只有一个线程。（JS是单线程的，但是用H5中的Web Workers可以多线程运行）<br>
<strong>js执行顺序</strong><br>
1、js是单线程，执行模式有两种：同步，异步<br>
　　单线程：只有一条流水线<br>
　　同步：依次再流水线上执行<br>
　　异步：流水线旁加了一个临时储物台（任务队列），会把某些模块拿到临时储物台，或者会把临时储物台的某些模块插队到流水线<br>
2、js默认模式是同步模式，按流水线执行:A,B,C，不管A里边代码运行时间多长，都要先执行完A，再执行B，再执行C<br>
3、实现异步模式的几种方法<br>
　　①回调函数（把临时储物台的模块插入到流水线）<br>
　　②setTimeout（把流水线的模块拿到临时储物台，过一段时间再插入回去）<br>
　　③Promise对象（把临时储物台的模块插入到流水线）<br>
4、小程序中所有的wx.xxx()接口，也都是异步模式（先执行流水线上非wx.xxx的模块，把流水线上所有的wx.xxx模块先拿到临时储物台执行，等哪个有了返回结果，并且流水线上有空了，也就是流水线上非wx.xxx的模块执行完了，再把哪个插回去）<br>
5、async函数中，代码的执行模式是异步模式，所有的模块都放在临时储物台上执行，哪个模块执行完了，就先把哪个模块拿到流水线上执行<br>
6、举例</p>
<pre><code class="language-js">  jobs.add({
      data: {
        userName: 'aaa'
      }
    })
    .then(res =&gt; {
      wx.hideLoading({
        success: res =&gt; {
          console.log('hideLoading')
        }
      })
      wx.showToast({
        title: '提交成功',
        icon: 'success',
        duration: 2000
      })
      wx.switchTab({
        url: '../my/my',
      })
      console.log('aaaa')
    })
    .catch(err =&gt; {
      console.log(err)
    })
</code></pre>
<p>执行顺序分析：<br>
把wx.hideLoading，wx.showToast，wx.switchTap先放到临时储物台，并执行执行流水线上的console.log('aaaa')，流水线上有空了，把临时储物台上最先有了返回结果的wx.hideLoading插入回流水线执行，流水线上有空了，又把第二个有了返回结果的wx.switchTab插入回流水线执行<br>
显示顺序：aaaa，hideLoading，跳转<br>
7、if...else if....else会按照顺序执行，先执行if，再执行else if，再执行else<br>
8、for循环是先执行完内部的循环，再跳出循环，for循环后面的代码，必须for循环完成后才能执行</p>
<h1 id="js引擎j">js引擎j</h1>
<p>js引擎执行代码的基本流程：    初始化代码---&gt;回调代码script 引入方式</p>
<pre><code>* html 静态&lt;script&gt;引入
* js 动态插入&lt;script&gt;
* &lt;script defer&gt;: 延迟加载，元素解析完成后执行
* &lt;script async&gt;: 异步加载，但执行时会阻塞元素渲染
</code></pre>
<h1 id="web-workers">Web Workers</h1>
<p>1.H5规范了js 分线程的实现，取名为:Web Workers    （但是 js 仍然是 单线程 的）</p>
<p>2.相关API:<br>
Worker:  构造函数，加载分线程执行的js文件<br>
Worker.prototype.onmessage： 用于接收另一个线程的回调函数<br>
Worker.protptype.postMessage:  向另一个线程发送消息</p>
<p>3.不足：</p>
<ol>
<li>Worker内代码不能操作DOM（更新UI）：因为他的全局变量不再是window</li>
<li>不能跨域加载JS</li>
<li>不是每个浏览器都支持这个新特性</li>
</ol>
<p>Web Workers使用：<br>
在主线程的JS中 发消息并设置回调：</p>
<p>主线程中的代码：</p>
<pre><code class="language-js">&lt;body&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;数值&quot; id=&quot;number&quot;/&gt;
  &lt;button id=&quot;btn&quot;&gt;计算&lt;/button&gt;
&lt;/body&gt;
&lt;script&gt;
  //斐波那契数 1 1 2 3 5 8  f(n)=f(n-1)+f(n-2)
  function fibonacci(n){
    return n&lt;2? 1 : fibonacci(n-1) + fibonacci(n-2)
  }
  var input = document.getElementById('number');
  document.getElementById('btn').onclick = function(){
    var number = input.value;
    //创建一个Worker对象，并向它传递在新线程中脚本的URL
    var worker = new Worker('worker.js');
    //绑定接收消息的监听
    worker.onmessage = function(event){ //onmessage当接收到消息时，自动回调
      console.log('主线程接收分线程返回的数据'+event.data);
      // console.log(event.data);
    }
    //向分线程发送消息
    worker.postMessage(number);
    console.log('主线程向分线程发送数据'+number);
  }
</code></pre>
<p>分线程中的代码：<br>
分线程不能更新界面，因为在分线程中看不到window<br>
<img src="https://cutezhangq.github.io/post-images/1596377870491.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1596377904673.png" alt="" loading="lazy"><br>
总结：</p>
<ol>
<li>分线程中的全局对象不再是window，所以在分线程中不可能更新界面</li>
<li>postMessage可以双向发送消息，一个一个发送<br>
<img src="https://cutezhangq.github.io/post-images/1596377925811.png" alt="" loading="lazy"></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[内存溢出与内存泄漏]]></title>
        <id>https://cutezhangq.github.io/post/nei-cun-yi-chu-yu-nei-cun-xie-lou/</id>
        <link href="https://cutezhangq.github.io/post/nei-cun-yi-chu-yu-nei-cun-xie-lou/">
        </link>
        <updated>2020-08-02T13:38:29.000Z</updated>
        <content type="html"><![CDATA[<p>闭包的缺点：<br>
1.函数执行完后，函数内的局部变量没有被释放，占用内存时间会变长<br>
2.容易造成内存泄漏（内存被占用着，但用不上里面的内容）<br>
解决：<br>
1.尽量不用闭包<br>
2.及时释放（让内部函数成为垃圾对象--&gt;就收闭包） 即 f = null<br>
<img src="https://cutezhangq.github.io/post-images/1596375551223.png" alt="" loading="lazy"><br>
内存溢出与内存泄漏:内存溢出：<br>
一种程序运行出现的错误。<br>
当程序运行的内存超过了剩余的内存时，就抛出内存溢出的错误<br>
<img src="https://cutezhangq.github.io/post-images/1596375576188.png" alt="" loading="lazy"><br>
注：是一种抛出错误，浏览器会崩溃</p>
<p>内存泄漏：<br>
占用的内存没有及时释放<br>
内存泄漏积累多了就容易导致内存溢出<br>
常见的内存泄漏：<br>
1.意外的全局变量<br>
2.没有及时清理的计时器或回调函数<br>
3.闭包</p>
<p><code>1.意外的全局变量</code><br>
<img src="https://cutezhangq.github.io/post-images/1596375625382.png" alt="" loading="lazy"><br>
<code>2.没有及时清理的计时器或回调函数，清理定时器</code>：clearInterval( )<br>
<img src="https://cutezhangq.github.io/post-images/1596375657343.png" alt="" loading="lazy"><br>
<code>3.闭包</code><br>
<img src="https://cutezhangq.github.io/post-images/1596375936764.png" alt="" loading="lazy"><br>
面试重点：<br>
1.this的指向<br>
<img src="https://cutezhangq.github.io/post-images/1596375977020.png" alt="" loading="lazy"><br>
输出：The window<br>
注：不属于闭包（有函数嵌套，但没有内部函数引用外部函数）</p>
<ol start="2">
<li>var that = this    指定局部作用域<br>
<img src="https://cutezhangq.github.io/post-images/1596376032467.png" alt="" loading="lazy"><br>
输出：My Object<br>
注：属于闭包</li>
</ol>
<p>3.闭包问题</p>
<pre><code class="language-js">function fun(n,o){
  console.log(o);
  return {
    fun:function(m){
      return fun(m,n);
    }
  }
}
var a = fun(0); a.fun(1); a.fun(2); a.fun(3); //undefined ,0 ,0 ,0
console.log('——————————');
var b = fun(0).fun(1).fun(2).fun(3);  //undefined ,0 ,1 ,2
console.log('——————————');
var c = fun(0).fun(1); c.fun(2);  c.fun(3); //undefined ,0 ,1 ,1

</code></pre>
<p>分析：<br>
a中，<br>
a.fun(1)时m=1,n=0（闭包，内部n调用外部传入的0）,然后内部的fun:function这个走完回到外面函数，将0传给o，然后console.log(o)得到 0<br>
a.fun(2)时m=2,n=0，然后到外面函数中n=2,o=0，然后console.log(o)得到 0</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[创建对象4种方式]]></title>
        <id>https://cutezhangq.github.io/post/chuang-jian-dui-xiang-4-chong-fang-shi/</id>
        <link href="https://cutezhangq.github.io/post/chuang-jian-dui-xiang-4-chong-fang-shi/">
        </link>
        <updated>2020-08-02T12:07:55.000Z</updated>
        <content type="html"><![CDATA[<p>变量与对象的区别<br>
变量：只能存一个数据<br>
对象：可以存多个数据（属性、封装...）<br>
对象的组成：<br>
属性（属性名 String类型，属性值 任意类型）<br>
方法（一种特别的属性，属性值是函数）</p>
<p>访问 对象内部数据 的方法    (中括号运算符总是能代替点运算符。但点运算符却不一定能全部代替中括号运算符。)<br>
. 点 属性名        后面加静态标志符<br>
当对象内部没有定义该属性时不能使用。<br>
[' 属性名 ']        后面可以加动态标志符<br>
当属性名包含特殊字符：-  空格，必须使用[' ']；<br>
当属性名 不确定时，必须使用[' ']；</p>
<p>常用：点是访问json对象。而方括号是数组。   obj.name='xx'  ;  arr[0] = 1</p>
<pre><code class="language-js">//访问对象内部属性
var person = {
  name:'cutezhangq',
  age:20,
  setName:function(name){
    this.name = name      //改变person对象的name属性，this是局部作用域内的对象，即person
  },
  setAge:function(age){
    this.age = age
  }
}
console.log(person)                 //Object {name: &quot;cutezhangq&quot;, age: 20, setName: , setAge: }
//采用 点 的方式，访问对象内部属性
person.setName('zhuangzhou');  
console.log(person)                 //Object {name: &quot;zhuangzhou&quot;, age: 20, setName: , setAge: }
//采用['']的方式，[''](值)  这种是给该属性赋值
person['setAge'](100);
console.log(person)                 //Object {name: &quot;zhuangzhou&quot;, age: 100, setName: , setAge: } 

</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596370140753.png" alt="" loading="lazy"><br>
什么时候必须使用['属性名']？<br>
中括号运算符可以用字符串变量的内容作为属性名。点运算符不能。<br>
中括号运算符可以用纯数字为属性名。点运算符不能。<br>
中括号运算符可以用js的关键字和保留字作为属性名。点运算符不能。</p>
<pre><code class="language-js">var p= {},b = {};
//给对象添加属性：content-type:text/json
//p.content-type不可以使用,含义特殊字符 - 
p['content-type'] = 'text/json';
console.log(p['content-type']);   //text/json
//属性名 不确定
var propName = 'age';
var value = 20;
// p.propName = value;  //报错
b[propName] = value;
console.log(b);   //Object {age: 20}
//——————————————————————————————————————————————————————
var obj={
         say1:1,
         say2:2,
         say3:3
        }
 
for(let i=1; i&lt;Object.keys(obj).length+1; i++){
    console.log(obj[&quot;say&quot;+i]);  
}
//  1
//  2
//  3
</code></pre>
<p>创建对象的四种方式：<br>
<strong>系统的构造函数Object</strong><br>
<strong>自定义构造函数</strong><br>
<strong>字面量的方式</strong><br>
<strong>工厂化模式</strong></p>
<pre><code class="language-js">//创建对象的4中方式
//1.调用 系统的构造函数Object 创建对象（per2.name=&quot; &quot;）
var person = new Object();
person.name = 'cutezhangq';
person.age = 20;
person.key = function(i){
  console.log('给实例自定义方法'+i);
}
console.log(person);  //Object {name: &quot;cutezhangq&quot;, age: 20, key: }
person.key(123)       //给实例自定义方法123



//2.自定义构造函数    (申请一块空闲的空间,首字母一般大写)
function stu(name,age){
  this.name = name;
  this.age = age;
  this.say = function(){
    return console.log(&quot;我叫：&quot;+this.name,&quot;,年龄是:&quot;+this.age);
  };
}
var stu_zq = new stu('ccc',22);
stu_zq.say();    //我叫：ccc ,年龄是:22
for(var key in stu_zq){
  console.log('key:'+key+',value:'+stu_zq[key])
}
//  key:name,value:ccc
//  key:age,value:22
//  key:say,value:function(){ return console.log(&quot;我叫：&quot;+this.name,&quot;,年龄是:&quot;+this.age);  }



//3.字面量的方式创建对象
var obj = {
  name:'piu',
  age:20,
  eat:function(){
    console.log('wowowo');
  }
}
obj.eat();  //wowowo
console.log(obj.name);  //piu
//3.1
var b1 = {
  b2:[1,'aaa',console.log],
  b3:function(){
    console.log('b3');
    return function(){
      return 'yiny';
    }
  }
}
console.log(typeof b1.b2[2])  //function  说明console.log是函数
console.log(b1.b3()())  //yiny
//b1.b3() 找到b3属性里的函数
//b1.b3()() 找到函数里的return的函数



//4.工厂化模式创建对象（批量制作对象）  采用createObject批量化生产，能实例化多个具有相似属性和方法的对象
function createObject(name,age){
  var obj = new Object;
  obj.name = name;
  obj.age = age;
  return obj;
}
var per1 = createObject(&quot;xixi&quot;,23);
var per2 = createObject(&quot;hihi&quot;,53);
console.log(per1);  //Object {name: &quot;xixi&quot;, age: 23}
console.log(per2);  //Object {name: &quot;hihi&quot;, age: 53}
console.log(createObject);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MVVM设计模式]]></title>
        <id>https://cutezhangq.github.io/post/mvvm/</id>
        <link href="https://cutezhangq.github.io/post/mvvm/">
        </link>
        <updated>2020-07-07T07:03:01.000Z</updated>
        <content type="html"><![CDATA[<p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表</p>
<p>MVVM 源自于经典的 Model–View–Controller（MVC）模式  ，MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率，MVVM 的核心是 ViewModel 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。如下图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596524698651.png" alt="" loading="lazy"><br>
（1）View 层<br>
View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。<br>
（2）Model 层<br>
Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。<br>
（3）ViewModel 层<br>
ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。<br>
MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。<br>
我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：<br>
（1）View 层</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{message}}&lt;/p&gt;
    &lt;button v-on:click=&quot;showMessage()&quot;&gt;Click me&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>（2）ViewModel 层</p>
<pre><code class="language-js">var app = new Vue({
    el: '#app',
    data: {  // 用于描述视图状态   
        message: 'Hello Vue!', 
    },
    methods: {  // 用于描述视图行为  
        showMessage(){
            let vm = this;
            alert(vm.message);
        }
    },
    created(){
        let vm = this;
        // Ajax 获取 Model 层的数据
        ajax({
            url: '/your/server/data/api',
            success(res){
                vm.message = res;
            }
        });
    }
})
</code></pre>
<p>（3）Model 层</p>
<pre><code class="language-json">{
    &quot;url&quot;: &quot;/your/server/data/api&quot;,
    &quot;res&quot;: {
        &quot;success&quot;: true,
        &quot;name&quot;: &quot;IoveC&quot;,
        &quot;domain&quot;: &quot;www.cnblogs.com&quot;
    }
}

</code></pre>
<p><strong>MVVM.js</strong></p>
<pre><code class="language-js">/*
相关于Vue的构造函数
 */
function MVVM(options) {
  // 将选项对象保存到vm
  this.$options = options;
  // 将data对象保存到vm和data变量中
  var data = this._data = this.$options.data;
  //将vm保存在me变量中
  var me = this;
  // 遍历data中所有属性
  Object.keys(data).forEach(function (key) { // key是data的某个属性名: name
    // 对指定属性实现代理
    me._proxy(key);
  });

  // 对data中所有层次的属性通过 数据劫持 实现 数据绑定。进行监视
  observe(data, this);

  // 创建一个编译对象，来解析模板 的compile对象
  //如果左边有值传左边的，没有则传右边的
  this.$compile = new Compile(options.el || document.body, this)
}

MVVM.prototype = {
  $watch: function (key, cb, options) {
    new Watcher(this, key, cb);
  },

  // 对指定属性实现代理
  _proxy: function (key) {
    // 保存vm
    var me = this;
    // 给vm添加指定属性名的属性(使用属性描述)
    Object.defineProperty(me, key, {
      configurable: false,    // 不能再重新定义
      enumerable: true,       // 可以枚举
      // 当通过vm.name读取属性值时自动调用,从data中获取对应的属性值返回
      get: function proxyGetter() {
        // 读取data中对应属性值返回(实现代理 读 操作)
        return me._data[key];
      },
      // 当通过vm.name = 'xxx'时自动调用
      set: function proxySetter(newVal) {
        // 将xxx最新的值保存到data中对应的属性上(实现代理 写 操作)
        me._data[key] = newVal;
      }
    });
  }
};

</code></pre>
<p><strong>MVVM 原理图分析</strong><br>
<img src="https://cutezhangq.github.io/post-images/1596524937242.png" alt="" loading="lazy"></p>
<p><strong>实现了 数据初始化 和 数据更新：</strong><br>
<img src="https://cutezhangq.github.io/post-images/1596524952690.png" alt="" loading="lazy"></p>
<p>双向数据绑定双向数据绑定=单向数据绑定+input 监听<br>
1.<br>
双向数据绑定是建立在单向数据绑定(model==&gt;View)的基础之上的<br>
2.<br>
双向数据绑定的实现流程:<br>
a. 在解析 v-model 指令时, 给当前元素添加 input 监听 （从View==&gt;model）<br>
b. 当 input 的 value 发生改变时, 将最新的值赋值给当前表达式所对应的 data 属性</p>
<pre><code class="language-js">&lt;div id=&quot;test&quot;&gt;
&lt;input type=&quot;text&quot; v-model=&quot;msg&quot;&gt;
&lt;p&gt;{{msg}}&lt;/p&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
new MVVM({
el: '#test',
data: {
msg: 'haha'
}
})
&lt;/script&gt;
</code></pre>
<h3 id="数据劫持observedata-this">数据劫持observe(data, this);</h3>
<pre><code>1. 数据劫持是 vue 中用来实现数据绑定的一种 技术
2. 基本思想: 通过 defineProperty()来监视 data 中所有属性(任意层次)数据的变化, 一旦变化就去更新界面
</code></pre>
<p>即，给data中的属性添加set(监视变化)，get方法</p>
<p>例如:this.xxx = 3,此时this是vm,改变vm的set的值，然后这里的set变化了，会改变data中xxx的值。(vm——&gt;M)<br>
当data中xxx的值改变时，data的set值也发生变化，就会去更新界面了。(数据绑定：M——&gt;V)<br>
即：<br>
vm中的set是用来实现 数据代理的<br>
data中的set是用来实现 数据绑定 的（界面会变）</p>
<h2 id="四个重要对象">四个重要对象</h2>
<h3 id="1-observer-观察到了然后去劫持数据定义getset创建dep对象">1) Observer        （观察到了然后去“劫持”数据，定义get/set，创建dep对象）</h3>
<p>a. 用来对 data 所有属性数据进行劫持的构造函数<br>
b. 给 data 中所有属性重新定义属性描述(get/set)<br>
c. 为 data 中的每个属性创建对应的 dep 对象</p>
<h3 id="2-depdepend-存放watcher的数组即subscribessubs">2) Dep(Depend)    （存放watcher的数组，即subscribes——subs）</h3>
<p>a. data 中的每个属性(所有层次)都对应一个 dep 对象<br>
b. 创建的时机:<br>
* 在初始化 definedata 中各个属性时创建对应的 dep 对象<br>
* 在 data 中的某个属性值被设置为新的对象时</p>
<p>c. 对象的结构</p>
<pre><code class="language-js">{
     id,            // 每个 dep 都有一个唯一的 id
    subs        //包含 n 个对应 watcher 的 数组 (subscribes 的简写)
}
</code></pre>
<p>d. subs 属性说明<br>
* 当 watcher 被创建时, 内部将当前 watcher对象添加到对应的 dep对象的 subs中<br>
* 当此 data 属性的值发生改变时,subs 中所有的 watcher 都会收到更新的通知,从而最终更新对应的界面</p>
<h3 id="3-compiler">3) Compiler        ()</h3>
<p>a. 用来解析模板页面的对象的构造函数(一个实例)<br>
b. 利用 compile 对象解析模板页面<br>
c. 每解析一个表达式(非事件指令)都会创建一个对应的watcher对象, 并建立watcher 与 dep 的关系<br>
d. complie 与 watcher 关系: 一对多的关系</p>
<h3 id="4-watcher">4) Watcher</h3>
<p>更新显示的<br>
a. 模板中每个非事件指令或表达式都对应一个 watcher 对象<br>
b. 监视当前表达式数据的变化<br>
c. 创建的时机: 在初始化编译模板时<br>
d. 对象的组成</p>
<p>{<br>
vm,           //vm 对象<br>
exp,          //对应指令的表达式<br>
cb,            //当表达式所对应的数据发生改变的回调函数    （更新界面的回调函数）<br>
value,        //表达式当前的值<br>
depIds        //表达式中各级属性所对应的 dep 对象的集合对象         //属性名为 dep 的 &gt; id, 属性值为 dep<br>
}5) 总结:dep 与 watcher 的关系: 多对多</p>
<p>a. data 中的一个属性对应一个 dep, 一个 dep 中可能包含多个 watcher(模板中有几个 表达式使用到了同一个属性)<br>
b. 模板中一个非事件表达式对应一个 watcher, 一个 watcher 中可能包含多个 dep(表 达式是多层:a.b)<br>
c. 数据绑定使用到 2 个核心技术<br>
* defineProperty()<br>
* 消息订阅与发布<br>
<img src="https://cutezhangq.github.io/post-images/1596525197350.png" alt="" loading="lazy"></p>
<p><strong>Dep与Watch之间的关系    ：多对多</strong><br>
dep先创建，watcher后创建。一旦watcher创建，关系就有限制条件了</p>
<pre><code>* 1data属性 ---&gt;1Dep ---&gt; n个watcher(模板中有多个表达式使用了此属性)

* 例如：在模板中写了多次表达式：{{name}}/ v-text=&quot;name&quot; ,则此时1个name ---&gt;1个Dep ---&gt; 2个watcher
* 1表达式---&gt;1Watcher---&gt;n个Dep(多层表达式)

* 例如：a.b.c对应1个watcher，但对应3个dep(a.b.c有3层)
</code></pre>
<p>同一个属性对应同一个dep<br>
如何建立的？<br>
data中属性的get()中建立<br>
vm.name = 'abc' ---&gt;data中的name属性值变化 ---&gt; name的set()调用 ---&gt; dep ---&gt;相关的所有watcher ---&gt;cb() ---&gt;updater<br>
什么时候建立？<br>
初始化的解析模板中的表达式创建watcher对象时<br>
通过get:建立dep与watcher的关系</p>
<pre><code class="language-js">
Object.defineProperty(data, key, {
enumerable: true, // 可枚举
configurable: false, // 不能再define
get: function() {
// 建立dep与watcher的关系
if (Dep.target) {
dep.depend();
}
// 返回属性值
return val;
},
set: function(newVal) {
if (newVal === val) {
return;
}
val = newVal;
// 新的值是object的话，进行监听
childObj = observe(newVal);//observe观察data中的所有属性
// 通过dep ,通知订阅者
dep.notify();
}
});
</code></pre>
<h1 id="vue-是如何实现数据双向绑定的">Vue 是如何实现数据双向绑定的？</h1>
<p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596527367288.png" alt="" loading="lazy"><br>
即：</p>
<p>输入框内容变化时，Data 中的数据同步变化。即 View =&gt; Data 的变化。<br>
Data 中的数据变化时，文本节点的内容同步变化。即 Data =&gt; View 的变化。</p>
<p>其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。<br>
Vue 主要通过以下 4 个步骤来实现数据双向绑定的：<br>
实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。<br>
实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。<br>
实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。<br>
实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。<br>
<img src="https://cutezhangq.github.io/post-images/1596527393627.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[居中方案（水平居中、垂直居中、水平垂直居中）]]></title>
        <id>https://cutezhangq.github.io/post/ju-zhong-fang-an-shui-ping-ju-zhong-chui-zhi-ju-zhong-shui-ping-chui-zhi-ju-zhong/</id>
        <link href="https://cutezhangq.github.io/post/ju-zhong-fang-an-shui-ping-ju-zhong-chui-zhi-ju-zhong-shui-ping-chui-zhi-ju-zhong/">
        </link>
        <updated>2020-07-01T01:10:23.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="最简单的居中">最简单的居中</h1>
<pre><code class="language-css">.zi{
    width: 200px;
    margin: 0 auto;
}
</code></pre>
<h1 id="案例内容">案例内容</h1>
<pre><code class="language-html"> &lt;style&gt;
    .fu{
      width: 200px;
      height: 200px;
      background-color: powderblue;
    }

  &lt;/style&gt;

    &lt;body style=&quot;background-color: antiquewhite;&quot;&gt;
      &lt;div class=&quot;fu&quot;&gt;
        &lt;h2&gt;这是标题哦&lt;/h2&gt;
        &lt;div class=&quot;zi&quot;&gt;
          &lt;p&gt;哈哈&lt;/p&gt;
          &lt;form action=&quot;&quot;&gt;
            姓名:&lt;input type=&quot;text&quot;&gt;&lt;br /&gt;
            性别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女
            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;br /&gt;
            爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;篮球
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;下棋
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;画画
             &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;写作&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
             &lt;img src=&quot;../bootstrap/img/1.png&quot; alt=&quot;&quot; width=&quot;150px&quot;&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/body&gt;
</code></pre>
<h1 id="水平垂直-居中方案1">水平垂直 居中方案1</h1>
<h3 id="需要知道-宽高">需要知道 宽高</h3>
<pre><code class="language-css">        .fu{
          position: absolute;
          left: 0;
          right: 0;
          bottom: 0;
          top: 0;
          margin: auto;
        }
</code></pre>
<h1 id="水平垂直-居中方案2">水平垂直 居中方案2</h1>
<h3 id="可用于-不知道宽高-的情况下使用">可用于 不知道宽高 的情况下使用</h3>
<p>缺点：transform的兼容性不高</p>
<ul>
<li>translate()函数是css3的新特性,在不知道自身宽高的情况下,可以利用它来进行水平垂直居中</li>
<li>当使用: top: 50%;left: 50%；是以左上角为原点，故不处于中心位置</li>
<li>translate(-50%,-50%)作用是：往上(x轴),左(y轴)移动自身长宽的50%,以使其居于中心位置。</li>
</ul>
<pre><code class="language-css">.fu{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);   //百分比是相对于自身宽高的百分比
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596418063196.png" alt="" loading="lazy"></figure>
<h1 id="对于仅文本内容的需要居中的也可使img标签对于div标签-水平居中">对于仅文本内容的，需要居中的：(也可使Img标签对于div标签 水平居中)</h1>
<pre><code class="language-css">h2{
    text-align: center;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1596417930705.png" alt="" loading="lazy"></figure>
<h1 id="表格中内容水平垂直居中">表格中内容水平垂直居中：</h1>
<pre><code class="language-css">.table&gt;tbody&gt;tr&gt;td{
  vertical-align: middle;
  text-align: center;
}
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="最简单的居中">最简单的居中</h1>
<pre><code class="language-css">.zi{
    width: 200px;
    margin: 0 auto;
}
</code></pre>
<h1 id="案例内容">案例内容</h1>
<pre><code class="language-html"> &lt;style&gt;
    .fu{
      width: 200px;
      height: 200px;
      background-color: powderblue;
    }

  &lt;/style&gt;

    &lt;body style=&quot;background-color: antiquewhite;&quot;&gt;
      &lt;div class=&quot;fu&quot;&gt;
        &lt;h2&gt;这是标题哦&lt;/h2&gt;
        &lt;div class=&quot;zi&quot;&gt;
          &lt;p&gt;哈哈&lt;/p&gt;
          &lt;form action=&quot;&quot;&gt;
            姓名:&lt;input type=&quot;text&quot;&gt;&lt;br /&gt;
            性别:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女
            &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;br /&gt;
            爱好:&lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;篮球
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;下棋
            &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;画画
             &lt;input type=&quot;checkbox&quot; name=&quot;hobbies&quot;&gt;写作&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
             &lt;img src=&quot;../bootstrap/img/1.png&quot; alt=&quot;&quot; width=&quot;150px&quot;&gt;
          &lt;/form&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/body&gt;
</code></pre>
<h1 id="水平垂直-居中方案1">水平垂直 居中方案1</h1>
<h3 id="需要知道-宽高">需要知道 宽高</h3>
<pre><code class="language-css">        .fu{
          position: absolute;
          left: 0;
          right: 0;
          bottom: 0;
          top: 0;
          margin: auto;
        }
</code></pre>
<h1 id="水平垂直-居中方案2">水平垂直 居中方案2</h1>
<h3 id="可用于-不知道宽高-的情况下使用">可用于 不知道宽高 的情况下使用</h3>
<p>缺点：transform的兼容性不高</p>
<ul>
<li>translate()函数是css3的新特性,在不知道自身宽高的情况下,可以利用它来进行水平垂直居中</li>
<li>当使用: top: 50%;left: 50%；是以左上角为原点，故不处于中心位置</li>
<li>translate(-50%,-50%)作用是：往上(x轴),左(y轴)移动自身长宽的50%,以使其居于中心位置。</li>
</ul>
<pre><code class="language-css">.fu{
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);   //百分比是相对于自身宽高的百分比
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596418063196.png" alt="" loading="lazy"></figure>
<h1 id="对于仅文本内容的需要居中的也可使img标签对于div标签-水平居中">对于仅文本内容的，需要居中的：(也可使Img标签对于div标签 水平居中)</h1>
<pre><code class="language-css">h2{
    text-align: center;
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1596417930705.png" alt="" loading="lazy"></figure>
<h1 id="表格中内容水平垂直居中">表格中内容水平垂直居中：</h1>
<pre><code class="language-css">.table&gt;tbody&gt;tr&gt;td{
  vertical-align: middle;
  text-align: center;
}
</code></pre>
<!-- more -->
<h1 id="10种-水平垂直居中对齐方式">10种 水平垂直居中对齐方式</h1>
<p>测试代码</p>
<pre><code class="language-html"> &lt;div class=&quot;wp&quot;&gt;
    &lt;div class=&quot;box size&quot;&gt;123123&lt;/div&gt;
 &lt;/div&gt;
</code></pre>
<pre><code class="language-css">/* 公共代码 */
.wp {
border: 1px solid red;
width: 300px;
height: 300px;
}

.box {
background: green;
}

.box.size{
width: 100px;
height: 100px;
}
/* 公共代码 */
</code></pre>
<h2 id="absolute-负margin-需要知道子元素的宽高">absolute + 负margin 需要知道子元素的宽高</h2>
<ul>
<li>绝对定位的百分比是相对于父元素的宽高，通过这个特性可以让子元素的居中显示。</li>
<li>但绝对定位是基于子元素的左上角，期望的效果是子元素的中心居中显示</li>
<li>为了修正这个问题，可以借助外边距的负值，负的外边距可以让元素向相反方向定位，通过指定子元素的外边距为子元素宽度一半的负值，就可以让子元素居中了</li>
</ul>
<pre><code class="language-css">/* 定位代码 */
.wp {
    position: relative;
}
.box {
    position: absolute;;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
</code></pre>
<h2 id="absolute-margin-auto-见上面内容">absolute + margin auto 见上面内容</h2>
<h2 id="absolute-transform-见上面内容">absolute + transform 见上面内容</h2>
<h2 id="absolute-calc-这种方法兼容性依赖calc的兼容性缺点是需要知道子元素的宽高">absolute + calc        这种方法兼容性依赖calc的兼容性，缺点是需要知道子元素的宽高</h2>
<p>感谢css3带来了calc 计算属性，既然top的百分比是基于元素的左上角，那么在减去宽度的一半就好了</p>
<pre><code class="language-css">.wp {
position: relative;
}
.box {
position: absolute;;
top: calc(50% - 50px);
left: calc(50% - 50px);
}
</code></pre>
<h2 id="lineheight">lineheight</h2>
<p>利用行内元素 居中属性也可以做到水平垂直 居中，<br>
把box设置为行内元素，通过text-align就可以做到水平居中，但很多同学可能不知道通过通过vertical-align也可以在垂直方向做到居中</p>
<p>/* 定位代</p>
<pre><code class="language-css">/* 定位代码 */
.wp {
line-height: 300px;
text-align: center;
font-size: 0px;
}
.box {
font-size: 16px;
display: inline-block;
vertical-align: middle;
line-height: initial;
text-align: left; /* 修正文字 */
}
</code></pre>
<p>这种方法需要在子元素中将文字显示重置为想要的效果<br>
<img src="https://cutezhangq.github.io/post-images/1596444057505.png" alt="" loading="lazy"></p>
<h2 id="writing-mode">writing-mode</h2>
<p>简单来说writing-mode可以改变文字的显示方向，比如可以通过writing-mode让文字的显示变为垂直方向</p>
<pre><code class="language-html">&lt;div class=&quot;div1&quot;&gt;水平方向&lt;/div&gt;
&lt;div class=&quot;div2&quot;&gt;垂直方向&lt;/div&gt;
</code></pre>
<pre><code class="language-css">.div2 {
   writing-mode: vertical-lr;
}
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596444154555.png" alt="" loading="lazy"><br>
更神奇的是所有水平方向上的css属性，都会变为垂直方向上的属性，比如text-align，通过writing-mode和text-align就可以做到水平和垂直方向的居中了，只不过要稍微麻烦一点</p>
<pre><code class="language-css">/* 此处引用上面的公共代码 */
/* 此处引用上面的公共代码 */

/* 定位代码 */
.wp {
writing-mode: vertical-lr;
text-align: center;
}
.wp-inner {
writing-mode: horizontal-tb;
display: inline-block;
text-align: center;
width: 100%;
}
.box {
display: inline-block;
margin: auto;
text-align: left;
}
</code></pre>
<h2 id="table">table</h2>
<p>曾经table被用来做页面布局，现在没人这么做了，但table也能够实现水平垂直居中，但是会增加很多冗余代码</p>
<pre><code class="language-css">.wp {
text-align: center;
}
.box {
display: inline-block;
}
</code></pre>
<h2 id="css-table">css-table</h2>
<p>css新增的table属性，可以让我们把普通元素，变为table元素的现实效果，通过这个特性也可以实现水平垂直居中<br>
下面通过css属性，可以让div显示的和table一样<br>
这种方法和table一样的原理，但却没有那么多冗余代码，兼容性也还不错</p>
<pre><code class="language-css">.wp {
display: table-cell;
text-align: center;
vertical-align: middle;
}
.box {
display: inline-block;
}
</code></pre>
<h2 id="flex">flex</h2>
<p>flex作为现代的布局方案，颠覆了过去的经验，只需几行代码就可以优雅的做到水平垂直居中</p>
<pre><code class="language-css">.wp {
    display: flex;
    justify-content: center;
    align-items: center;
}
</code></pre>
<h2 id="grid">grid</h2>
<p>css新出的网格布局，由于兼容性不太好，一直没太关注，通过grid也可以实现水平垂直居中</p>
<pre><code class="language-css">.wp {
    display: grid;
}
.box {
    align-self: center;
    justify-self: center;
}
</code></pre>
<h1 id="总结">总结</h1>
<pre><code>* PC端有兼容性要求，宽高固定，推荐absolute + 负margin
* PC端有兼容要求，宽高不固定，推荐css-table
* PC端无兼容性要求，推荐flex
* 移动端推荐使用flex
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js常规问题]]></title>
        <id>https://cutezhangq.github.io/post/js/</id>
        <link href="https://cutezhangq.github.io/post/js/">
        </link>
        <updated>2020-06-16T06:05:13.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="js中的数据类型">js中的数据类型</h1>
<p>js共有9种数据类型：5种基本数据类型，3种引用类型，1种es6新增类型<br>
👉<code>基本数据类型</code>：Number、String、Null、Undefined、Boolean<br>
👉<code>引用类型</code>：Function、Array、Object<br>
👉<code>es6新增类型</code>：Symbol</p>
<!-- more -->
<p>当然有些可以合并，引用类型部分也可以归为Object类型一种，故也称7种数据类型（5+1+1）<br>
其中，基本数据类型存储的是实际数据的值；引用数据类型存储的是数据的引用（引用存储在<code>栈</code>里，实际内容存储在<code>堆</code>里）<br>
那么，为啥要分几种不同的数据类型呢？因为我们最终的目的是要使用数据来搞事情~😀，面对庞大的数据必然有许多重复，如果不分类的存储不然会造成混乱。这就需要我们对数据进行分类存储了。</p>
<!-- more -->
<ul>
<li>
<p>有的数据是直接存储起来，用的时候直接使用就行了，不需要对数据进行改变，这种类型的往往比较简单，所以统称为<strong>基本数据类型</strong>。</p>
</li>
<li>
<p>有的数据存储了之后，再进行使用需要对数据进行改动，可以原始数据就进行改动，也可只对引用的数据进行改动，这种情况就比较复杂了，所以对数据的结构就分出来栈和堆，栈中的数据指向堆中最终存储的数据。这种统称为<strong>引用数据类型</strong>。</p>
</li>
</ul>
<p>🔶局部变量存放在<code>栈</code>中(该方法中声明的变量随着栈的销毁而结束，局部变量只能在方法中有效)；<br>
🔷全局变量存放在<code>堆</code>中(不会随着某个方法执行结束而销毁)</p>
<!-- more -->
<p>那么分好了存储，接下来还要👊使用数据，一般是定义变量来使用存储的数据。但是因为存储类型不同，所以在使用<code>变量</code>定义数据是也有不同的特性(变量的类型是根据其内部存储的数据类型来决定的)：</p>
<ul>
<li>基本变量类型：一个变量要复制另一个变量时，采用 <code>深拷贝</code> ，会开辟一块新的内存空间进行存储，所以数据改变不影响原始数据。变量存放的就是数据值。</li>
<li>引用变量类型：给变量添加属性，采用 点 的方式。一个变量复制引用类型时，采用 <code>浅拷贝</code> ，所以数据改变会影响原数据的值。变量存放的是数据的引用（指针）。</li>
</ul>
<h1 id="不同数据类型之间的运算及比较">不同数据类型之间的运算及比较</h1>
<h2 id="和-的区别">=== 和 == 的区别</h2>
<p>===这种先比较数据的类型，再比较数据的值。<strong>类型</strong>和<strong>值</strong>要完全一样才相等。（不转换类型）<br>
==这种比较值，当类型不同，可先进行转换，<strong>转换完</strong>再比较<strong>值</strong>。<br>
注：==中转换情况如下几种情况：</p>
<ul>
<li><strong>String和Number</strong>：将String按照ASCII转换为数字再进行比较。</li>
<li><strong>Undefined和Null</strong>：这两个实际的值都是false，它们==是<strong>相等</strong>的。</li>
<li><strong>NaN</strong>：只能使用isNaN来检测类型。</li>
<li><strong>boolean与其他类型</strong>：boolean先转为 0 或 1 再进行比较。</li>
<li>如果是<strong>对象和数字比较</strong>：会将对象先转换为基础数据类型。js中🙆一般valueof优先于tostring类型，采用valueof内置类进行转换，🤷‍♀但在data中是tostring采用转换。</li>
</ul>
<p>😃注：即基本的数据类型间比较时，都是转为数字进行比较（ASCII码转）；涉及到对象这种引用变量时，则是转换为字符串进行比较。</p>
<h2 id="不同数据类型间运算">不同数据类型间运算</h2>
<ul>
<li>执行<code>- 、*、/、%</code> 运算时，都转换为数字进行运算。</li>
<li>执行<code>+</code>运算时，分为几种情况：
<ul>
<li>number + String --&gt;String</li>
<li>number + object --&gt;String ，优先调用tostring转换了
<ul>
<li>如：[1].toString() === '1'</li>
<li>如：{}.toString() === '[object Object]'</li>
</ul>
</li>
<li>number + null/boolean --&gt; <strong>数字</strong></li>
<li>number + undefined --&gt; <strong>NaN</strong></li>
</ul>
</li>
</ul>
<h2 id="和-和">&amp;&amp;和||、&amp;和|</h2>
<p>&amp;&amp;和||是逻辑运算符。</p>
<ul>
<li>
<p>&amp;&amp;表示逻辑与，当左边为真时，才执行右边；左边为假，不执行右边。（会短路）</p>
</li>
<li>
<p>| | 表示逻辑或，当左边为真时，执行左边；左边为假，执行右边。<br>
&amp;和|是位运算符。</p>
</li>
<li>
<p>&amp;表示与运算，转换为二进制逐位进行比较，相同位为1，不同位为0，最后输出的二进制再转为十进制输出最后结果。</p>
</li>
<li>
<p>| 表示或运算，转换为二进制逐位进行比较，只要位上有1就为1，位上都为0则为0，最后输出的二进制再转为十进制输出最后结果。<br>
注：&amp;还可以用来判断 奇偶:</p>
</li>
</ul>
<pre><code class="language-javascript">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="数据类型的判断">数据类型的判断</h1>
<p>👉基本数据类型中<strong>null</strong>：采用 <code>String（）</code> 判断<br>
👉<strong>基本数据类型</strong>中除了null的：采用 <code>typeof()</code> 判断<br>
👉<strong>引用数据类型</strong> 中如object、array、Data等：采用 <code>toString()</code> 判断<br>
一种很稳的判断数据类型方法：💖</p>
<pre><code class="language-javascript">let class2type = {};
'Array Date RegExp Object Error'.splice('').forEach(e =&gt; class2type['[object'+e+']'] = e.toLowerCase())
function type(obj){
    if(obj == null){
        return String(obj)
    }
    return typeof obj ==='object'?  class2type[Object.prototype.toString.call(obj)] || 'object': typeof(obj)
}
</code></pre>
<h1 id="如何判断一个变量是对象还是数组">如何判断一个变量是对象还是数组</h1>
<p>判断数组和对象分别都有好几种方法，其中用prototype.toString.call()兼容性最好。</p>
<pre><code class="language-javascript">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>ps：千万不能使用typeof来判断对象和数组，因为这两种类型都会返回&quot;object&quot;。</p>
<h2 id="判断对象为空的3中方法">判断对象为空的3中方法</h2>
<ul>
<li>JSON.stringify(obj) == ‘{}’</li>
<li>for(var a in obj) == true</li>
<li>Object.keys(obj).length() == 0<br>
具体如下：</li>
</ul>
<pre><code class="language-javascript"> //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }

  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象

  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
  t = {};
  if(Object.keys(t).length == 0){   //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="不同数据类型的保存">不同数据类型的保存</h1>
<ul>
<li>基本数据类型：保存在 <code>堆</code>中</li>
<li>引用数据类型：保存在<code>栈</code>中</li>
<li>变量：可能是基本数据也可能是地址值。</li>
</ul>
<h1 id="内存-变量的生命周期">内存、变量的生命周期</h1>
<p>内存：是内存条通电后产生的一定的存储空间。<br>
变量的生命周期：当js引擎访问变量的时候，要经历：变量声明===》变量初始化===》变量赋值<br>
经历从 产生 到 销毁 的过程。<br>
🌰举例：<br>
<code>var</code>变量的生命周期：其中<strong>变量声明</strong>和<strong>变量初始化</strong>这2个阶段没有间隙，<br>
<code>函数声明</code>的生命周期：<strong>变量声明</strong>和<strong>变量初始化</strong>和<strong>变量赋值</strong>这3个阶段没有间隙，<br>
<code>let</code>:变量的生命周期：每段都有间隙，其中<strong>变量声明</strong>和<strong>变量初始化</strong>之间还有<strong>暂时性死区</strong></p>
<h2 id="为什么-提升-在let的生命周期里无效">为什么 提升 在let的生命周期里无效？</h2>
<p><code>提升：就是变量在作用域顶部进行 声明和初始化。</code><br>
因为let中每个阶段都有间隙，<strong>变量声明</strong>和<strong>变量初始化</strong>是解耦的（解耦让提升这个术语失效了），还存在暂时性死区，在这里，变量不能被访问。</p>
<h2 id="new的执行过程">new的执行过程</h2>
<p>1.创建一个对象<br>
2.将对象挂载到原型上<code>obj.__proto__ = Con.prototype</code><br>
3.this的指向<br>
4.返回新对象(如果构造函数有自己 retrun 时，则返回该值)</p>
<h1 id="对象">对象</h1>
<h2 id="访问对象内部数据的方法">访问对象内部数据的方法</h2>
<p>当访问json数据内部值时，一般采用 <code>点</code>的形式；当访问数组中数据时，一般采用<code>[ ]</code>的形式。<br>
其中，<strong>必须</strong>采用<code>[ ]</code>形式的情况有：属性中有特殊字符，如 - 空格 等的，有关键字的，是未定义的属性的。其余的都可采用这2中方式。</p>
<h2 id="创建对象的四种方法">创建对象的四种方法</h2>
<pre><code class="language-javascript">//1.采用系统的构造函数
var obj = new Object();
obj.name = 'zq';
obj.age = 20;
console.log(obj.name+','+obj.age);//zq,20

//2.自定义构造函数
function stu(name,age){
  this.name = name;
  this.age = age;
  this.mmm = 'koko';  //都是this.的形式，此处的this指代stu对象
  console.log(this.name+','+this.age);  //pk,22
}
var p1 = new stu('pk',22);  
console.log(p1.mmm);  //koko

//3.字面量形式
var tea = {
  name:'bobo',
  age:50,
  say:function(){
    console.log('hello js');
  }
}
console.log(tea.name);  //bobo
tea.say();  //hello js

//4.工厂模式    类似于封装了 系统的构造函数，批量生产对象
function createObject(name,age){
  var obj = new Object();
  obj.name = name;
  obj.age = age;
  return obj; //别忘了返回
} 
var stu1 = createObject('stu1',12);
var stu2 = createObject('stu2',13);
console.log(stu1.name+','+stu1.age);//stu1,12
console.log(stu2.name+','+stu2.age);//stu2,13
</code></pre>
<h1 id="函数">函数</h1>
<h2 id="几种常见的回调函数">几种常见的回调函数</h2>
<p>👉dom中的回调函数</p>
<pre><code class="language-javascript"> //1.dom中时间回调函数，包括Node.js中的
  document.getElementById('btn').onclick = function(){
    console.log('诶呀，被点了!');
  }//诶呀，被点了!
</code></pre>
<p>👉定时器</p>
<pre><code class="language-javascript"> //2.定时器
  setTimeout(function(){
    console.log('我是一个定时器');
  },2000)
  console.log('——————');  
  //——————
  //我是一个定时器
</code></pre>
<p>👉ajax请求中的回调函数（包括promise）</p>
<pre><code class="language-javascript">  $.ajax({
    url:'xxx',
    type:'get',
    data:data,
    success:function(data){
      console.log(data);
    }
  })
</code></pre>
<p>👉生命周期中的回调函数</p>
<pre><code class="language-javascript">//如vue中的

</code></pre>
<h2 id="钩子函数和回调函数">钩子函数和回调函数</h2>
<p>两者都是事件处理函数，不同的是：<br>
<strong>钩子函数</strong>：函数<code>调用时触发</code>，本质上是监听函数。<br>
<strong>回调函数</strong>：函数调用<code>结束时触发</code>。</p>
<h2 id="iife">IIFE</h2>
<p>立即调用函数<br>
形式：<code>( 匿名函数自调用 )( )</code>        或者       <code>( 匿名函数自调用 )(参数)</code><br>
作用：</p>
<ul>
<li>隐藏内部内容代码</li>
<li>防止污染全局（外部）命名空间</li>
<li>进行js编码</li>
<li>解决闭包问题（闭包中变量一直无法释放，占用内存）</li>
</ul>
<p>其他几种也是立即执行函数</p>
<pre><code class="language-javascript">(function(){alert('我是匿名函数')} ()) // 用括号把整个表达式包起来
(function(){alert('我是匿名函数')}) () //用括号把函数包起来
!function(){alert('我是匿名函数')}() // 求反，我们不在意值是多少，只想通过语法检查。
+function(){alert('我是匿名函数')}()
-function(){alert('我是匿名函数')}()
~function(){alert('我是匿名函数')}()
void function(){alert('我是匿名函数')}()
new function(){alert('我是匿名函数')}()
</code></pre>
<h2 id="函数声明与函数表达式">函数声明与函数表达式</h2>
<p>一、所能放置的 **位置 ** 不同<br>
函数声明：由于有<code>函数提升</code>，所以可以在任意地方声明</p>
<pre><code class="language-javascript">  fnName();
  //函数声明
  function fnName() { 
  }
  //正常，因为‘提升’了函数声明，函数调用可在函数声明之前
</code></pre>
<pre><code class="language-javascript">var fnName = function () {     
    alert('11');
  }();
    //函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数
</code></pre>
<p>二、是否 可以<strong>进行函数立即调用</strong></p>
<ul>
<li>函数声明不可以，只能以fnName()形式调用 。</li>
<li>函数表达式后面可以加括号立即调用该函数。</li>
</ul>
<h1 id="原型原理">原型原理</h1>
<p>1、所有的 引用类型 都有一个_ _ proto_ _ 属性     ( 隐式原型)。<br>
它们的_ _ proto_ <em>属性指向 它的构造函数 的 prototype 属性。<br>
如果对象本身不存在这个属性，那么会去它的</em> _ proto_ _属性 (也就是 它的构造函数的 prototype 属性) 中寻找。<br>
如：girl 的name,sayHello属性，最终是到它的构造函数（Person）的 prototype  属性中寻找</p>
<pre><code class="language-js">function Person(name,age){
      this.name = name;
      this.age = age;
      this.sayHello = function(){
          console.log(this.name + &quot; say hello&quot;);
      }
  }
  var girl = new Person(&quot;bella&quot;,23);
  console.log(girl.name);  //bella
  girl.sayHello(); //bella say hello

</code></pre>
<p>2、所有的 函数 都有一个 prototype 属性    ( 显式原型)。<br>
（prototype既是属性也是对象）这个属性是在 函数创建 的时候添加上的（定义函数的时候）</p>
<p>引用类型： 由类型的实际值引用（类似于指针）表示的数据类型（数组、对象、函数）<br>
构造函数：主要用来在 创建对象时 初始化 对象， 即为 对象成员变量 赋初始值，总与new运算符一起使用在创建对象的语句中。a = new people()<br>
一个类可以有多个构造函数 ，可根据其参数个数的不同 或 参数类型的不同来区分它们----&gt;构造函数的重载。<br>
实例化：用 类 创建对象的过程， 是将一个抽象的概念类，具体到该类实物的过程。<br>
var boy = new Person( );<br>
实例： 通过构造函数和 new 创建出来的对象，便是实例。</p>
<pre><code class="language-js">这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线
// 例如: 
// const o = new Object()
// o.constructor === Object   --&gt; true
// o.__proto__ = null;
// o.constructor === Object   --&gt; false
</code></pre>
<p><code>原型、构造函数、实例 关系 图解：</code><br>
<img src="https://cutezhangq.github.io/post-images/1596356775494.png" alt="" loading="lazy"></p>
<p>结论：<br>
1.对象的隐式原型的值__proto__为其 对应 构造函数的显式原型prototype 的值 ——&gt; 实例的__protp__和构造函数的prototype 都是指向原型的</p>
<pre><code class="language-js">function Person(name,height){
     this.name=name;
 }
var boy = new Person('keith');
console.log(boy.__proto__ === Person.prototype);     //true
</code></pre>
<p>通过 调用构造函数 产生的 实例对象，都拥有一个 内部属性，指向了原型对象。<br>
实例对象 能够访问 原型对象上 的所有属性和方法（继承）。(girl 能访问 Person 的所有属性和方法)<br>
如：构造函数：    Person()<br>
原型：         girl 的 <strong>proto</strong>    、Person.prototype<br>
实例对象：   girl<br>
<img src="https://cutezhangq.github.io/post-images/1596356885891.png" alt="" loading="lazy"><br>
<code>原型链 图示：</code></p>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596356873816.png" alt="" loading="lazy"></figure>
<p>使用 原型 自定义方法：</p>
<pre><code class="language-js">
1.prototype属性 指向：
    每个函数 都有一个prototype属性，它默认指向一个object 空对象（原型对象），Object最终是指向 null 空对象的
        如：Date.prototype  返回的是object    
               function.prototype  返回的也是object   
    原型对象 中有一个 属性constructor ,它指向 函数对象（先指向 构造函数，然后 构造函数 最终指向函数对象）
          如：console.log(Person)
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596356964474.png" alt="" loading="lazy"><br>
2.给原型对象添加属性（一般都是方法）<br>
作用：函数的 所有实例对象 自动拥有 原型中的属性（方法）<br>
原型上面的方法是给实例对象使用的<br>
3.prototype与constructor的关系：    相互引用<br>
<img src="https://cutezhangq.github.io/post-images/1596357057951.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1596357062445.png" alt="" loading="lazy"></p>
<p>4.prototype与__proto__的关系：<br>
怎么让两个引用变量指向同一个对象？（如下图）<br>
让一个引用变量 赋值 给另一个引用变量<br>
<img src="https://cutezhangq.github.io/post-images/1596357094861.png" alt="" loading="lazy"><br>
注：new Fn( ) 就是在实例化对象，实例对象的___proto__属性是 js引擎自动添加的</p>
<p>5.原型链 （隐式原型链）<br>
定义：原型链是由原型对象组成，每个对象都有 <strong>proto</strong> 属性，指向了创建该对象的构造函数的原型，<strong>proto</strong> 将对象连接起来组成了原型链。</p>
<p>作用： 共享属性：访问 一个对象的属性<br>
实现继承 ：构造函数的实例对象自动拥有构造函数原型对象的方法（属性）<br>
空Object的原型对象（null） 是原型链的尽头<br>
属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined；<br>
属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。<br>
<img src="https://cutezhangq.github.io/post-images/1596357121592.png" alt="" loading="lazy"><br>
原型链的 属性 问题：1.读取对象 的属性值时，会自动到原型链中查找2.设置对象 的属性值时：不会查找原型链，如果当前对象中没有此属性，直接添加此属性并设置其值3.方法 一般定义在原型中，属性一般通过构造函数定义在对象本身上理解：函数的 prototype属性：在定义函数时 自动添加，默认值是一个空object对象对象的 ___proto__属性：创建对象时 自动添加（产生的）,执行语句this.<strong>proto</strong> = Fn.prototype      ,默认值为构造函数的prototype属性值  程序员能直接操作显式原型，但不能直接操作隐式原型（ES6之前）   :Foo.prototype={ XXX:YYY  }函数大概像抽象的类，是一个高度概括的封装体；                               （抽象的概括）对象则是某个具体的实例，可以使用抽象体的某些特性，通过 对象 点  的方式使用。    （具体的使用）    所以，在使用对象之前要 构造函数 ，即初始化对象   ，相当于创建出一个具体的实例（new 一个对象）              因为：fun = new Function时 自身的显式原型（构造函数）和隐式原型（实例对象）是相等的</p>
<p>判断某个属性是否 属于原型</p>
<pre><code class="language-js">//判断某个属性是否属于原型
function hasPropertyPrototype(object,name){
  return !object.hasOwnProperty(name) &amp;&amp; (name in object);    //不是object原型上的，但是能在原型链上找到
}
</code></pre>
<h1 id="数组">数组</h1>
<h2 id="q如何对一个数组去重">Q：如何对一个数组去重？</h2>
<pre><code class="language-javascript">//1、Set结构去重。
let set = new Set([1,2,3,4,3,2,1,6,'1',NaN,NaN]);
console.log(set);
//Set(6)
// 0: 1
// 1: 2
// 2: 3
// 3: 4
// 4: 6
// 5: &quot;1&quot;
//6: NaN

//2、遍历，将值添加到新数组，用indexOf()判断值是否存在，已存在就不添加，达到去重效果。
let a = ['1','2','3',1,NaN,NaN,undefined,undefined,null,null, 'a','b','b'];
  let unique = arr =&gt;{
    let newA = [];
    arr.forEach(key =&gt; {
      if(newA.indexOf(key)&lt;0){  //遍历newA是否存在key，如果存在key会大于0就跳过push的那一步
        newA.push(key);
      }
    });
    return newA;
  }
  console.log(unique(a)) ;//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, 1, NaN, NaN, undefined, null, &quot;a&quot;, &quot;b&quot;]
  //ps:这个方法不能分辨NaN,会出现两个NaN。是有问题的，下面那个方法好一点。

  //3、遍历，将数组的值添加到一个对象的属性名里，并给属性赋值，对象不能添加相同属性名，
  //以这个为依据可以实现数组去重，然后用Object.keys(对象)返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组。
//注意：这个方法会将 number,NaN,undefined,null，变为字符串形式，因为对象的属性名就是一个字符串，根据需求来吧，想想还是Set去重最简单也最有效。
  let b = ['1', '2', '3', 1,NaN,NaN,undefined,undefined,null,null, 'a', 'b', 'b'];
  const unique2 = arr =&gt; {
        var obj = {}
        arr.forEach(value =&gt; {
            obj[value] = 0;//这步新添加一个属性，并赋值，如果不赋值的话，属性会添加不上去
        })
        return Object.keys(obj);//`Object.keys(对象)`返回这个对象可枚举属性组成的数组，这个数组就是去重后的数组
    }
    console.log(unique2(b));//[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;NaN&quot;, &quot;undefined&quot;, &quot;null&quot;, &quot;a&quot;, &quot;b&quot;]
</code></pre>
<h1 id="js中-new-操作符干了什么">js中 new 操作符干了什么？</h1>
<ul>
<li>
<ol>
<li>创建了一个空对象</li>
</ol>
</li>
<li>
<ol start="2">
<li>将空对象赋值给this，并将this的__proto__指向构造方法对象的原型</li>
</ol>
</li>
<li>
<ol start="3">
<li>对this这个对象进行属性的添加，并初始化</li>
</ol>
</li>
<li>
<ol start="4">
<li>将this对象返回</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[变量的生命周期 let、var、const]]></title>
        <id>https://cutezhangq.github.io/post/js-bian-liang-de-sheng-ming-zhou-qi-letvarconst/</id>
        <link href="https://cutezhangq.github.io/post/js-bian-liang-de-sheng-ming-zhou-qi-letvarconst/">
        </link>
        <updated>2020-05-19T11:34:39.000Z</updated>
        <content type="html"><![CDATA[<p>具体let、var、consts区别见es6中内容</p>
<h1 id="变量的生命周期">变量的生命周期</h1>
<p>当引擎（如：浏览器中的js引擎）访问变量的时候，它们的生命周期包括下面几个阶段：<br>
1.<strong>声明 阶段</strong>：在作用域中注册一个变量<br>
2.<strong>初始化 阶段</strong>：分配内存，给作用域中的变量创建绑定。在这个阶段，变量自动地被初始化为 undefined<br>
3.<strong>赋值 阶段</strong>：给已经初始化过的变量赋值<br>
通过声明阶段但是没有到达初始化阶段的变量是处于未定义的状态。<br>
<img src="https://cutezhangq.github.io/post-images/1596368154142.png" alt="" loading="lazy"><br>
注意，根据变量的生命周期，声明阶段和一般说的变量声明是不同的术语。<br>
简言之，引擎在这三个阶段处理变量声明：声明阶段、初始化阶段和赋值阶段。</p>
<h1 id="var-变量-的生命周期">var 变量 的生命周期</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596368206711.png" alt="" loading="lazy"><br>
严格来说，提升的概念是在函数作用域的顶部 声明和初始化 变量。在 声明和初始化 阶段之间 没有间隙。</p>
<pre><code class="language-js">function multiplyByTen(number) {  
  console.log(ten); // =&gt; undefined
  var ten;
  ten = 10;
  console.log(ten); // =&gt; 10
  return number * ten;
}
multiplyByTen(4); // =&gt; 40
</code></pre>
<h1 id="函数声明的生命周期">函数声明的生命周期</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596368259214.png" alt="" loading="lazy"><br>
声明、初始化、赋值阶段在 函数作用域 的开始 立刻执行（只有一步）。<br>
funcName()可以在该作用域的任何地方调用，不依赖于声明语句的位置（甚至可以在最后）。</p>
<h1 id="let-变量的生命周期">let 变量的生命周期</h1>
<p>let变量的处理方式和 var 不同。最主要的区别就是声明和初始化阶段被分开了。<br>
<img src="https://cutezhangq.github.io/post-images/1596368317409.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1596368337198.png" alt="" loading="lazy"></p>
<pre><code class="language-js">  let condition = true;  
  // console.log(number); // =&gt; Throws ReferenceError
  let number;
  console.log(number); // =&gt; undefined
  number = 5;
  console.log(number); // =&gt; 5
</code></pre>
<p>const和class类型 和let有相同的生命周期，除了赋值只能发生一次。</p>
<h3 id="为什么提升在let的生命周期里无效">为什么提升在let的生命周期里无效</h3>
<p>如上所述，<code>提升就是变量在作用域顶部进行声明和初始化。</code><br>
但是<code>let的生命周期</code>将 <code>声明和初始化</code> 两个阶段 <code>解耦</code> 了。<code>解耦让提升这个术语失效了</code>。<br>
两个阶段中间的间隙创建了暂时性死区，在这里，变量不能被访问。</p>
<h3 id="暂时性死区">暂时性死区</h3>
<p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<pre><code class="language-js">var tmp = 123;
if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
</code></pre>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。<br>
在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）</p>
<p>随意使用var声明变量容易犯错。基于这个教训，ES2015创建了let。它使用一种改进的算法来声明变量，并且使用块级作用域。<br>
由于声明和定义两个阶段解耦，提升对于一个let声明的变量（包括包括const和class）无效。在初始化之前，变量处于暂时性死区并且不可以访问。<br>
保持稳定的变量声明，有如下建议：</p>
<ul>
<li>声明、初始化，然后再使用变量。这个流程正确并且容易遵守；</li>
<li>尽可能隐藏变量。变量暴露的越少，代码就越模块化。</li>
</ul>
<p>new运算符的执行过程<br>
*  新生成一个对象<br>
*  链接到原型: obj.<strong>proto</strong> = Con.prototype<br>
*  绑定this:  apply<br>
* 返回新对象(如果构造函数有自己 retrun 时，则返回该值)</p>
<h1 id="let-const-var的区别">let const var的区别：</h1>
<h2 id="第一个是声明过程">第一个是声明过程：</h2>
<pre><code>var：遇到有var的作用域，在任何语句执行器都已经完成了声明和初始化，也就是变量提升并且拿到undefined的原因。
let：解析器进入一个块级作用域，发现let关键字，变量只是先完成声明，并没有到初始化那一步。如果此时在作用域提前访问，会报错 xx is not defined，这就是暂时性死区的由来。等到解析到有let那一行时，才会进入初始化阶段。如果let那一行是赋值操作，则初始化和赋值同时进行。
const和 let一样。
</code></pre>
<h2 id="第二个是内存分配">第二个是内存分配：</h2>
<pre><code> var：会直接在栈内存里预分配内存空间，然后等到实际语句执行时，再存储对应的变量，如果传的是引用类型，则在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针
 let：不会在栈内存里预分配内存空间，而且在栈内存分配变量的时候，会检查，如果有相同变量名存在就会报错
const：不会分预配内存空间，栈内存分配变量时也会做同样的检测。const存储的变量是不可修改的，所以对于基本类型来说无法修改定义的值，对于引用类型来说无法修改栈内存里分配的指针，但是可以修改指针指向的对象里面的属性
</code></pre>
<h2 id="第三个是变量提升">第三个是变量提升：</h2>
<pre><code>let只是创建过程中提升，初始化过程并没有提升，所以会产生暂时性死区。
var的创建和初始化过程都提升了，所以赋值前访问会得到undefined
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 模板字符串的前世今生]]></title>
        <id>https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/</id>
        <link href="https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/">
        </link>
        <updated>2020-05-13T08:07:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模板字符串的前世今生">模板字符串的前世今生</h1>
<h2 id="js">JS</h2>
<p>js中，输出模板是这样写的。通过<code>字符串</code>拼接</p>
<pre><code class="language-js">$('#result').append(
 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' +
 'items in your basket, ' +
 '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'
);
</code></pre>
<h2 id="es6">es6</h2>
<p>es6中，输出模板是这样写的。通过<code>${ }嵌入变量</code></p>
<pre><code class="language-js">$('#result').append(`
    There are &lt;b&gt;${basket.count}&lt;/b&gt; items
    in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
    are on sale!
`);
</code></pre>
<h2 id="vue">Vue</h2>
<p>Vue中，输出模板是这样写的。</p>
<pre><code class="language-js">new Vue({
     el:'#replace',
    template:'&lt;p&gt;字符串模板&lt;/p&gt;'
})
</code></pre>
<h2 id="vue20模板的三种写法">Vue2.0模板的三种写法</h2>
<h3 id="第一种利用模板字符串">第一种：利用模板字符串</h3>
<pre><code class="language-js">&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
        el:&quot;#app&quot;,
        data:{ },
        template:`&lt;h1 style=&quot;color:red&quot;&gt;第一种写法&lt;/h1&gt;`
    })
&lt;/script&gt;
</code></pre>
<h3 id="第二种利用template标签实现内容填充通过-id-或者其他的选择器挂载到template上">第二种：利用template标签实现内容填充,通过 id 或者其他的选择器挂载到template上</h3>
<p>通过 id,挂载到template上</p>
<pre><code class="language-js">&lt;template id=&quot;template&quot;&gt;
    &lt;h1&gt;11&lt;/h1&gt;
&lt;/template&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
    ...
    template:&quot;#template&quot;
})
&lt;/script&gt;
</code></pre>
<h3 id="改变script中的type变为typex-template给它id最终挂载到template中">改变script中的type.变为type=&quot;x-template&quot;,给它id,最终挂载到template中</h3>
<p>使用于内容比较多或有公共的模板,可以使用,引入就可以<br>
type=&quot;x-template&quot;，给它id</p>
<pre><code class="language-js">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;x-template&quot; id=&quot;template&quot;&gt;
    &lt;h2&gt;11&lt;/h2&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var app=new Vue({
     ...
    template:&quot;#template&quot;
})
</code></pre>
<h2 id="vue30模板的写法">Vue3.0模板的写法</h2>
<pre><code class="language-js">import Vue from 'vue'
import App from './App.vue'
new Vue({
   ...
    render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue 整理]]></title>
        <id>https://cutezhangq.github.io/post/vue/</id>
        <link href="https://cutezhangq.github.io/post/vue/">
        </link>
        <updated>2020-05-13T07:55:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="vue-简介">Vue 简介</h1>
<p>2014年诞生vue、2013年react、2009年angular<br>
核心：<br>
组件化、<br>
双向数据流（js内存属性变化导致页面的变化、页面的变化影响js内存属性变化）：因为vue是响应式的，会自动更新。<br>
常用指令：v-text、v-html、v-if、v-show<br>
把 vue.js 换成 vue.min.js：可以避免刷新后有时渲染有时不渲染的情况</p>
<pre><code class="language-javascript">&lt;body&gt;
  &lt;div id=&quot;app&quot;&gt;  
    &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
  &lt;/div&gt;
 
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
</code></pre>
<p>一个 渐进式 JS框架（核心库，插件）。官网 https://cn.vuejs.org/</p>
<ul>
<li>作用: 动态构建用户界面</li>
</ul>
<h1 id="注意点">注意点</h1>
<h2 id="路由动画">路由动画</h2>
<p>💥出现问题：动画滑动时，最上面的header元素没有置顶，导致最后动画完成时突然向上移动。<br>
✔️解决：</p>
<pre><code class="language-html">&lt;transition :name=&quot;transitionName&quot;&gt;
    &lt;router-view :Event_Play=&quot;Event_Play&quot; class=&quot;transitionBody&quot;&gt;&lt;router-view&gt;
&lt;/transition&gt;
&lt;style lang=&quot;less&quot;&gt;
.transitionBody {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
 }
 &lt;/style&gt;
</code></pre>
<h1 id="vue-框架怎么实现对象和数组的监听">Vue 框架怎么实现对象和数组的监听？</h1>
<p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p>
<pre><code class="language-js">/**
   * Observe a list of Array items.
   */
  observeArray (items: Array&lt;any&gt;) {
    for (let i = 0, l = items.length; i &lt; l; i++) {
      observe(items[i])  // observe 功能为监测数据的变化
    }
  }

  /**
   * 对属性进行递归遍历
   */
  let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化

</code></pre>
<p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p>
<h1 id="proxy-与-objectdefineproperty-优劣对比">Proxy 与 Object.defineProperty 优劣对比</h1>
<p><strong>Proxy 的优势如下:</strong></p>
<p>Proxy 可以直接监听对象而非属性；<br>
Proxy 可以直接监听数组的变化；<br>
Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；<br>
Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；<br>
Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</p>
<p><strong>Object.defineProperty 的优势如下:</strong></p>
<p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p>
<h1 id="vue-怎么用-vmset-解决对象新增属性不能响应的问题">Vue 怎么用 vm.$set() 解决对象新增属性不能响应的问题 ？</h1>
<p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  来实现为对象添加响应式属性，那框架本身是如何实现的呢？<br>
我们查看对应的 Vue 源码：vue/src/core/instance/index.js</p>
<pre><code class="language-js">export function set (target: Array&lt;any&gt; | Object, key: any, val: any): any {
  // target 为数组  
  if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) {
    // 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误
    target.length = Math.max(target.length, key)
    // 利用数组的splice变异方法触发响应式  
    target.splice(key, 1, val)
    return val
  }
  // key 已经存在，直接修改属性值  
  if (key in target &amp;&amp; !(key in Object.prototype)) {
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__
  // target 本身就不是响应式数据, 直接赋值
  if (!ob) {
    target[key] = val
    return val
  }
  // 对属性进行响应式处理
  defineReactive(ob.value, key, val)
  ob.dep.notify()
  return val
}

</code></pre>
<p>我们阅读以上源码可知，vm.$set 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用   defineReactive 方法进行响应式处理（ defineReactive 方法就是  Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试题]]></title>
        <id>https://cutezhangq.github.io/post/interview-question/</id>
        <link href="https://cutezhangq.github.io/post/interview-question/">
        </link>
        <updated>2020-04-01T01:22:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第-1-题-react-vue-项目时为什么要在列表组件中写-key其作用是什么">第 1 题： React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h1>
<p>😅emm..对这个问题有过疑问，但是一直没有探寻原因，现在梳理一下</p>
<h2 id="答案"><strong>答案</strong></h2>
<p>首先在vue循环遍历生成节点中会使用到key，那么到底要不要使用key，参考官网上的描述：<br>
📃VUE文档:</p>
<ul>
<li>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</li>
</ul>
<p>得出结论，多数情况最好使用key!</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;i in dataList&quot; :key=&quot;i&quot;&gt;{{ i }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>key是用来<code>绑定</code>虚拟节点的，给每一个vnode<code>唯一</code>id。<br>
当不使用key的时候，也可以通过v-for实现以下的dom节点数组<br>
🌰 案例：</p>
<pre><code class="language-js">var vm = new Vue({
  el: '#app',
  data: {
    dataList: [1, 2, 3, 4, 5]
  }
})
</code></pre>
<p>为了方便，标记上id加以说明节点。当数组为[1, 2, 3, 4, 5]时，加key与不加key都如下：</p>
<pre><code class="language-html"> [
    '&lt;div&gt;1&lt;/div&gt;',     // id:  A
    '&lt;div&gt;2&lt;/div&gt;',     // id:  B
    '&lt;div&gt;3&lt;/div&gt;',     // id:  C
    '&lt;div&gt;4&lt;/div&gt;',     // id:  D
    '&lt;div&gt;5&lt;/div&gt;'      // id:  E
  ]
</code></pre>
<p>但是，当数组有变化时，两者就有区别了。<br>
改变dataList数据，进行数据位置替换，对比改变后的数据如下：</p>
<pre><code class="language-javascript"> vm.dataList = [4, 1, 3, 5, 2] // 数据位置替换
 // 没有key的情况， 节点位置不变，但是节点innerText内容更新了
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： A
    '&lt;div&gt;1&lt;/div&gt;', // id:  B
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  D
    '&lt;div&gt;2&lt;/div&gt;'  // id:  E
  ]

  // 有key的情况，dom节点位置进行了交换，但是内容没有更新
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： D
    '&lt;div&gt;1&lt;/div&gt;', // id:  A
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;2&lt;/div&gt;'  // id:  B
  ]
</code></pre>
<p>原因：<code>没有绑定key的情况下，节点会进行复用</code>，即呈现出id没变，内容变化了（<code>就地更新</code>），这样<code>有利于diff速度</code>，但是这种模式会带来一些隐藏的副作用。可能不会产生过渡的效果，某些节点绑定数据（表单）状态时，会出现状态错位。没办法追踪到每个节点。<br>
使用key可以：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<pre><code class="language-html">&lt;transition&gt;
  &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;
&lt;/transition&gt;
</code></pre>
<p>当 text 发生改变时，span总是会被替换而不是被修改，因此会触发过渡。</p>
<p>📃VUE文档也说明了</p>
<ul>
<li>不加key时，<a href="https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81">这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</a></li>
</ul>
<p>增删dataList列表项，对比改变后的数据如下：</p>
<pre><code class="language-html">vm.dataList = [3, 4, 5, 6, 7] // 数据进行增删
  // 1. 没有key的情况， 节点位置不变，内容也更新了
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： A
    '&lt;div&gt;4&lt;/div&gt;', // id:  B
    '&lt;div&gt;5&lt;/div&gt;', // id:  C
    '&lt;div&gt;6&lt;/div&gt;', // id:  D
    '&lt;div&gt;7&lt;/div&gt;'  // id:  E
  ]

  // 2. 有key的情况， 节点删除了 A, B 节点，新增了 F, G 节点
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： C
    '&lt;div&gt;4&lt;/div&gt;', // id:  D
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;6&lt;/div&gt;', // id:  F
    '&lt;div&gt;7&lt;/div&gt;'  // id:  G
  ]
</code></pre>
<p>key是给每一个vnode的唯一id,可以依靠key,<code>更准确</code>, <code>更快</code>的拿到oldVnode中对应的vnode节点。<br>
更快 体现在：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。</p>
<h2 id="扩展"><strong>扩展</strong>：</h2>
<h3 id="diff算法">diff算法</h3>
<h3 id="vue源码">vue源码</h3>
<h1 id="第-2-题1-2-3mapparseint-what-why">第 2 题：['1', '2', '3'].map(parseInt) what &amp; why ?</h1>
<p>emm..map是es6中涉及到的方法，是指不重复的Key-value形式的数据，parseInt是....返回整数的，然并卵...orz🤒</p>
<h2 id="答案-2"><strong>答案</strong></h2>
<p>真正的答案是[1, NaN, NaN]<br>
这题的主要考察，还是arr.map（）方法，和parseInt，对它们一定要深入理解。下面附上MDN官方解释：<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()</a></li>
</ul>
<pre><code class="language-javascript">    var new_array = arr.map(function callback(currentValue[, index[, array]]) {     }[, thisArg])
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585987454821.png" alt="" width="400" height="300" loading="lazy"></figure>
<h3 id="map方法定义">map方法定义</h3>
<p>将数组中的值按顺序调用callback函数，然后由callback返回的数按顺序组成新数组；没有赋值或删除掉的索引不会调用。</p>
<h3 id="map方法使用">map方法使用</h3>
<p>map方法针对<code>新数组</code>的，<code>不会修改原数组</code>，若是对原数组进行操作则使用for-of或forEach。<br>
callback 函数会被自动传入三个参数：<code>数组元素</code>，<code>元素索引</code>，<code>原数组本身</code>。</p>
<p>🙄其实这里主要难度是parseInt，下面一起来研究下叭~<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a></li>
</ul>
<pre><code class="language-javascript">parseInt(string, radix);
</code></pre>
<p>将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。</p>
<h1 id="3原生js使用vuejs时的闪现问题">[3.]原生js使用vue.js时的闪现问题</h1>
<p>原生js中在使用到vue.js时，如使用<code>{{}}</code>会出现闪现问题，会先变成<code>{{message}}</code>显示在页面上，然后再变成需要显示的值。<br>
闪现问题是如何产生的？<br>
因为代码的执行顺序，先编译（编译template代码），再进行数据绑定。<br>
解决办法（2种）避免FOUC (Flash of Uncompiled Content)</p>
<h2 id="v-cloak">v-cloak</h2>
<p><code>v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。</code></p>
<pre><code class="language-html">&lt;style type=&quot;text/css&quot;&gt;
    [v-cloak] {
      display: none;
    }
  &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;p&gt;方法一: v-cloak&lt;/p&gt;
  &lt;!-- 页面加载数据时，原始代码会闪现一下
  加入一段css代码，在view上引用css模块 --&gt;
  &lt;!-- v-cloak 这个指令保持在元素上直到关联实例结束编译。 v-cloak指令可以像CSS选择器一样绑定一套CSS样式然后这套CSS会一直生效到实例编译结束。--&gt;
  &lt;div id=&quot;app&quot; v-cloak&gt;    &lt;!-- &lt;div&gt; 不会显示，直到编译结束。--&gt;
    &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;h1&gt;{{name}}&lt;/h1&gt;
    &lt;!-- 双括号会被编译成textNode的一个v-text指令 --&gt;
  &lt;/div&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
</code></pre>
<h2 id="v-text-取代">v-text 取代 {{}}</h2>
<pre><code class="language-html">&lt;body&gt;
    &lt;p&gt;方法二: v-text&lt;/p&gt;
    &lt;h1 v-text=&quot;message&quot;&gt;&lt;/h1&gt;
    &lt;h1 v-text=&quot;name&quot;&gt;&lt;/h1&gt;
  &lt;/div&gt;
    &lt;!-- vue中我们会将数据包在两个大括号中，然后放到HTML里，但是在vue内部，所有的双括号会被编译成textNode的一个v-text指令。
  而使用v-text的好处就是永远更好的性能，更重要的是可以避免FOUC (Flash of Uncompiled Content) ，也就是上面与遇到的问题。 --&gt;
  &lt;script type=&quot;text/javascript&quot; src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
    //模型数据Model
    var exeData = {
      message: &quot;Hello World&quot;,
      name: &quot;我是Vue&quot;
    };
    //View实例，也就是View-Model(VM)
    new Vue({
      el: &quot;#app&quot;,
      data: exeData
    })
  &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h1 id="4v-if-与-v-show">[4.]v-if 与 v-show</h1>
<p>区别：v-if 的那段代码为false就不编译了，为true才编译；而 v-show 的代码是一定会编译的<br>
使用场景：v-show用于标签切换更频繁的地方，v-if用于初始进行判断是否编译</p>
<h1 id="5computed-和-watch-的区别和运用的场景">[5.]computed 和 watch 的区别和运用的场景？</h1>
<p><strong>computed</strong> ：主要进行<strong>计算</strong>，依赖于其他属性，并且有缓存。只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。computed中的函数必须要用return返回；</p>
<ul>
<li>使用场景：当一个值受多个属性影响的时候————购物车商品结算<br>
<strong>watch</strong>：更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作，<strong>监听一个值的变化，然后执行对应的回调</strong>；<br>
<strong>运用场景：</strong></li>
<li>使用场景：当一条数据的更改影响到多条数据的时候————搜索框。需要监听属性时<br>
总结：</li>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h1 id="6直接给一个数组项赋值vue-能检测到变化吗">[6.]直接给一个数组项赋值，Vue 能检测到变化吗？</h1>
<p>由于 JavaScript 的限制，Vue <strong>不能</strong>检测到以下数组的变动：</p>
<p>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code><br>
当你修改数组的长度时，例如：<code>vm.items.length = newLength</code></p>
<p>为了解决第一个问题，Vue 提供了以下操作方法：</p>
<pre><code class="language-js">// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
 this.$set(this.tableData, this.idx, this.form);    //修改数组的值
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
this.item.splice(1,1,'xx')  //给数组中下标是1的位置添加一个新值‘xx’
</code></pre>
<p>为了解决第二个问题（修改数组长度——添加数据、删除数据），Vue 提供了以下操作方法：</p>
<pre><code class="language-js">// Array.prototype.splice
vm.items.splice(newLength)

var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];
var removed = myFish.splice(2);         //从第 2 位开始删除所有元素
// 运算后的 myFish: [&quot;angel&quot;, &quot;clown&quot;]
// 被删除的元素: [&quot;mandarin&quot;, &quot;sturgeon&quot;]
</code></pre>
<h1 id="7vue-的父组件和子组件生命周期钩子函数执行顺序">[7.]Vue 的父组件和子组件生命周期钩子函数执行顺序？</h1>
<p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p>
<ul>
<li><code>加载渲染过程</code>
<ul>
<li>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</li>
</ul>
</li>
<li><code>子组件更新过程</code>
<ul>
<li>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li>
</ul>
</li>
<li><code>父组件更新过程</code>
<ul>
<li>父 beforeUpdate -&gt; 父 updated</li>
</ul>
</li>
<li><code>销毁过程</code>
<ul>
<li>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</li>
</ul>
</li>
</ul>
<h1 id="8在哪个生命周期内调用异步请求">[8.]在哪个生命周期内调用异步请求？</h1>
<p>分析：ajax就是异步请求，即相当于在问：在那个生命周期中调用ajax请求？<br>
可以在钩子函数<code>created、beforeMount、mounted</code>中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端返回的数据进行赋值。但是<code>推荐</code>在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面 loading 时间；</li>
<li>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性；</li>
</ul>
<h1 id="9在什么阶段才能访问操作dom">[9.]在什么阶段才能访问操作DOM？</h1>
<p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。</p>
<h1 id="10父组件可以监听到子组件的生命周期吗">[10.]父组件可以监听到子组件的生命周期吗？</h1>
<p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：</p>
<pre><code class="language-js">// Parent.vue
&lt;Child @mounted=&quot;doSomething&quot;/&gt;
    
// Child.vue
mounted() {
  this.$emit(&quot;mounted&quot;);
}
</code></pre>
<p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 <code>@hook</code> 来监听即可，如下所示：</p>
<pre><code class="language-js">//  Parent.vue
&lt;Child @hook:mounted=&quot;doSomething&quot; &gt;&lt;/Child&gt;

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     
</code></pre>
<p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。</p>
<h1 id="11谈谈你对-keep-alive-的了解">[11.]谈谈你对 keep-alive 的了解？</h1>
<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p>
<ul>
<li>一般结合路由和动态组件一起使用，用于缓存组件；</li>
<li>提供<code>include</code> 和<code>exclude</code> 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；
<ul>
<li><code>&lt;keep-alive :exclude=&quot;&quot;&gt;</code></li>
</ul>
</li>
<li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li>
</ul>
<h1 id="12组件中-data-为什么是一个函数">[12.]组件中 data 为什么是一个函数？</h1>
<blockquote>
<p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p>
</blockquote>
<pre><code class="language-js">// data
data() {
  return {
	message: &quot;子组件&quot;,
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '&lt;App/&gt;',
  components: {App}
})
</code></pre>
<p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，<br>
如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；<br>
而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。</p>
<h1 id="13v-model-的原理">[13.]v-model 的原理</h1>
<p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ul>
<li>text 和 textarea 元素使用 value 属性和 input 事件；</li>
<li>checkbox 和 radio 使用 checked 属性和 change 事件；</li>
<li>select 字段将 value 作为 prop 并将 change 作为事件。</li>
</ul>
<p>以 input  表单元素为例：</p>
<pre><code class="language-html">&lt;input v-model='something'&gt;
</code></pre>
<p>相当于</p>
<pre><code class="language-html">&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something = $event.target.value&quot;&gt;
</code></pre>
<p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：<br>
父组件：</p>
<pre><code class="language-html">&lt;ModelChild v-model=&quot;message&quot;&gt;&lt;/ModelChild&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-js">&lt;div&gt;{{value}}&lt;/div&gt;

props:{
    value: String
},
methods: {
  test1(){
     this.$emit('input', '小红')
  },
},
</code></pre>
<h1 id="14q标准盒子模型与ie怪异盒子模型">[14.]Q：标准盒子模型与IE怪异盒子模型</h1>
<p>这个问题主要会出现在笔试题上面，比如：</p>
<pre><code class="language-javascript">&lt;div style=&quot;width:100px;height=&quot;100px;border:10px;padding:10px;&quot;&gt;&lt;/div&gt;
</code></pre>
<p>这个盒子在w3c标准盒子模型和IE的怪异盒子模型下面它的宽度分别是多少？</p>
<pre><code class="language-javascript">标准盒子模型：总宽度=content100px+border 10px*2+padding 10px*2 //140px
怪异盒子模型: 总宽度=content60px+ border 10px*2+padding 10px*2 //100px
</code></pre>
<p>怪异盒子：box-sizing：border-box将div的width就是width赋值的宽<br>
标准盒子：宽度为width的宽加上border和padding</p>
<h1 id="15闭包">[15.]闭包</h1>
<p><img src="https://cutezhangq.github.io/post-images/1596370324100.png" alt="" loading="lazy"><br>
注：关键看有没有产生新的闭包<br>
结果：<br>
<img src="https://cutezhangq.github.io/post-images/1596370348698.png" alt="" loading="lazy"><br>
补充：<br>
通过闭包---立即执行函数，生成块级作用域</p>
<pre><code class="language-js">&lt;body&gt;
    &lt;button&gt;测试1&lt;/button&gt;
    &lt;br&gt;
    &lt;button&gt;测试2&lt;/button&gt;
    &lt;br&gt;
    &lt;button&gt;测试3&lt;/button&gt;
    &lt;br&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
//使用var:
    let bottons = document.getElementsByTagName('button');
    //1.
    for(var j = 0;j&lt;  bottons.length;j++){
      var botton = bottons[j];
      botton.onclick = function(){
        alert(j)    //输出都是3
        //点击事件对应回调函数，回调函数会被放入事件队列中，等主线程代码执行完了，才将回调函数&quot;钩&quot;出来去执行
        //回调函数（钩子函数）
      }
    }
    //2.使用闭包解决问题：
        //----闭包产生条件：1.函数嵌套  2调用外部函数
    for(var k= 0;k&lt; bottons.length;k++){
      var botton = bottons[k];
      (function(k){     //()()立即执行函数
        botton.onclick = function(){
        alert(k)         //点击每个按钮一次输出0,1,2   
        }
      })(k) //立即执行函数有其自己的作用于（私有作用域），每执行一次有一个自己的函数作用域
    }
&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>使用闭包的注意点1.由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退     出函数之前，将不使用的局部变量全部删除.<br>
2.闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当     作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
<h1 id="16使用过-vue-ssr-吗说说-ssr">[16.]使用过 Vue SSR 吗？说说 SSR？</h1>
<blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。<br>
即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
</blockquote>
<p>** 服务端渲染 SSR 的优缺点如下：**<br>
** （1）服务端渲染的优点：**</p>
<ul>
<li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li>
<li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li>
</ul>
<p>** （2) 服务端渲染的缺点： **</p>
<ul>
<li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li>
<li>更多的服务器负载：在 Node.js  中渲染完整的应用程序，显然会比仅仅提供静态文件的  server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<h1 id="17vue-router-路由模式有几种">[17.]vue-router 路由模式有几种？</h1>
<p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p>
<pre><code class="language-js">switch (mode) {
  case 'history':
	this.history = new HTML5History(this, options.base)
	break
  case 'hash':
	this.history = new HashHistory(this, options.base, this.fallback)
	break
  case 'abstract':
	this.history = new AbstractHistory(this, options.base)
	break
  default:
	if (process.env.NODE_ENV !== 'production') {
	  assert(false, `invalid mode: ${mode}`)
	}
}
</code></pre>
<p>其中，3 种路由模式的说明如下：</p>
<ul>
<li>
<p>hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</p>
</li>
<li>
<p>history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p>
</li>
<li>
<p>abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p>
</li>
</ul>
<h1 id="18能说下-vue-router-中常用的-hash-和-history-路由模式实现原理吗">[18.]能说下 vue-router 中常用的 hash 和 history 路由模式实现原理吗？</h1>
<p><strong>（1）hash 模式的实现原理</strong><br>
早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'：</p>
<pre><code class="language-cmd">https://www.word.com#search
</code></pre>
<p>hash  路由模式的实现主要是基于下面几个特性：</p>
<ul>
<li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li>
<li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li>
<li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li>
<li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。<br>
<strong>（2）history 模式的实现原理</strong><br>
HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</li>
</ul>
<pre><code class="language-js">window.history.pushState(null, null, path);
window.history.replaceState(null, null, path);
</code></pre>
<p>history 路由模式的实现主要基于存在下面几个特性：</p>
<ul>
<li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li>
<li>我们可以使用 popstate  事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li>
<li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li>
</ul>
]]></content>
    </entry>
</feed>