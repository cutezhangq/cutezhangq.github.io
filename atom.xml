<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-08-30T02:28:13.443Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[排序算法（上）]]></title>
        <id>https://cutezhangq.github.io/post/pai-xu-suan-fa-shang/</id>
        <link href="https://cutezhangq.github.io/post/pai-xu-suan-fa-shang/">
        </link>
        <updated>2020-08-30T02:18:15.000Z</updated>
        <summary type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>前端常见的排序算法，共有10种😘</p>
<!-- more -->
<p><img src="https://cutezhangq.github.io/post-images/1598754120978.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1598754150521.png" alt="" loading="lazy"></p>
<h1 id="一冒泡排序">（一）：冒泡排序</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1598754182443.png" alt="" loading="lazy"></figure>
<p>冒泡排序（Bubble Sort）是一种简单直观的排序算法。冒泡排序算法的步骤描述如下：（<strong>相邻元素 比较 交换位置</strong>）</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="具体实现">具体实现：</h3>
<pre><code class="language-js"> //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}  

</code></pre>
<p>案例：</p>
<pre><code class="language-js">  //冒泡排序:   数组中的相邻元素，两两比较，数值或者 Unicode 码小的元素往前排
  var bubbleSort = function(arr){
    var i,j,m;
    var len = arr.length;
    if(len &lt;= 1){
      return arr;
    }

    for(i = 0;i&lt;len - 1;i++){ //循环2层：两两比较
      for(j=0;j&lt;len-1;j++){
        if(arr[j] &gt; arr[j+1]){  //当前一个比后一个大了
          [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        }
      }
      console.log(`第${i+1}次循环————`, arr);
    }
    return arr;
  }
const testArr = [11,4,6,52,3,20,1,9,2,5,19,3,6,21]
console.log('————冒泡排序——————',bubbleSort(testArr));
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598754314075.png" alt="" loading="lazy"></figure>
<h2 id="优化单向冒泡实现">优化：单向冒泡实现</h2>
<p>如果数组原本的顺序就是冒泡的，又或者仅做完前面寥寥几次就已经达到效果了，那后续的比较工作就显得有些多余了，如何对以上算法进行改进？<br>
我们可以在某一轮的循环比较结束后，<strong>如果没有发生任何的元素交换，则可以认为该数组已经达到预期效果，不必再继续下一轮的比较了</strong>。</p>
<pre><code class="language-js">var bubbleSort2 = function(arr){
  var start = + new Date();
  var i,j,m,noswap; //noswap没有交换
  var len = arr.length;
  if(len &lt;= 1){
    return arr;
  }

  for(i=0;i&lt;len-1;i++){
    noswap = true;  //未交换
    for(j=0;j&lt;len-1;j++){
      if(arr[j] &gt; arr[j+1]){  
          m = arr[j];         
          arr[j] = arr[j+1];
          arr[j+1] = m;
          noswap = false; //交换了
        }
    }
    if(noswap){
      break;
    }
  }
  // 当 arr 的长度越长，时间差越明显
  console.log(+new Date() - start);
  return arr;
}
const testArr2 = [11,4,6,52,3,20,1,9,2,5,19,3,6,21,105,22,33,44,88,22,1,2,0,3,9,4,100,103,98]
console.log('————改进版冒泡排序——————',bubbleSort2(testArr2));
// 0
// ————改进版冒泡排序—————— (29) [0, 1, 1, 2, 2, 3, 3, 3, 4, 4, 5, 6, 6, 9, 9, 11, 19, 20, 21, 22, 22, 33, 
44, 52, 88, 98, 100, 103, 105]

</code></pre>
<h2 id="优化双向冒泡实现">优化：双向冒泡实现</h2>
<p>普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，双向冒泡排序则是<code>多一轮的筛选</code>，即找出<code>最大值也找出最小值</code>。</p>
<pre><code class="language-js"> //算法改进————————双向冒泡实现
    // 普通的冒泡排序，在一轮循环中只能找到最大值或者最小值的其中一个，
    // 双向冒泡排序则是多一轮的筛选，即找出最大值也找出最小值。
  let testArr3 = [1, 6, 7, 4, 5, 8, 9, 0, 2, 3];
  let res = bubbleSortTow(testArr3)
  console.log(res);

  function bubbleSortTow(arr) {
    let low = 0;
    let high = arr.length - 1;
    while(low &lt; high){
      let mark = true;
      // 找到最大值放到右边
      for (let i = low; i &lt; high; i++) {
        if (arr[i] &gt; arr[i + 1]) {
          [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
          mark = false;
        }
      }
      high--;
      // 找到最小值放到左边
      for (let j = high; j &gt; low; j--) {
        if (arr[j] &lt; arr[j - 1]) {
          [arr[j], arr[j - 1]] = [arr[j - 1], arr[j]];
          mark = false;
        }
      }
      low++;
      console.log(mark);
      console.log(`第${low}次循环`, arr);
      if (mark) 
        return arr;
    }
  }
</code></pre>
<h3 id="性能比较">性能比较</h3>
<p>对三种排序的算法进行性能的比较：发现<br>
<code>单向冒泡排序性能 &gt; 双向冒泡排序性能 &gt; 大于普通冒泡性能。</code>（产生时间具体取决于所使用的系统）</p>
<h3 id="时间度复杂度分析">时间度复杂度分析:</h3>
<figure data-type="image" tabindex="3"><img src="https://cutezhangq.github.io/post-images/1598754429691.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[逻辑题]]></title>
        <id>https://cutezhangq.github.io/post/luo-ji-ti/</id>
        <link href="https://cutezhangq.github.io/post/luo-ji-ti/">
        </link>
        <updated>2020-08-21T07:37:32.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录一些小的逻辑题或算法题👀，啊啊啊，血的教训😰，思考方式很重要</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录一些小的逻辑题或算法题👀，啊啊啊，血的教训😰，思考方式很重要</p>
<!-- more -->
<h1 id="关于取火柴棒问题取胜方法的一些思考">关于取火柴棒问题取胜方法的一些思考</h1>
<p>取火柴棒游戏的问题叙述:<br>
桌上有<strong>n根</strong>火柴棒,甲乙<strong>两人</strong>按照如下规则轮流取走这些火柴棒:</p>
<ul>
<li>1.<code>每次只允许取走1~2根火柴棒</code>;</li>
<li>2.<code>最后一次取走火柴棒的人获胜</code>;</li>
</ul>
<p>若甲先取,且甲想要取胜,那么可以考虑如下一种策略(我们姑且就称之为<code>策略A</code>吧):</p>
<pre><code class="language-cmd">甲先取,之后乙取,若乙取1个火柴棒,那么之后甲就取2个火柴棒;若乙取2个火柴棒,则甲取1个火柴棒,
总之就是保证甲+乙=3,那么,就产生了如下3种情况:
</code></pre>
<h2 id="1n3k1k是整数">1)n=3k+1,k是整数:</h2>
<p>这种情况下,甲要取胜,方法为:<code>先取1个火柴棒</code>(这是最后一个1),那么还剩下3k个火柴棒,之后采取策略A.这样,就能<code>保证每回合都取走3个</code>,且甲取后一次.以此类推,甲就一定能取胜.</p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
</tr>
<tr>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
</tr>
</tbody>
</table>
<h2 id="2n3k2k是整数">2)n=3k+2,k是整数:</h2>
<p>这种情况下,甲要取胜,方法为:<code>先取2个火柴棒</code>,那么还剩下3k个火柴棒,之后采取策略A.这样,就能<code>保证每回合都取走3个</code>,且甲取后一次.以此类推,甲就一定能取胜.</p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
<th>|</th>
</tr>
</thead>
<tbody>
<tr>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
</tr>
<tr>
<td>M</td>
<td>M</td>
<td>Y</td>
<td>Y</td>
<td>M</td>
<td>Y</td>
<td>M</td>
<td>M</td>
</tr>
</tbody>
</table>
<h2 id="3n3kk是整数">3)n=3k,k是整数;</h2>
<p>这种情况下,<code>甲要么先取1个,要么先取2个</code>.剩下的就是:<code>3k-1或者3k-2</code>;而3k-1=(3k+2)-3; 3k-2=(3k+1)-3 在这种情况下,甲是必输的.因为这个问题可以<code>等价于</code><strong>乙先取3k-1或3k-2个火柴棒</strong>,也就是3k+2或3k+1个火柴棒,这与上述1),2)的情况是一样的.所以,这种情况下,<code>甲必输</code></p>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
<th style="text-align:center">|</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">M</td>
<td style="text-align:center">M</td>
<td style="text-align:center">Y</td>
</tr>
</tbody>
</table>
<h3 id="总结">总结:</h3>
<p>在甲先取的情况下,胜负如下</p>
<ul>
<li>1)若n=3k+1或者n=3k+2</li>
</ul>
<p>甲采取策略A必胜</p>
<ul>
<li>2)若n=3k</li>
</ul>
<p>乙一定能用策略A取得胜利,亦即乙必胜.</p>
<h2 id="进一步推广取火柴棒问题描述如下">进一步推广取火柴棒问题,描述如下:</h2>
<p>桌上有<code>n个</code>火柴棒,甲乙两人按照如下规则轮流取走这些火柴棒:</p>
<p><code>1)每次只允许取走1~m个火柴棒;</code></p>
<p><code>2)最后一次取走火柴棒的人获胜;</code></p>
<p>我们可以从上面的推理中类推出此问题的解,取胜方法策略为(我们姑且称之为<code>策略B</code>):</p>
<p>若甲先取,且甲想取胜</p>
<p>甲先取若干个火柴棒,之后乙取,若乙取1个火柴棒,那么之后甲就取m个火柴棒;若乙取2个火柴棒,则甲取m-1个火柴棒......总之就是保证<code>甲+乙=m+1</code>,那么,就产生了如下m+1种情况:</p>
<h2 id="1nm1k1k是整数">1)n=(m+1)*k+1,k是整数;</h2>
<p>甲先取1个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<h2 id="2nm1k2k是整数">2)n=(m+1)*k+2,k是整数:</h2>
<p>甲先取2个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<h2 id="">......</h2>
<h2 id="mnm1kmk是整数">m)n=(m+1)*k+m,k是整数:</h2>
<p>甲先取m个火柴棒,那么还剩下(m+1)*k个火柴棒,之后采取策略B,这样,就能保证每回合都取走m+1个,且甲取后一次.以此类推,甲就一定能取胜.</p>
<p>m+1)n=(m+1)*k,k是整数:</p>
<p>这种情况下,甲要么先取1个,要么先取2个,要么先取3个,......要么先取m个,那么分别还剩下:(m+1)*k-1,(m+1)*k-2,(m+1)*k-3,......,(m+1)*k-m个火柴棒,亦即<code>[(m+1)*k+m]-(m+1),......,[(m+1)*k+1]-(m+1)</code>个火柴棒.这相当于上面的1)~m)这m种情况,只不过先取的是乙,这种情况下,乙必胜.</p>
<h3 id="总结-2">总结:</h3>
<p>甲先取,且甲想取胜</p>
<ul>
<li>1)若n=(m+1)*k+1,(m+1)*k+2,......,(m+1)*k+m</li>
</ul>
<p>采取上述策略,甲一定能取得胜利</p>
<ul>
<li>2)若n=(m+1)*k</li>
</ul>
<p>乙采取上述策略,乙一定能取得胜利.</p>
<blockquote>
<p>从上面的结论,我们可以看到,只有一种情况下,乙是必胜的,那就是n=(m+1)*k,其余都是甲必胜,可见,甲必胜的概率随着m的增加而不断变大,同时,我们也可以看出,先手者胜率高.</p>
</blockquote>
<p>👉考察了<code>逆向来思考</code>能力【反向逆推法】，数据之间产生关系（相加）规律，</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔试-题目整理2-2020bilibili ]]></title>
        <id>https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/</id>
        <link href="https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/">
        </link>
        <updated>2020-08-14T07:18:46.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
<!-- more -->
<h1 id="1关于domcontentloaded和load事件说法正确的是">【1.】关于DOMContentLoaded和load事件说法正确的是？</h1>
<p>A DOMContentLoaded事件比load事件更早执行<br>
B load事件比DOMContentLoaded事件更早执行<br>
C 按监听代码从上到下先后执行<br>
D dom文档完全加载完后执行load事件</p>
<h2 id="答案a-domcontentloaded事件比load事件更早执行">答案：A DOMContentLoaded事件比load事件更早执行</h2>
<p><strong>DOMContentLoaded</strong>：DOM解析完成之后。<br>
当纯HTML被完全加载以及解析时，DOMContentLoaded事件会被触发，而不必等待样式表，图片或者子框架完成加载。</p>
<pre><code class="language-cmd">MDN
当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。
</code></pre>
<p><strong>load</strong>：页面HTML、CSS、JS..及图片等外链资源加载完成之后，才会执行load。<br>
当一个资源及其依赖资源已完成加载时，将触发load事件。</p>
<h1 id="2如何在-div-容器里展示-divdiv-这几个字符">【2.】如何在 div 容器里展示 <div></div> 这几个字符？</h1>
<h2 id="答案documentqueryselectordivinnertext-divdiv">答案：document.querySelector('div').innerText = &quot;<div></div>&quot;</h2>
<pre><code class="language-html">  &lt;!--  innerHTML：设置或获取标签所包含的HTML与文本信息。（不含标签本身）
        innerText：设置或获取标签所包含的文本信息。（不含标签本身）
        outerHTML：设置或获取标签本身以及所包含的HTML与文本信息。（包含标签本身）
        outerText：设置或获取标签本身以及所包含的文本信息。（包含标签本身） --&gt;

&lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
&lt;/div&gt;
    &lt;script&gt;
        var div=document.getElementsByTagName(&quot;div&quot;);
        console.log(div[0].innerHTML);      //  &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
        console.log(div[0].innerText);         //  this is text
        console.log(div[0].outerHTML);     // &lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;&lt;/div&gt;
        console.log(div[0].outerText);        //  this is text
    &lt;/script&gt;
</code></pre>
<h1 id="3以下不是box-sizing的属性是">【3.】以下不是box-sizing的属性是？</h1>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>content-box</td>
<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>
</tr>
<tr>
<td>border-box</td>
<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应从父元素继承 box-sizing 属性的值。</td>
</tr>
</tbody>
</table>
<h2 id="box-sizing">box-sizing</h2>
<p>box-sizing 最主要的用法是规定容器元素的<strong>最终尺寸计算方式。</strong></p>
<p>如果你创造了一个 <code>&lt;div&gt;</code> 没有设置 <code>box-sizing</code>属性为<code>border-box</code>(不设置的话默认值为 <code>content-box</code>)，同时你设置 <code>width:100px; border:10px solid red; padding:10px;</code>那么最终 div 容器的实际宽度为：</p>
<pre><code class="language-js">100px(width)+2*10px*(padding)+2*10px(border)=140px
</code></pre>
<p>所以你会得到一个比你预期（100px）还要更大的容器，结果就是会破坏网页布局。<br>
注意：容易 margin 的尺寸不会被计算入最终容器宽度，因为对他的定义为对这个容器的留白，但不属于容器本身。</p>
<p>如果当我们定义一个容器的 <code>box-sizing</code>属性为<code>border-box</code>时<br>
（表达式：<code>br{box-sizing:border-box}</code>），那么我们创建一个和上段中相同设置的<code>&lt;div&gt;</code>容器时，那么他的最终宽度即为 100px, 那么它的内容部分（content）的有效宽度变成了</p>
<pre><code class="language-js">100px-2*10px-2*10px =60px; 
</code></pre>
<p>所以你会得到一个你预期大小的盒子容器，但是只是被压缩了内容部分尺寸而已，但是对于整体布局而言益处颇多。</p>
<p>所以要合理利用好这个属性，这个属性十分重要。</p>
<!-- more -->
<h1 id="4-1-32-的值为">【4.】‘-1 &gt;&gt;&gt; 32 的值为(  )’</h1>
<p>emm...知识盲区😳😳😳</p>
<h2 id="答案232-1">答案：2^32-1</h2>
<pre><code class="language-cmd">&gt;&gt;这个是带符号右移
&gt;&gt;&gt; 这个是无符号右移
无符号右移运算符（&gt;&gt;&gt;）
</code></pre>
<p><code>按二进制形式把所有的数字向右移动对应位数，低位移出(舍弃)，高位的空位补零。对于正数来说和带符号右移（&gt;&gt;） 相同，但是对于负数来说不同。</code><br>
<strong>正数</strong><br>
例：20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为0001 0100<br>
2、<code>将二进制数向右移两位，高位补符号位（0）</code>，得到0000 0101<br>
3、最后<code>将二进制数转化成十进制数</code>，0000 0101转化为十进制为5<br>
所以，20 &gt;&gt; 2 = 5</p>
<p><strong>负数</strong><br>
例：-20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为1110 1100   //<code>取反加1</code>  20的二进制为0001 0100 取反得到1110 1011 加1后得到1110 1100<br>
2、将<code>二进制数向右移两位，高位补符号位（1）</code>，得到1111 1011<br>
3、最后<code>将二进制数转化成十进制数</code>，1111 1011转化为十进制为-5  //取反 0000 0100 加1   0000 0101 因为是负数，也就是1000 0101也就是2的2次方加2的零次方 等于-5<br>
所以，-20 &gt;&gt; 2 = -5</p>
<p><code>1</code>的二进制 00000000 00000000 00000000 00000001<br>
<code>-1</code>的二进制 10000000 00000000 00000000 00000001 取反加1得到补码 11111111 11111111 11111111 11111111  //首位不变，其余为取反<br>
右移32位（高位补符号位1） 也就是11111111 11111111 11111111 11111111  //32位<br>
假设该数值加上一也就是变成<br>
1 00000000 00000000 00000000 00000000  //1后面有32个0<br>
那就把刚才加上的1减掉<br>
也就是结果<br>
2^32-1<br>
<img src="https://cutezhangq.github.io/post-images/1597476991984.png" alt="" loading="lazy"></p>
<h1 id="51-2-3mapparseint">【5.】['1', '2', '3'].map(parseInt) ( )</h1>
<h2 id="答案1-nan-nan">答案：[1, NaN, NaN]</h2>
<pre><code class="language-js">['1', '2', '3'].map((item, index) =&gt; {
    return parseInt(item, index)
})
parseInt('1', 0) // 1  默认十进制的1
parseInt('2', 1) // NaN 1进制没有2
parseInt('3', 2) // NaN,2进制逢2进1
</code></pre>
<p>ps 啥是parseInt<br>
parseInt('11',2) //二进制的11 转换成十进制应该是 3</p>
<p>['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4]<br>
意思是0(默认0是十进制)进制的十转换成十进制是多少 1进制的十转换成十进制是多少 二进制的10转换成十进制是多少...</p>
<pre><code class="language-js">['1','2','3'].map((a,b,arr)=&gt;{  //a:循环得到的那一项的值；b:循环时的索引; arr整个数组的值
    parseInt(a,b);  //a代表那一项； b代表进制
})
// parseInt(string, radix)   
// 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。
parseInt('1', 0) // radix 为 0，默认以十进制解析字符串，返回 1 

parseInt('2', 1) // radix 为 1，不在 2 ~ 36 之间，返回 NaN 

parseInt('3', 2) // radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN
//2 进制只有0和1，，，3超出范围了
</code></pre>
<h1 id="6计算结果">【6.】计算结果</h1>
<pre><code class="language-js">console.log(1);
setTimeout(() =&gt; {console.log(2)}, 0);
console.log(3);
Promise.resolve(4).then(b =&gt; {
console.log(b);
});
console.log(5);
</code></pre>
<h2 id="答案1-3-5-4-2">答案：1 3 5 4 2</h2>
<p><code>console.log()</code> -&gt; <code>同步</code><br>
<code>promise</code>-&gt; <code>异步，微任务</code><br>
<code>setTimeout</code> -&gt; <code>异步，宏任务</code><br>
执行顺序:<code>同步</code> &gt;<code>异步,微任务</code> &gt; <code>异步，宏任务</code></p>
<h1 id="7mathabs-6666-的结果是多少">【7.】Math.abs(-6.666) 的结果是多少?</h1>
<h2 id="答案6666">答案：6.666</h2>
<p><code>Math.abs()</code>转为为绝对值</p>
<p><code>parseInt(7/2)</code>丢弃小数部分,保留整数部分</p>
<p><code>Math.ceil(7/2)</code>向上取整,有小数就整数部分加1</p>
<p><code>Math.round(7/2)</code>四舍五入</p>
<p><code>Math.floor(7/2)</code>向下取整</p>
<h1 id="812345-的数组的基础上-删除第一个-和-最后一位">【8.】[1,2,3,4,5] 的数组的基础上 删除第一个 和 最后一位</h1>
<p>[1,2,3,4,5].replace(1, -1)<br>
[1,2,3,4,5].reverse(1，-1)<br>
[1,2,3,4,5].toString(-1，1)<br>
[1,2,3,4,5].slice(1, -1)</p>
<h2 id="答案12345slice1-1">答案：[1,2,3,4,5].slice(1, -1)</h2>
<p><code>slice(1,-1)</code>  slice不会操作原数组，会返回一个新数组 。 表示从索引为0开始截取，-1表示截取到倒数第二个，并将这个新数组返回。</p>
<p><code>replace</code>方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。原字符串不会改变。</p>
<p><code>reverse</code>方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p>
<h1 id="9计算结果">【9.】计算结果</h1>
<pre><code class="language-js">function setname(name){
 this.name = name
}
setname.prototype.printName = function(){ console.log(this.name) }
let a = new setname(&quot;cc&quot;)
a.name = &quot;dd&quot;
a.__proto__.name = &quot;ee&quot;

a.__proto__.printName()  // ?
a.printName() // ?
</code></pre>
<h2 id="答案ee-dd">答案：ee dd</h2>
<p>首先定义了一个函数 setname（）接下来定义了一个方法printname<br>
调用new 方法生成对象传参 “cc” 此时a对象上面的name属性为cc<br>
<img src="https://cutezhangq.github.io/post-images/1597559456328.png" alt="" loading="lazy"><br>
接下来通过a.name修改属性 此时a对象的name属性为 dd<br>
<img src="https://cutezhangq.github.io/post-images/1597559495746.png" alt="" loading="lazy"><br>
最后修改通过a修改构造函数中的属性 --proto--<br>
<img src="https://cutezhangq.github.io/post-images/1597559529281.png" alt="" loading="lazy"></p>
<h1 id="输入">输入</h1>
<pre><code class="language-js">    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    rl.on('line',(line)=&gt;{
      console.log();
    })
</code></pre>
<h1 id="10找出有序数组从小到大排列中和为sum的两个数要求复杂度为on找到一组即可">【10.】找出有序数组（从小到大排列）中和为sum的两个数，要求复杂度为O(n)，找到一组即可</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1597739669645.png" alt="" loading="lazy"></figure>
<p>可以采用<code>暴力枚举</code>,即2层for循环——但是<code>复杂度</code>就不符合了<br>
<strong>从小到大排列</strong>——想起<strong>二分查找</strong>的思想（从数组的第一个查找i；从数组的最后一个查找j）</p>
<pre><code class="language-js">//[1    3   4   6       8]
//13    14  16  18  34  36  46  48  
//10
//头 i
//尾 j
//  1+8 = 9 &lt;10 数组从小到大排列的，需要挪动数组，考虑移动i还是j，因为从小到大排列，所以i++
//  3+8 = 11 &gt;10 比目标值大了，要想办法减小，j--
//  3+6 = 9 &lt;10 进行i++
//  4+6 = 10 = 10 找到了，返回4和6
</code></pre>
<p>答案：</p>
<pre><code class="language-js">   //没找到，i往后走，j往前走
    //javascript(node)运行
    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    const maxLine = 3;
    let input = []; //放数组的
    function solution(input){
      //input[1].split(' ')取出第一个输入的数字，以空格将其分开
      //.map(e =&gt; parseInt(e))将切出的字符串转换为数字
      const arr = input[1].split(' ').map(e =&gt; parseInt(e));  
      //sum拿到数组的最后一项
      const sum = parseInt(input[2]);
      const len = arr.length;
      let i = 0;  //头指针
      let j = len - 1;  //尾指针
      while(i&lt;j){
        let res = arr[i] + arr[j];
        //如果找到了
        if(res === sum) return `${arr[i]} ${arr[j]}`
        //如果没找到
        if(res &lt; sum){
          i++;
        }
        if(res &gt; sum){
          j--;
        }
      }
      return 'notfound' //数组中没找到
    }
    rl.on('line',(line)=&gt;{
      input.push(line);
      if(input.length === maxLine){
        console.log(solution(input));
        rl.close();
      }
    })
</code></pre>
<h1 id="11判断由6种括号组成的字符串是否合法">【11.】判断由&quot;()[]{}&quot;6种括号组成的字符串是否合法</h1>
<ol>
<li>所有括号必须闭合</li>
<li>左括号必须在正确的位置闭合<br>
<img src="https://cutezhangq.github.io/post-images/1597739560221.png" alt="" loading="lazy"></li>
</ol>
<h1 id="12有n级台阶每一步可以走1级或2级问一共有多少种走法">【12.】有n级台阶，每一步可以走1级或2级，问一共有多少种走法</h1>
<p><img src="https://cutezhangq.github.io/post-images/1597739843040.png" alt="" loading="lazy"><br>
答案：</p>
<pre><code class="language-js">   //20 走法(18走法+19走法)
      //18走法 + 2 = 20 或 
      //19走法 + 1 = 20
    //19
      //17 + 2 = 19 或 18 + 1 = 19

    //1
      //1
    //2
      //1 或 2
    //3
      //1走法+2走法
    //...


    //1 2 3 4 ... 18  19  20  ——————后面的走法为前两个走法之 和 ——————斐波那契数列
    const readline = require('readline');
    const rl = readline.createInterface({
      input:process.stdin,
      output:process.stdout
    })
    function solution(step){
      step = parseInt(step);
      function walk(n){
        if(n &lt; 1){    //没有台阶
          return 0
        }
        if(n === 1) return 1; //只有一个台阶
        if(n === 2) return 2;
        return walk(n-1) + walk(n-2);
      }
      return walk(step);
    }
    rl.on('line',(line)=&gt;{
      console.log();
    })
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇淫巧技]]></title>
        <id>https://cutezhangq.github.io/post/qi-yin-qiao-ji/</id>
        <link href="https://cutezhangq.github.io/post/qi-yin-qiao-ji/">
        </link>
        <updated>2020-08-11T01:49:25.000Z</updated>
        <summary type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
<!-- more -->
<h1 id="对数据进行奇偶判断">对数据进行奇偶判断</h1>
<p>普通选手：</p>
<pre><code class="language-js">const n = 11;
if(n%2 == 1){
   console.log('奇数')
}else{
    console.log('偶数')
}
</code></pre>
<p>种子选手：&amp; 位运算符的妙用，相“与”</p>
<pre><code class="language-js">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="判断类型-封装可判断所有类型">判断类型 封装（可判断所有类型）</h1>
<p>普通选手：</p>
<pre><code class="language-js">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>种子选手：<br>
判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。<br>
因此要真正完美判断时，我们需要区分对待:<br>
* 基本类型( null ): 使用String( )，如：String(null)<br>
* 基本类型(string / number / boolean / undefined) + function + symbol: 直接使用 typeof 即可<br>
* 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断，本质上还是调用 valueof 进行判断。</p>
<pre><code class="language-js"> let class2type = {}
  'Array Date RegExp Object Error'.split(' ').forEach(e =&gt; class2type['[object ' + e + ']'] = e.toLowerCase())

  function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[Object.prototype.toString.call(obj)] || 'object' : typeof obj
  }
</code></pre>
<p>这里的.call是绑定this对象指向当前的Object对象<br>
**RegExp：**是正则表达式（regular expression）的简写。</p>
<h1 id="判断是否存在">判断是否存在</h1>
<pre><code class="language-js">  if(typeof a!=&quot;undefined&quot;){     //不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错
      xxx
    }
</code></pre>
<h1 id="检测-某个对象-是不是-另一个对象-的-实例">检测 某个对象 是不是 另一个对象 的 实例</h1>
<p>（测试一个对象在其原型链中是否存在一个构造函数的prototype属性）</p>
<pre><code class="language-js">  function test(){};
  var b = new test();
  var c = new test();
  console.log(b instanceof test); //true   可用来判断一个变量是否是某个对象的实例
  console.log(c == b);  //false
</code></pre>
<h1 id="判断一个-实例-是否属于它的-父类型">判断一个 实例 是否属于它的 父类型</h1>
<p>instanceof 可以在 继承关系 中用来判断一个 实例 是否属于它的 父类型。</p>
<pre><code class="language-js"> var a = new Array();  
 console.log(a instanceof Array);  //true
 console.log(a instanceof Object); //true  因为 Array 是 Object的 子类
</code></pre>
<h1 id="判断-对象是否为空-的三种方法">判断 对象是否为空 的三种方法：</h1>
<pre><code class="language-js">  //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }


  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象


  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
    //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
  t = {};
  if(Object.keys(t).length == 0){
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="apply的使用">.apply（）的使用</h1>
<h2 id="1找出数组最大元素">（1）找出数组最大元素</h2>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>
<pre><code class="language-js">var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
</code></pre>
<h2 id="2将数组的空元素变为undefined">（2）将数组的空元素变为undefined</h2>
<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>
<pre><code class="language-js">Array.apply(null, ['a', ,'b'])
// [ 'a', undefined, 'b' ]
</code></pre>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。<br>
因此，遍历内部元素的时候，会得到不同的结果。</p>
<pre><code class="language-js">var a = ['a', , 'b'];

function print(i) {
console.log(i);
}

a.forEach(print)
// a
// b

Array.apply(null, a).forEach(print)
// a
// undefined
// b
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[slot插槽]]></title>
        <id>https://cutezhangq.github.io/post/slot-cha-cao/</id>
        <link href="https://cutezhangq.github.io/post/slot-cha-cao/">
        </link>
        <updated>2020-08-07T03:04:18.000Z</updated>
        <summary type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
<!-- more -->
<p>由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>两大类。<br>
非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；<br>
插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p>
<h1 id="单个插槽-默认插槽-匿名插槽">单个插槽 | 默认插槽 | 匿名插槽</h1>
<p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。<br>
单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。<br>
下面通过一个例子来展示。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;h3&gt;这里是父组件&lt;/h3&gt;
        &lt;child&gt;
            &lt;div class=&quot;tmpl&quot;&gt;
              &lt;span&gt;菜单1&lt;/span&gt;
              &lt;span&gt;菜单2&lt;/span&gt;
              &lt;span&gt;菜单3&lt;/span&gt;
              &lt;span&gt;菜单4&lt;/span&gt;
              &lt;span&gt;菜单5&lt;/span&gt;
              &lt;span&gt;菜单6&lt;/span&gt;
            &lt;/div&gt;
        &lt;/child&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;child&quot;&gt;
        &lt;h3&gt;这里是子组件&lt;/h3&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p>
<pre><code class="language-html">&lt;div class=&quot;tmpl&quot;&gt;
  &lt;span&gt;菜单1&lt;/span&gt;
  &lt;span&gt;菜单2&lt;/span&gt;
  &lt;span&gt;菜单3&lt;/span&gt;
  &lt;span&gt;菜单4&lt;/span&gt;
  &lt;span&gt;菜单5&lt;/span&gt;
  &lt;span&gt;菜单6&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>最终的渲染结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892088251.png" alt="" loading="lazy"></p>
<h1 id="具名插槽">具名插槽</h1>
<p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个<strong>具名插槽</strong>和<strong>单个插槽</strong>的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;child&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt;
        &lt;span&gt;菜单1&lt;/span&gt;
        &lt;span&gt;菜单2&lt;/span&gt;
        &lt;span&gt;菜单3&lt;/span&gt;
        &lt;span&gt;菜单4&lt;/span&gt;
        &lt;span&gt;菜单5&lt;/span&gt;
        &lt;span&gt;菜单6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt;
        &lt;span&gt;菜单-1&lt;/span&gt;
        &lt;span&gt;菜单-2&lt;/span&gt;
        &lt;span&gt;菜单-3&lt;/span&gt;
        &lt;span&gt;菜单-4&lt;/span&gt;
        &lt;span&gt;菜单-5&lt;/span&gt;
        &lt;span&gt;菜单-6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot;&gt;
        &lt;span&gt;菜单-&gt;1&lt;/span&gt;
        &lt;span&gt;菜单-&gt;2&lt;/span&gt;
        &lt;span&gt;菜单-&gt;3&lt;/span&gt;
        &lt;span&gt;菜单-&gt;4&lt;/span&gt;
        &lt;span&gt;菜单-&gt;5&lt;/span&gt;
        &lt;span&gt;菜单-&gt;6&lt;/span&gt;
      &lt;/div&gt;
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
    // 具名插槽
    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 具名插槽
    &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt;
    // 匿名插槽
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596892200490.png" alt="" loading="lazy"><br>
可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。</p>
<h1 id="作用域插槽-带数据的插槽">作用域插槽 | 带数据的插槽</h1>
<p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p>
<pre><code class="language-cmd">匿名插槽
&lt;slot&gt;&lt;/slot&gt;
具名插槽
&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
</code></pre>
<p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p>
<pre><code class="language-html">&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;
 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    },
}
</code></pre>
<p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p>
<pre><code class="language-cmd">&lt;child&gt;
   html模板
&lt;/child&gt;
</code></pre>
<p>可以说是子组件暴露的一个让父组件传入自定义内容的接口。<br>
写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。<br>
OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？<br>
<code>正因为作用域插槽绑定了一套数据，父组件可以拿来用。</code>于是，情况就变成了这样：<code>样式父组件说了算，但内容可以显示子组件插槽绑定的。</code><br>
我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。<br>
下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;!--第一次使用：用flex展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;div class=&quot;tmpl&quot;&gt;
          &lt;span v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第二次使用：用列表展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第三次使用：直接显示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;              &lt;!--通过slot-scope获取子组件的信息--&gt;
       {{user.data}}
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;
    &lt;child&gt;
      我就是模板
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;

</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;

    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 作用域插槽
    &lt;slot  :data=&quot;data&quot;&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    }
}
</code></pre>
<p>结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892616696.png" alt="" loading="lazy"></p>
<h1 id="slot-scope">slot-scope</h1>
<p><strong>父组件中在使用时：</strong></p>
<ul>
<li>默认插槽的话直接在子组件的标签内写入内容即可</li>
<li>具名插槽是在默认插槽的基础上加上slot属性，值为子组件插槽name属性值</li>
<li>作用域插槽则是通过<code>slot-scope获取子组件的信息</code>，在内容中使用。这里可以用解构语法去直接获取想要的属性</li>
</ul>
<h1 id="v-slot">v-slot</h1>
<pre><code class="language-cmd">在vue2.6中，上述的API被软废弃（3.0正式废弃），取而代之的是内置指令v-slot，可以缩写为【#】
</code></pre>
<p>**子组件用法保持不变，**父组件中</p>
<ul>
<li>slot属性弃用，具名插槽通过指令参数<code>v-slot:插槽名</code>的形式传入，可以简化为 <code>#插槽名。</code></li>
<li><code>slot-scope</code>属性弃用，作用域插槽通过<code>v-slot:xxx=&quot;slotProps&quot;</code>的slotProps来获取子组件传出的属性</li>
<li>v-slot属性只能在 <code>&lt;template&gt;</code>上使用，但在**【只有默认插槽时】**可以在组件标签上使用</li>
</ul>
<pre><code class="language-html">//Parent
&lt;template&gt;
  &lt;child&gt;
   &lt;!--默认插槽--&gt;
   &lt;template v-slot&gt;
     &lt;div&gt;默认插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--具名插槽--&gt;
   &lt;template #header&gt;
     &lt;div&gt;具名插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--作用域插槽--&gt;
   &lt;template #footer=&quot;slotProps&quot;&gt;
     &lt;div&gt;
      {{slotProps.testProps}}
     &lt;/div&gt;
   &lt;/template&gt;
  &lt;child&gt;
&lt;/template&gt;
</code></pre>
<h1 id="拓展用法">拓展用法：</h1>
<ol>
<li>同样可以通过解构获取v-slot={user},<br>
还可以重命名v-slot=&quot;{user: newName}&quot;和定义默认值v-slot=&quot;{user = '默认值'}&quot;</li>
<li>插槽名可以是动态变化的 v-slot:[slotName]</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>默认插槽名为<code>default</code>，可以省略default直接写<code>v-slot</code>，<br>
缩写为#时不能不写参数，写成<code>#default</code>（这点所有指令都一样，v-bind、v-on）</li>
<li>多个插槽混用时，v-slot不能省略default</li>
</ol>
<h1 id="作用域插槽的原理">作用域插槽的原理</h1>
<p>slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过<br>
<code>template &gt;&gt; render function &gt;&gt; VNode &gt;&gt; DOM</code>过程。 组件挂载的本质就是执行渲染函数得到VNode，至于data/props/computed这些属性都是给VNode提供数据来源。<br>
在2.5之前，如果是普通插槽就<strong>直接是VNode</strong>的形式了，而如果是作用域插槽，由于子组件需要在父组件访问子组件的数据，所以父组件下是一个<strong>未执行的函数</strong><code>(slotScope) =&gt; return h('div', slotScope.msg)</code>，接受子组件的slotProps参数，在子组件渲染实例时会调用该函数传入数据。<br>
在2.6之后，两者合并，普通插槽也变成一个函数，只是不接受参数了。</p>
<h1 id="总结">总结</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596938553804.png" alt="" loading="lazy"></figure>
<h1 id="slot的使用场景">slot的使用场景</h1>
<ul>
<li>布局组件、</li>
<li>表格列、</li>
<li>下拉选项</li>
</ul>
<h1 id="slot-scope的使用场景">slot-scope的使用场景</h1>
<p>想象一个场景：<br>
<strong>当你要给同事封装一个列表组件，你就需要使用作用域插槽（注意是列表或者类似列表的组件）</strong><br>
你开发的这个列表组件要如何使用呢？<br>
一般来说作为列表组件的调用者，你的同事先做ajax请求，拿到一个这样的数组</p>
<pre><code class="language-json">   todos: [
        {
          id: 0,
          text: 'ziwei0',
          isComplete: false
        },
        {
          text: 'ziwei1',
          id: 1,
          isComplete: true
        },
        {
          text: 'ziwei2',
          id: 2,
          isComplete: false
        },
        {
          text: 'ziwei3',
          id: 3,
          isComplete: false
        }
      ]
</code></pre>
<p>之后会把todso传递给列表组件吧，那么列表组件内部做什么事情呢？<br>
列表内部肯定会v-for去帮你的同事渲染这个数组嘛。 就类似element-ui里的table组件一样<br>
问题的关键就在这里<br>
<strong>列表组件的循环，是发生在组件内部的，所以通过 v-for=&quot;todo in todos&quot; ,列表组件很容易拿到一项todo，但列表拿到数据没用呀，列表只是一个瓜皮，它又不懂业务逻辑这个数据是你同事的业务数据，</strong><br>
<strong>所以这个数据必须得交给组件的调用者，也就是把数据交给你的同事才对。</strong></p>
<p>那么你怎样才能把每一项的todo数据给传递出去呢？<br>
你会发现没有办法！</p>
<p>无论是用$emit、vuex还是localStorage，可以考虑一下，会发现没有合适的时机，能让你把todo传递出去</p>
<p>所以为了应对这个场景下，发明了<code>作用域插槽</code>，列表组件可以通过<code>&lt;slot :todo=&quot;todo&quot;&gt;&lt;/slot&gt;</code>传递todo出去<br>
你的同事可以通过 slot-scope=&quot;slotsProps&quot;<code>拿到todo</code>。<br>
回答几个疑问，其实如果你看懂上面的问题，应该可以回答下面的问题。这也是我曾经的疑问</p>
<ul>
<li>疑问1：一般不是我们传参数来调用组件吗？为什么组件还把数据传递回来？</li>
</ul>
<pre><code class="language-cmd">的确，调用ui组件时一般是我们传递配置参数给他们。

但是就像elemnt-ui的table组件，你把数组传递给table后，是不是有时候需要拿到某一行的row对象

并根据row对象里的字段，来判断一些内容的显示隐藏？

因为循环的过程发生在table组件内部，所以table组件可以方便的获取到每一项数据，但是这些数据最终不是给组件的，而是我们自己要用的业务数据。所以也需要一个方式，让调用者能拿到自己想要的数据
</code></pre>
<ul>
<li>疑问2： 既然子组件最终还要把我给他的数据，再返还给我，那我当初还干嘛给它，能不能就自己在父组件里玩？</li>
</ul>
<pre><code class="language-cmd">如果你不把数据给子组件当然可以。但是就等于抛弃掉了子组件的封装，只能你直接在父组件自己写一个列表

毕竟你不把数据给子组件，子组件还渲染个锤子？没有父子关系的话，也就不用什么插槽了。

但是咱不是为了封装后，可以复用嘛，总不能永远不用组件嘛
</code></pre>
<ul>
<li>疑问3： 父组件需要子组件的数据？那不会有$emit和vuex嘛，为什么要有slot-scope？</li>
</ul>
<pre><code class="language-cmd">$emit和vuex是数据传递的一种方法，但是你可以尝试用$emit和vuex把todo传递给父组件。

你会发现的确没有合适的钩子、时机来$emit数据
</code></pre>
<h1 id="26新增用法">2.6新增用法</h1>
<h2 id="动态插槽名260新增">动态插槽名(2.6.0新增)</h2>
<p>动态指令参数(需要自己了解)也可以用在v-slot上，来定义动态的插槽名：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<h2 id="具名插槽的缩写260新增">具名插槽的缩写(2.6.0新增)</h2>
<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：<br>
原来是这样写的：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;  
</code></pre>
<p>现在可以这样写：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;
</code></pre>
<p>如果希望使用缩写的话，必须始终以明确插槽名取而代之：</p>
<pre><code class="language-html">&lt;test #default=&quot;{ usertext }&quot;&gt;
  {{ usertext.firstName }}
&lt;/test&gt;
</code></pre>
<h1 id="其他示例">其他示例</h1>
<p>插槽 prop 允许我们将插槽转换为<code>可复用</code>的模板，这些模板可以基于输入的 <code>prop</code>渲染出不同的内容。 这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。<br>
例如，我们要实现一个 <code>&lt;todo-list&gt;</code>组件，它是一个列表且包含布局和过滤逻辑：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>我们可以将每个<code>todo</code>作为父级组件的插槽，以此通过父级组件对其进行控制，然后将<code>todo</code> 作为一个插槽<code>prop</code>进行绑定：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    &lt;!--
    我们为每个 todo 准备了一个插槽，
    将 `todo` 对象作为一个插槽的 prop 传入。
    --&gt;
    &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code>组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code>作为替代方案，并且可以从子组件获取数据：</p>
<pre><code class="language-html">&lt;todo-list v-bind:todos=&quot;todos&quot;&gt;
  &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
&lt;/todo-list&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[computed，watch，method执行的先后顺序]]></title>
        <id>https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/</id>
        <link href="https://cutezhangq.github.io/post/computedwatchmethod-zhi-xing-de-xian-hou-shun-xu/">
        </link>
        <updated>2020-08-06T13:57:16.000Z</updated>
        <summary type="html"><![CDATA[<p>👉他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>👉他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
<!-- more -->
<h1 id="computed">computed：</h1>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<h1 id="methods">methods：</h1>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。</p>
<h1 id="watch">watch：</h1>
<p>是一种更通用的方式来观察和响应 Vue 实例上的数据变动。一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。</p>
<p>通俗来讲，</p>
<p>computed是在HTML DOM加载后马上执行的，如赋值；</p>
<p>而methods则必须要有一定的触发条件才能执行，如点击事件；</p>
<p>watch呢？它用于观察Vue实例上的数据变动。对应一个对象，键是观察表达式，值是对应回调。值也可以是方法名，或者是对象，包含选项。</p>
<p>所以他们的执行顺序为：<code>默认加载的时候先computed再watch，不执行methods；等触发某一事件后，则是：先methods再watch。</code></p>
<p>下面的例子可以做为说明。</p>
<p>computed 属性 vs watched 属性：Vue 确实提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：watch 属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的想法是使用 computed 属性而不是命令式的 watch 回调。</p>
<h1 id="computed与watch的区别">computed与watch的区别</h1>
<p>在很多情况下, computed会比watch使用起来更加方便,但是当需要在数据变化时执行异步或者开销比较大的情况下,用watch会更加合适。<br>
例如官网提供的例子(问与答。watch观察question的值,若值有改变会执行方法getAnswer,并且根据question不同的值, answer会给出不同的回答,并且会异步调用API返回相应的值,这些都是计算属性做不到的。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>目的</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>computed</td>
<td>依赖变动实时更新数据</td>
<td>更新数据</td>
</tr>
<tr>
<td>watch</td>
<td>观察某一特定的值，执行特定的函数</td>
<td>观察数据</td>
</tr>
</tbody>
</table>
<pre><code class="language-js">&lt;divid=&quot;demo&quot;&gt;{{ fullName }}&lt;/div&gt;

使用watch方法观察数据（单个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar',
fullName: 'Foo Bar'
},
watch: {
firstName: function (val) {
this.fullName = val + ' ' + this.lastName
},
lastName: function (val) {
this.fullName = this.firstName + ' ' + val
}
}
})

使用computed方法计算数据（多个数据）
var vm = new Vue({
el: '#demo',
data: {
firstName: 'Foo',
lastName: 'Bar'
},
computed: {
fullName: function () {
return this.firstName + ' ' + this.lastName
}
}
})
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JSON.stringify与"环"问题]]></title>
        <id>https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/</id>
        <link href="https://cutezhangq.github.io/post/jsonstringify-yu-huan-wen-ti/">
        </link>
        <updated>2020-08-06T10:50:32.000Z</updated>
        <summary type="html"><![CDATA[<p>JSON.stringify在解析接口数据时，我们经常使用到，那么它为什么会产生“环“呢，啥是”环“和？😨<br>
🙄博主酱的脑海中一堆问号，赶快来了解下了！</p>
]]></summary>
        <content type="html"><![CDATA[<p>JSON.stringify在解析接口数据时，我们经常使用到，那么它为什么会产生“环“呢，啥是”环“和？😨<br>
🙄博主酱的脑海中一堆问号，赶快来了解下了！</p>
<!-- more -->
<p>JSON.stringify的功能是，将一个js字面量对象转化为一个JSON格式的字符串，例如：</p>
<pre><code class="language-js">const obj = {a:1,b:2}
JSON.stringify(obj)     //  ‘ {“a”:1,“b”:2}’
</code></pre>
<!-- more -->
<p>当要转化的对象有**“环”**存在时（<strong>子节点属性赋值了父节点的引用</strong>），为了避免死循环，JSON.stringify 会抛出异常，例如：</p>
<pre><code class="language-js">const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
JSON.stringify(obj) // =&gt; TypeError: Converting circular structure to JSON 类型错误:将循环结构转换为JSON
</code></pre>
<p>请完善以下“环”检查器函数 cycleDetector，当入参对象中有环时返回 true，否则返回 false。</p>
<pre><code class="language-js">function cycleDetector(obj) {   
  // 请添加代码
}
</code></pre>
<p>“环”的形成是因为对象的子节点属性赋值了父节点的引用，所以我们需要记录下父节点的地址，然后再拿其子节点的属性与之前记录下的父节点地址做一个比较，当结果一致时，就形成了“环”。</p>
<p>那么，在“环”检测器函数中，我们首先需要遍历这个对象的属性，前面提到了引用，那么我们只需对Object类型的属性进行处理即可（简单数据类型不存在引用关系）。对于Objcet类型的属性，我们先与记录下来的父节点地址做一个对比，如无匹配项，将当前属性地址记录下来，然后遍历其子节点属性，一层一层找下去。下面开始上代码：</p>
<pre><code class="language-js">function cycleDetector(obj){
    var hasCircle = false,  //  定义一个变量，标志是否有环
    cache = [];          //  定义一个数组，来保存对象类型的属性值
    (function(obj){
        var keys = Object.keys(obj);    //获取当前对象的属性数组——key是获取属性
             for (var i = 0; i &lt; keys.length; i++) {
            var key = keys[i];
            var value = obj[key];
            if (typeof value == 'object' &amp;&amp; value !== null) {
                var index = cache.indexOf(value)
                if (index !== -1) {
                    hasCircle = true
                    break
                } else {
                    cache.push(value)
                    arguments.callee(value)
                    cache.pop()      //  注意：这里要推出数据，因为递归返回，后面遍历的属性不是这个数据的子属性
                }
            }
        }
    })(obj)
}

</code></pre>
<p>补充：<br>
<strong>Object.keys</strong> 返回一个所有元素为字符串的数组，其元素来自于从给定的object上面可直接枚举的属性。这些属性的顺序与手动遍历该对象属性时的一致。<br>
<strong>测试用例</strong></p>
<pre><code class="language-js">/* 测试一 */

const obj = {
  foo: {
    name: 'foo',
    bar: {
      name: 'bar'
      baz: {
        name: 'baz',
        aChild: null  //待会让它指向obj.foo
      }
    }
  }
}
obj.foo.bar.baz.aChild = obj.foo // foo-&gt;bar-&gt;baz-&gt;aChild-&gt;foo 形成环
</code></pre>
<pre><code class="language-js">/* 测试二 */

var obj = {
    foo: {
        name: 'foo',
        bar: {
            name: 'bar',
            baz: {
                name: 'baz',
                aChild: null
            }
        }
    },
    aaa: {
        name: &quot;test&quot;,
        bbb: null
    }
}
obj.aaa.bbb = obj.foo;   //  aaa-&gt;bbb-&gt;bar-&gt;baz-&gt;aChild-&gt;null 不形成环
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JWT认证原理（JSON Web Token）、SSO单点登录]]></title>
        <id>https://cutezhangq.github.io/post/jwt-ren-zheng-yuan-li/</id>
        <link href="https://cutezhangq.github.io/post/jwt-ren-zheng-yuan-li/">
        </link>
        <updated>2020-07-31T06:27:29.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于👉分布式站点的<code>单点登录（SSO）</code>场景👈。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。👀</p>
<p>JWT认证原理（JSON Web Token）</p>
<p>互联网服务离不开用户认证。一般流程是下面这样。🙌</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于👉分布式站点的<code>单点登录（SSO）</code>场景👈。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。👀</p>
<p>JWT认证原理（JSON Web Token）</p>
<p>互联网服务离不开用户认证。一般流程是下面这样。🙌</p>
<!-- more -->
<h1 id="一-传统的session认证">一、传统的Session认证</h1>
<h2 id="流程session">流程session</h2>
<p>认证的流程一般如下：</p>
<ul>
<li>1.用户向服务器发送用户名和密码。</li>
<li>2.服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>3.服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>4.用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>5.服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>session保存在服务器，当注册用户很多，会增加服务器的开销。</li>
<li>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡的能力。这也意味着限制了应用的扩展能力。</li>
<li>session是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到<code>跨站请求伪造（CSRF）</code>的攻击。</li>
</ul>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 <code>session 数据持久化</code>，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都<code>保存在客户端</code>，每次请求都发回服务器。<code>JWT</code>就是这种方案的一个代表。</p>
<h1 id="二-jwt-认证">二、JWT 认证</h1>
<h2 id="token">token</h2>
<p><code>JWT</code>是基于<code>token</code>的鉴权机制类似于<code>http协议</code>也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。<br>
这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<h2 id="流程">流程</h2>
<ul>
<li>1.用户使用用户名密码来请求服务器。</li>
<li>2.服务器进行验证用户的信息</li>
<li>3.服务器通过验证发送给用户一个token</li>
<li>4.客户端存储token，并在每次请求时附送上这个token值</li>
<li>5.服务端验证token值，并返回数据</li>
</ul>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)策略</code>，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p>
<h2 id="jwt-的原理">JWT 的原理</h2>
<p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<pre><code class="language-json">{
  &quot;姓名&quot;: &quot;张三&quot;,
  &quot;角色&quot;: &quot;管理员&quot;,
  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;
}
</code></pre>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>
服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h1 id="三-jwt-的数据结构">三、JWT 的数据结构</h1>
<pre><code class="language-js">    const accessToken =    &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1597647417511.png" alt="" loading="lazy"></figure>
<p>JWT 的三个部分依次如下:</p>
<pre><code class="language-cmd">Header（头部）
Payload（负载）
Signature（签名）
</code></pre>
<p>写成一行，就是下面的样子。<br>
Header.Payload.Signature<br>
下面依次介绍这三个部分。</p>
<h2 id="header">Header</h2>
<p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<pre><code class="language-json">{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>
最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h2 id="payload">Payload</h2>
<p>载荷就是存放有效信息的地方。这些有效信息包含三个部分:<br>
标准中注册的声明<br>
公共的声明<br>
私有的声明<br>
Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<pre><code class="language-cmd">iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
</code></pre>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<pre><code class="language-json">{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}
</code></pre>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>
这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h2 id="signature">Signature</h2>
<p>JWT的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64加密)</li>
<li>payload (base64加密)</li>
<li>secret 密钥<br>
Signature 部分是对前两部分的签名，防止数据篡改。<br>
首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</li>
</ul>
<pre><code class="language-cmd">HMACSHA256(
  base64UrlEncode(header) + &quot;.&quot; +
  base64UrlEncode(payload),
  secret)
</code></pre>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（.）分隔，就可以返回给用户。</p>
<p><strong>注意</strong>：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的<code>私钥</code>，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以<code>自我签发jwt</code>了。如果觉得密钥泄露了，请及时修改。</p>
<h2 id="base64url">Base64URL</h2>
<p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>
JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+、/和=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h1 id="五-jwt-的几个特点">五、JWT 的几个特点</h1>
<p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>
（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>
（3）JWT 不仅可以<code>用于认证</code>，也可以用于<code>交换信息</code>。有效使用 JWT，可以<code>降低服务器查询数据库的次数</code>。<br>
（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>
（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>
（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<p>案例：request.js</p>
<pre><code class="language-js">import axios from 'axios'
import global from '../../api/global'
import router from '../../router/router'
// 拿到token
function getAccessToken() {
    // 从localStorage中获取token
    //let accessToken = localStorage.getItem('accessToken')
    const accessToken = &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
    if (accessToken != null&amp;&amp; refreshToken !== undefined) {
        return &quot;Bearer &quot; + accessToken
    }
}

// 创建一个axios实例
const axiosJWT = axios.create({
    baseURL: global.API,
    timeout: 300000,
    headers: {
        'Authorization': getAccessToken(),
        &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
    }
})

async function refreshToken() {    //之前的逻辑是去发送请求拿到刷新的token(refreshToken)
    // instance是当前request.js中已创建的axios实例
    // return await axiosBASIC.get('/auth/reissueToken', {
    //   params: {
    //     refreshToken: getRefreshToken()
    //   }
    // })
    return await axiosBASIC.get('/auth/issueToken', {
    params: {
      openId: &quot;oV76BwiaUXpg1aJ6KTCoxPmjiDx4&quot;
    }
  })
}


// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中
axiosJWT.setToken = (accessToken) =&gt; {
    localStorage.setItem('accessToken', accessToken)
    axiosJWT.defaults.headers['Authorization'] = &quot;Bearer &quot;+accessToken
}

// 是否正在刷新的标记
let isRefreshing = false
// 重试队列，每一项将是一个待执行的函数形式
let requests = []


// 响应拦截
axiosJWT.interceptors.response.use(response =&gt; {
        const {code} = response.data
        // 接下来会在这里进行token过期重发逻辑处理
        switch(code){
            case 604:
                //非法token！
                break
            case 603:
                //缺少token！
            case 605:
                //accessToken已过期！
                //获取当前失败的请求
                const config = response.config
                if (!isRefreshing) {
                    isRefreshing = true
                   return refreshToken()
                        .then(res =&gt; {
                            const {code} = res.data
                            switch(code){
                                case 200:
                                    //refreshToken有效，刷新Token成功
                                    //将最新的token更新到header中，同时保存在localStorage中
                                    const {accessToken} = res.data.data
                                    console.log('access_token====='+accessToken)
                                    axiosJWT.setToken(accessToken)
                                    // 刷新下之前的请求配置
                                    config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
                                    config.baseURL = ''
                                    //已经刷新了token，将所有队列中的请求进行重试
                                    requests.forEach(cb =&gt; cb(accessToken))
                                    //清空队列
                                    requests = []
                                    // 重试之前的请求并返回promise
                                    return axiosJWT(config)
                                case 500:
                                case 606:
                                    //refreshToken过期
                                   router.push(&quot;/auth&quot;)
                            }
                        })
                        .finally(() =&gt; {
                            //刷新成功，恢复标志位
                            isRefreshing = false
                        })
                } else {
                    // 正在刷新token，返回一个未执行resolve的promise
                    return new Promise((resolve) =&gt; {
                        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行
                        requests.push((accessToken) =&gt; {
                            config.baseURL = ''
                            config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
                            resolve(axiosJWT(config))
                        })
                    })
                }
            case 701:
                //JWT认证失败!
                break
            default: 
            return response.data
        }
    },error =&gt; {
        return Promise.reject(error)
    })

export  {
    axiosJWT,
    axiosBASIC
}
</code></pre>
<h1 id="六-什么是单点登录">六、什么是单点登录</h1>
<p><img src="https://cutezhangq.github.io/post-images/1598427024701.jpg" alt="" loading="lazy"><br>
单点登录的英文名叫做：Single Sign On（简称SSO）。<br>
在初学/以前的时候，一般我们就单系统，所有的功能都在同一个系统上。<br>
<img src="https://cutezhangq.github.io/post-images/1598356039400.png" alt="" loading="lazy"></p>
<p>后来，我们为了合理利用资源和降低耦合性，于是把单系统拆分成多个子系统。<br>
回顾：分布式基础知识</p>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1598356074130.png" alt="" loading="lazy"></figure>
<p>比如阿里系的淘宝和天猫，很明显地我们可以知道这是两个系统，但是你在使用的时候，登录了天猫，淘宝也会自动登录。<code>不需要用户重复登录</code><br>
简单来说，<strong>单点登录就是在多个系统中，用户只需一次登录，各个系统即可感知该用户已经登录</strong>。<br>
众所周知，HTTP是无状态的协议，这意味着服务器无法确认用户的信息。于是乎，W3C就提出了：给每一个用户都发一个通行证，无论谁访问的时候都需要携带通行证，这样服务器就可以从通行证上确认用户的信息。通行证就是<strong>Cookie</strong>。<br>
如果说<strong>Cookie</strong>是检查用户身上的”通行证“来确认用户的身份，那么Session就是通过检查服务器上的”客户明细表“来确认用户的身份的。<strong>Session</strong>相当于在服务器中建立了一份“客户明细表”。<br>
<code>Cookie：令牌（识别身份）</code><br>
<code>Session：花名册（核对身份）</code><br>
所以，一般我们单系统实现登录会这样做：</p>
<ul>
<li><strong>登录</strong>：将用户信息保存在Session对象中
<ul>
<li>如果在Session对象中能查到，说明已经登录</li>
<li>如果在Session对象中查不到，说明没登录（或者已经退出了登录）</li>
</ul>
</li>
<li><strong>注销（退出登录）</strong>：从Session中删除用户的信息</li>
<li><strong>记住我（关闭掉浏览器后，重新打开浏览器还能保持登录状态）</strong>：配合Cookie来用</li>
</ul>
<h1 id="实战基于云平台的儿童英语听说交互系统">实战（基于云平台的儿童英语听说交互系统）</h1>
<p>1、代码进入main.js页面，通过路由拦截</p>
<ul>
<li>当已经登录（sessionStorage 中存了状态isLogin），则跳转要前往的页面；</li>
<li>当没有存储isLogin或进入设置设备页，则进入login.vue页面
<ul>
<li>注：使用sessionStorage 是为了即时更新登录态（浏览器未关闭，第一次获取完isLogin，后面的请求就都授权了，但是当浏览器关闭了，就要重新授权）</li>
</ul>
</li>
</ul>
<p>2、当“没有授权或需要操作设备时” 进入login.vue页面，通过路由拦截（路由守卫）</p>
<ul>
<li>2.1、不是从auth授权页跳转过来的，就存储来的路径（存在sessionStorage中）</li>
<li>2.2、获取存储的需要跳转的路径</li>
<li>2.3、请求login接口（JWT请求）将登陆时间存储到isLogin中</li>
<li>2.4、跳转之前存储的进入页面
<ul>
<li>注：login.vue是用来登陆授权的（在未授权前登陆）</li>
</ul>
</li>
</ul>
<p>3、requset.js（封装JWT的）</p>
<ul>
<li>
<p>axiosJWT 携带请求头（发送Token给后台）</p>
<ul>
<li>Token从localStorage 中获取，能拿到则将token放在请求头中发送过去</li>
<li>后台设置不过期的token，前端将这个token携带在请求头中发过去</li>
</ul>
<pre><code class="language-js">如：const accessToken =       &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
</code></pre>
</li>
<li>
<p>更新Token: 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中</p>
<pre><code class="language-js"> axiosJWT.setToken = (accessToken) =&gt; {
        localStorage.setItem('accessToken', accessToken)
        axiosJWT.defaults.headers['Authorization'] = &quot;Bearer &quot;+accessToken
    }
</code></pre>
</li>
<li>
<p>响应拦截 :<code>axiosJWT.interceptors.response.use(response =&gt; { })</code></p>
<ul>
<li>在这里进行token过期重发逻辑处理 :
<ul>
<li>判断code：<code>（604非法token、603缺少token、605token过期、701JWT认证失败、默认： return response.data ）</code></li>
<li>token过期：
<ul>
<li>
<p>1、获取当前失败的请求：const config = response.config</p>
</li>
<li>
<p>2、判断是否进入刷新状态</p>
<ul>
<li>刷新中：</li>
</ul>
<pre><code class="language-js">      // 正在刷新token，返回一个未执行resolve的promise
        return new Promise((resolve) =&gt; {
          // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行
          requests.push((accessToken) =&gt; {
            config.baseURL = ''
            config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
             resolve(axiosJWT(config))
          })
      })
</code></pre>
<ul>
<li>未刷新：<br>
更新刷新状态为：刷新中，返回 refreshToken：(携带固定 openId 请求 /auth/issueToken)</li>
</ul>
<pre><code class="language-js">    async function refreshToken() {
        // instance是当前request.js中已创建的axios实例
        // return await axiosBASIC.get('/auth/reissueToken', {
        //   params: {
        //     refreshToken: getRefreshToken()
        //   }
        // })
        return await axiosBASIC.get('/auth/issueToken', {
        params: {
          openId: &quot;oV76BwiaUXpg1aJ6KTCoxPmjiDx4&quot;
        }
      })
</code></pre>
<p>通过请求后台接口，拿到返回值，响应状态码（200刷新token成功、500后台错误、606 refreshToken过期，跳转auth页面）</p>
<ul>
<li>200 刷新token成功（refreshToken有效）<pre><code class="language-js">//refreshToken有效，刷新Token成功
//将最新的token更新到header中，同时保存在localStorage中
const {accessToken} = res.data.data
axiosJWT.setToken(accessToken)
// 刷新下之前的请求配置
config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
config.baseURL = ''
//已经刷新了token，将所有队列中的请求进行重试
requests.forEach(cb =&gt; cb(accessToken))
requests = []	//清空队列
return axiosJWT(config)	// 重试之前的请求并返回promise
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>error ：<code>返回失败信息 return Promise.reject(error)</code></li>
</ul>
</li>
<li>
<p>axiosBASIC （auth页使用）</p>
<ul>
<li>
<pre><code>const BASIC_TOKEN = &quot;b3JhbmdlMjpvcmFuZ2UyLXNlY3JldA==&quot; 
</code></pre>
</li>
</ul>
</li>
</ul>
<p>4、auth页（ 进行路由拦截 ）</p>
<ul>
<li>4.1、需要跳转的不是auth页时：
<ul>
<li>
<pre><code>`sessionStorage.setItem(&quot;authBackUrl&quot;, from.path)`
</code></pre>
</li>
</ul>
</li>
<li>4.2、获取url中的code<code>let code = myUtils.getUrlArg(&quot;code&quot;);</code></li>
<li>4.3、url中是否携带code：
<ul>
<li>code不为null（url中携带了code）
<ul>
<li>取出之前需要跳转的地址 authBackUrl</li>
</ul>
</li>
</ul>
<pre><code class="language-js">    //携带code请求后台签发token+openid
         axiosBASIC({
            url: &quot;/auth/issueToken&quot;,
            method: &quot;get&quot;,
            params: {
              code: code
            }
        })
</code></pre>
<ul>
<li>请求响应成功200，重新设置<code>accessToken</code>和<code>reflashToken</code></li>
</ul>
<pre><code class="language-js">      let WxUser = res.data
      axiosJWT.setToken(WxUser.accessToken)
      localStorage.setItem(&quot;refreshToken&quot;, WxUser.refreshToken)
</code></pre>
<ul>
<li>路由跳转要去的页面</li>
<li>请求响应701：打印错误</li>
<li>请求响应805：表示未绑定设备，前往Open 页绑定设备</li>
<li>code = null：<code>window.location.href = sysConst.OAUTH2 //请求腾讯OAuth服务器</code></li>
</ul>
</li>
</ul>
<p>通过code拿到open_id，进而拿到Token(由open_id构成)——&gt;open_id不过期，code与Token均会过期</p>
<ul>
<li><code>code</code>：授权码，由微信授权生成（有时间限制，并且只能使用一次）</li>
<li><code>open_id</code>：通过这个授权码code获取该用户的openid（将这个授权码code发送给后台以后，后台用code去请求openid，openid是唯一的，可以通过这个openid在数据库中绑定用户）</li>
<li><code>taken</code>:（后台生成，有时间限制，由open_id组成）</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router中传参的方式都有哪些]]></title>
        <id>https://cutezhangq.github.io/post/vue-router-zhong-chuan-can-de-fang-shi-du-you-na-xie/</id>
        <link href="https://cutezhangq.github.io/post/vue-router-zhong-chuan-can-de-fang-shi-du-you-na-xie/">
        </link>
        <updated>2020-07-11T13:11:46.000Z</updated>
        <summary type="html"><![CDATA[<p>没事就需要翻翻vue官网，好长时间不看了。<a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">Vue路由组件传参</a>🏃‍♀🏃<br>
主要从this.$router.push的name和params、path和qurey；router-link :to传参来回答</p>
]]></summary>
        <content type="html"><![CDATA[<p>没事就需要翻翻vue官网，好长时间不看了。<a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">Vue路由组件传参</a>🏃‍♀🏃<br>
主要从this.$router.push的name和params、path和qurey；router-link :to传参来回答</p>
<!-- more -->
<h1 id="常用的传递方式">常用的传递方式</h1>
<h1 id="一-编程式的导航-routerpush">一、编程式的导航 router.push</h1>
<h2 id="直接传拼接">直接传（拼接）</h2>
<pre><code class="language-js">//组件调用
this.$router.push({path: `/describe/${id}`})
//路由配置
{
    path: '/describe/:id',
    name: 'Describe',
    component: Describe
}
//Describe组件获取
this.$route.query.id
</code></pre>
<h2 id="query传参get请求">query传参——get请求</h2>
<p>传递的参数会拼接在url上</p>
<pre><code class="language-js"> //组件调用
this.$router.push({
 path: '/describe',
 query: {
            id: id
        }
})
//路由配置
{
    path: '/describe',
    name: 'Describe',
    component: Describe
}
//Describe组件获取
this.$route.query.id
</code></pre>
<p>（注：以上两种方式都会把参数放置在 this.$route.query 中）</p>
<h2 id="params传参post请求">params传参——post请求</h2>
<p>params传参<br>
（注：这里的路由匹配方式：通过路由属性中的name来确定匹配的路由。如果提供了 path，params 会被忽略）</p>
<p>params传参不会拼接在url上，但存在一个问题-------如果强制刷新页面会丢失参数</p>
<pre><code class="language-js">//组件调用
this.$router.push({
    name: 'Describe',
    params: {
                id: id
            }
})
//路由配置
{
     path: '/describe',
     name: 'Describe',
     component: Describe
}
//Describe组件获用
this.$route.params.id
</code></pre>
<h1 id="新发现">新发现</h1>
<p>现在的路由传参的方式没有改变，上述内容依然有效。组件内获取的方式增加了props方式接收，可以把参数传到props里了，功能更强大了。</p>
<p>如果在组件内要用props接收路由上的参数可以分为三种方式</p>
<h2 id="布尔模式">布尔模式</h2>
<p>如果<code>props</code> 被设置为<code>true</code>，<code>route.params</code>将会被设置为组件属性。</p>
<pre><code class="language-js">//组件调用
//路由传递方式只能使用params传递参数
this.$router.push(
    name: 'Describe',
    params: {
                id: id
            }
})
//路由配置
{
     path: '/describe',
     name: 'Describe',
     component: Describe,
     props: ture
}
//组件获取
const Describe= {
  props: ['id'],
  template: '&lt;div&gt;User {{ id }}&lt;/div&gt;'
}
</code></pre>
<h2 id="对象模式">对象模式</h2>
<p>如果<code>props</code>是一个对象，它会被按原样设置为组件属性。当<code>props</code>是静态的时候有用。</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    { 
        path: '/promotion/from-newsletter', 
        component: Promotion, 
        props: { 
            newsletterPopup: false
             } 
        }
  ]
})
</code></pre>
<p>案例：</p>
<pre><code class="language-js">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
//组件配置
{
  path: '/describe/:id',
  components: { default: Describe, sidebar: Sidebar },
  props: { default: true, sidebar: false }
}
//单文件组件在props中获取
const Describe= {
    props: ['id'],
    template: '&lt;div&gt;describe{{ id }}&lt;/div&gt;'
}
 //方式二 (这里需要注意如果在props中声明了id，这里方式获取会报undefined。)
this.$attrs['id']
</code></pre>
<h2 id="函数模式">函数模式</h2>
<p>你可以创建一个函数返回<code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    { 
        path: '/search', 
        component: SearchUser, 
        props: (route) =&gt; ({ 
            query: route.query.q 
            }) 
        }
  ]
})
</code></pre>
<p><code>URL /search?q=vue</code>会将<code>{query: 'vue'}</code> 作为属性传递给<code>SearchUser</code>组件。</p>
<p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p>
<pre><code class="language-js">//组件调用（这里只能把参数放置在query中）
 this.$router.push({
     path: '/describe',
     query: {
                id: id
            }
})
  //路由设置
 { 
    path: '/describe', 
    component: describe, 
    props: (route) =&gt; ({ name: route.query.name}) 
 }
 //组价获取
 //方式一
 props:{
     name:''
 }
 this.name
 //方式二 (这里需要注意如果在props中声明了name，这里方式获取会报undefined。)
this.$attrs['name']
</code></pre>
<h1 id="总结">总结</h1>
<p>布尔模式需要用命名路由访问并把参数放置在<code>params</code>中，否则接收不到。<br>
对象路由需要使用path拼接或者放置在<code>query</code>中，否则接收不到。<br>
对象路由静态参数无所谓。<br>
对象模式和函数模式返回的都是一个对象，如果在<code>props</code>中接收则直接<code>this.key</code>访问。若没有在<code>props</code>中接收则通过<code>this.$attrs.key</code>访问</p>
<h1 id="二-声明式的导航">二、声明式的导航</h1>
<p>声明式的导航和编程式的一样，这里就不在过多介绍，给几个例子大家对照编程式理解，例子如下：</p>
<h3 id="字符串">字符串</h3>
<pre><code class="language-html">&lt;router-link to=“news”&gt;click to news page&lt;/router-link&gt;
</code></pre>
<h3 id="命名路由">命名路由</h3>
<pre><code class="language-html">&lt;router-link :to=&quot;{ name: ‘news’, params: { userId: 1111}}&quot;&gt;click to news page&lt;/router-link&gt;
</code></pre>
<h3 id="查询参数">查询参数</h3>
<pre><code class="language-html">&lt;router-link :to=&quot;{ path: ‘/news’, query: { userId: 1111}}&quot;&gt;click to news page&lt;/router-link&gt;
</code></pre>
<h1 id="总结-2">总结</h1>
<p>1.命名路由搭配params，刷新页面参数会丢失<br>
2.查询参数搭配query，刷新页面数据不会丢失<br>
3.接受参数使用this.$router后面就是搭配路由的名称就能获取到参数的值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔试-题目整理1-2017字节]]></title>
        <id>https://cutezhangq.github.io/post/bi-shi-zheng-li/</id>
        <link href="https://cutezhangq.github.io/post/bi-shi-zheng-li/">
        </link>
        <updated>2020-06-16T07:41:25.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录了部分字节2017的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录了部分字节2017的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
<!-- more -->
<p>#【1.】变量a是一个64位有符号的整数，初始值用16进制表示为：0Xf000000000000000； 变量b是一个64位有符号的整数，初始值用16进制表示为：0x7FFFFFFFFFFFFFFF。 则a-b的结果用10进制表示为多少？（）</p>
<h2 id="答案">答案：</h2>
<p><strong>方案1</strong><br>
0Xf000000000000000补码为1111000000000000000000000000000000000000000000000000000000000000<br>
0x7FFFFFFFFFFFFFFF补码为0111111111111111111111111111111111111111111111111111111111111111<br>
a-b=a+(-b)=<br>
1111000000000000000000000000000000000000000000000000000000000000+<br>
1000000000000000000000000000000000000000000000000000000000000001=<br>
10111000000000000000000000000000000000000000000000000000000000001(高位溢出舍去)<br>
则结果为<br>
0111000000000000000000000000000000000000000000000000000000000001=<br>
2<sup>62+2</sup>61+2^60+1</p>
<pre><code class="language-cmd"> ①  原码：

　　原码是指将最高位作为符号位(0表示正，1表示负)，其它数字位代表数值本身的绝对值的数字表示方式。

　　例如：数字6 在计算机中原码表示为：0 000 0110

　　其中，第一个数字0是符号位，0表示正数，0 000110是数字6的二进制数据表示。

　　数字－6 在计算机中原码表示为：1 000 0110

　　以上是在8位计算机中的原码表示，如果在32位或16位计算机中，表示方法也是一样的，只是多了几个数字0而已。

　　例如，在32位 计算机中数字6 的原码表示为：00000000 0000 0000 0000 0000 0000 0110

　　在16位 计算机中数字6 的原码表示为：00000000 0000 0110
</code></pre>
<pre><code class="language-cmd">②   反码：

　　反码表示规则为：如果是正数，则表示方法和原码一样；如果是负数，符号位不变，其余各位取反，则得到这个数字的反码表示形式。

　　例如，数字6 在8位 计算机中的反码就是它的原码：00000110

　　数字－6 在 8位计算机中的反码为：11111001
</code></pre>
<pre><code class="language-cmd">③   补码

　　补码是计算机表示数据的一般方式，其规则为：如果是整数，则表示方法和原码一样；如果是负数，则将数字的反码加上1(相当于将原码数值位取反然后在最低位加1)。

　　例如：数字6 在8位 计算机中的补码就是它的原码：00000110

    数字－6 在8 位 计算机中的补码为：1111 1010
</code></pre>
<p><strong>方案2</strong><br>
0x7FFFFFFFFFFFFFFF+1=0X8000000000000000，那么<br>
a-b=0Xf000000000000000-0X8000000000000000+1<br>
=0X7000000000000001<br>
=16<sup>15*7+16</sup>0<em>1<br>
=2^60</em>7+1<br>
=2<sup>60*(2</sup>2+2<sup>1+2</sup>0)+1<br>
=2<sup>62+2</sup>61+2^60+1</p>
<!-- more -->
<p>#【2.】得到的结果分别是什么？（）</p>
<pre><code class="language-js">console.log(([])?true:false); 
console.log(([]==false?true:false)); 
console.log(({}==false)?true:false) 
</code></pre>
<h2 id="结果true-true-false">结果：true true false</h2>
<p>题考察类型转换，三元运算符先“分清是非”，再决定今后该走哪条路，“==”运算符比较“喜欢”Number类型。下面是题目的类型转换结果：</p>
<pre><code class="language-js">Boolean([]); //true
Number([]); //0
Number({}); // NaN
Number(false); //0
</code></pre>
<p>因此：</p>
<pre><code class="language-js">console.log(([])?true:fasle);// =&gt; console.log((true)?true:false);
console.log([]==false?true:false); // =&gt; console.log(0==0?true:false);
console.log(({}==false)?true:false); // =&gt; console.log((NaN==0)?true:false);
</code></pre>
<p><code>《JavaScript权威指南》的部分相关知识点</code><br>
<strong>“==”运算符（两个操作数的类型不相同时）</strong></p>
<ul>
<li>如果一个值是null，另一个值是undefined，则它们相等</li>
<li>如果一个值是数字，另一个值是字符串，先将字符串转换为数学，然后使用转换后的值进行比较。</li>
<li>如果其中一个值是true，则将其转换为1再进行比较。如果其中的一个值是false，则将其转换为0再进行比较。</li>
<li>如果一个值是对象，另一个值是数字或字符串，则将对象转换为原始值，再进行比较。</li>
</ul>
<p><strong>对象到数字的转换</strong></p>
<ul>
<li>如果对象具有valueOf()方法，后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回一个数字。</li>
<li>否则，如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回。（对象的toString()方法返回一个字符串直接量（作者所说的原始值），JavaScript将这个字符串转换为数字类型，并返回这个数字）。</li>
<li>否则，JavaScript抛出一个类型错误异常。<br>
<strong>空数组转换为数字0</strong></li>
<li>数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值，因此，数组到数学的转换则调用toString()方法。空数组转换为空字符串，空字符串转换为数字0.</li>
</ul>
<!-- more -->
<p>#【3.】下列哪些是块级元素（）<br>
input、ul、hr、li、div、form</p>
<h2 id="答案ul-hr-li-div-form">答案：ul、hr、li、div、form</h2>
<p><strong>input是行内替换元素</strong></p>
<pre><code class="language-cmd"> （1）行内元素有：a b span img input select strong 
  （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p
  （3）常见的空元素：
  &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;
  鲜为人知的是：
  &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt;
</code></pre>
<!-- more -->
<p>#【4.】关于跨域问题下面说法正确的是？（）</p>
<ol>
<li>可以利用flash的http请求，来处理跨域问题</li>
<li>通过iframe设置document.domain可以实现跨域</li>
<li>一般情况下，m.toutiao.com可以ajax请求www.toutiao.com域名下的接口并获得响应</li>
<li>通过jsonp方式可以发出post请求其他域名下的接口</li>
</ol>
<h2 id="答案-通过iframe设置documentdomain可以实现跨域">答案: 通过iframe设置document.domain可以实现跨域</h2>
<p>javascript中实现跨域的方式总结</p>
<pre><code class="language-cmd">- **第一种方式：** jsonp请求；jsonp的原理是利用&lt;script&gt;标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有&lt;img&gt;.
- **第二种方式：** document.domain；这种方式用在主域名相同子域名不同的跨域访问中
- **第三种方式：** window.name；window的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。
- **第四种方式：**  window.postMessage；window.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。
- **第五种方式：**  CORS；CORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。
- **第六种方式：**  Web Sockets；web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。
</code></pre>
<pre><code class="language-cmd">JSONP的优点是：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它

的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支

持；并且在请求完毕后可以通过调用callback的方式回传结果。

JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求；它只支持跨域

HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。
</code></pre>
<!-- more -->
<p>#【5.】以下符合 ES6 写法的有：（）<br>
<img src="https://cutezhangq.github.io/post-images/1596789012438.png" alt="" loading="lazy"></p>
<h2 id="答案c">答案：C</h2>
<p>A、Fun() 把 class 当成方法来用？ var fun = new Func() 这样用就对了<br>
B、export 后面变量没加括号；<br>
D、import readFile 没加括号，是导入 default 的用法，但是前面不是 export 为 default</p>
<p>参照 export 和 import 用法：<br>
1、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export">export用法：</a><br>
2、<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">import用法：</a></p>
<pre><code class="language-js">export {name1,name2, …,nameN};
export {variable1asname1,variable2asname2, …,nameN};
export letname1,name2, …,nameN; // also var
export letname1= …,name2= …, …,nameN; // also var, const

export expression;
export default expression;
export default function (…) { … } // also class, function*
export default function name1(…) { … } // also class, function*
export {name1as default, … };

export * from …;
export {name1,name2, …,nameN} from …;
export {import1asname1,import2asname2, …,nameN} from …;
</code></pre>
<pre><code class="language-js">import defaultMember from &quot;module-name&quot;;
import * as name from &quot;module-name&quot;;
import { member } from &quot;module-name&quot;;
import { member as alias } from &quot;module-name&quot;;
import { member1 , member2 } from &quot;module-name&quot;;
import { member1 , member2 as alias2 , [...] } from &quot;module-name&quot;;
import defaultMember, { member [ , [...] ] } from &quot;module-name&quot;;
import defaultMember, * as name from &quot;module-name&quot;;
import &quot;module-name&quot;;
</code></pre>
<p>#【6.】可继承的样式属性包括（）<br>
<img src="https://cutezhangq.github.io/post-images/1596789677874.png" alt="" loading="lazy"></p>
<h2 id="解析">解析：</h2>
<pre><code class="language-cmd">不可继承的：display、margin、border、padding、background、height、min-height、max- height、width、min-width、max-width、overflow、position、left、right、top、 bottom、z-index、float、clear、table-layout、vertical-align、page-break-after、 page-bread-before和unicode-bidi。

所有元素可继承：visibility和cursor。

内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction。

块状元素可继承：text-indent和text-align。

列表元素可继承：list-style、list-style-type、list-style-position、list-style-image。

表格元素可继承：border-collapse。
</code></pre>
<pre><code class="language-cmd">CSS中可以和不可以继承的属性
一、无继承性的属性
1、display：规定元素应该生成的框的类型
2、文本属性：
vertical-align：垂直文本对齐
text-decoration：规定添加到文本的装饰
text-shadow：文本阴影效果
white-space：空白符的处理
unicode-bidi：设置文本的方向
3、盒子模型的属性：width、height、margin 、margin-top、margin-right、margin-bottom、margin-left、border、border-style、border-top-style、border-right-style、border-bottom-style、border-left-style、border-width、border-top-width、border-right-right、border-bottom-width、border-left-width、border-color、border-top-color、border-right-color、border-bottom-color、border-left-color、border-top、border-right、border-bottom、border-left、padding、padding-top、padding-right、padding-bottom、padding-left
4、背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment
5、定位属性：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index
6、生成内容属性：content、counter-reset、counter-increment
7、轮廓样式属性：outline-style、outline-width、outline-color、outline
8、页面样式属性：size、page-break-before、page-break-after
9、声音样式属性：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during
</code></pre>
<pre><code class="language-cmd">二、有继承性的属性
1、字体系列属性
font：组合字体
font-family：规定元素的字体系列
font-weight：设置字体的粗细
font-size：设置字体的尺寸
font-style：定义字体的风格
font-variant：设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小。
font-stretch：对当前的 font-family 进行伸缩变形。所有主流浏览器都不支持。
font-size-adjust：为某个元素规定一个 aspect 值，这样就可以保持首选字体的 x-height。
2、文本系列属性
text-indent：文本缩进
text-align：文本水平对齐
line-height：行高
word-spacing：增加或减少单词间的空白（即字间隔）
letter-spacing：增加或减少字符间的空白（字符间距）
text-transform：控制文本大小写
direction：规定文本的书写方向
color：文本颜色
3、元素可见性：visibility
4、表格布局属性：caption-side、border-collapse、border-spacing、empty-cells、table-layout
5、列表布局属性：list-style-type、list-style-image、list-style-position、list-style
6、生成内容属性：quotes
7、光标属性：cursor
8、页面样式属性：page、page-break-inside、windows、orphans
9、声音样式属性：speak、speak-punctuation、speak-numeral、speak-header、speech-rate、volume、voice-family、pitch、pitch-range、stress、richness、、azimuth、elevation
三、所有元素可以继承的属性
1、元素可见性：visibility
2、光标属性：cursor
四、内联元素可以继承的属性
1、字体系列属性
2、除text-indent、text-align之外的文本系列属性
五、块级元素可以继承的属性
1、text-indent、text-align
</code></pre>
<p>#【7.】堆的数据结构能够使得堆顶总是维持最大（对于大根堆）或最小（对于小根堆），给定一个数组，对这个数组进行建堆，则平均复杂度是多少？如果只是用堆的 push 操作，则一个大根堆依次输入 3,7,2,4,1,5,8 后，得到的堆的结构示意图是下述图表中的哪个？（）<br>
<img src="https://cutezhangq.github.io/post-images/1596849879994.png" alt="" loading="lazy"></p>
<h1 id="正确答案-d">正确答案: D</h1>
<p>堆的插入操作就是将元素插入到堆的最后，然后继续将其调整为堆。<br>
<img src="https://cutezhangq.github.io/post-images/1596851015506.png" alt="" loading="lazy"></p>
<p>#【8.】http 请求方式 get 和 post 的区别包括（）<br>
<img src="https://cutezhangq.github.io/post-images/1596851060571.png" alt="" loading="lazy"><br>
C . get请求Content-type只能是text/html<br>
--错误，get的 Content-type不仅可以是 text/html，也可以是其他，如 application/json, text/plain 等等</p>
<p>D. get请求可以跨域、post请求不能跨域<br>
-- 错误， post一样可以跨域</p>
<p>#【9.】下面哪些属于JavaScript的typeof运算符的可能结果：（）<br>
symbol<br>
NaN<br>
boolean<br>
null<br>
array<br>
undefined<br>
string</p>
<h1 id="正确答案-symbol-boolean-undefined-string">正确答案: symbol、boolean、undefined、string</h1>
<p>即除了null的基本类型都可以用<code>typeof</code>，在加上Function和Symbol<br>
<img src="https://cutezhangq.github.io/post-images/1596851314915.png" alt="" loading="lazy"></p>
<p>#【10.】老王有两个孩子，已知至少有一个孩子是在星期二出生的男孩。问：两个孩子都是男孩的概率是多大？</p>
<h1 id="正确答案-1327">正确答案: 13/27</h1>
<h3 id="思维缜密的项目经理的解题思路">思维缜密的项目经理的解题思路</h3>
<p>项目经理小李，虽然数学功底不深，编程技术不精，但有个很大的好处是处事不惊，有条不紊。看到题目之后，略加思索，就用最简单的办法弄懂了这个问题，并求出了结果。</p>
<p>首先看如果只知道老王有两个孩子，其他信息都不知道的情况下，两个孩子都是男孩的概率显然是1/4。</p>
<p>再来看看没有“星期二”这个条件的情况，题目变成：老王有两个孩子，已知至少有一个孩子是男孩，问两个孩子都是男孩的概率是多大？那结果显然是1/3。因为在“至少有一个男孩”这样的条件下，只有三种可能：兄妹俩、姐弟俩、兄弟俩。这三种情况是等概率的，而只有一种情况是两个男孩，因此是1/3。</p>
<p>最后再把星期二也考虑进来。还是在上面的基础上扩展，先按照两个孩子的四种可能的性别组合进行划分，然后在每种组合里看看满足有至少一个周二男孩的情况数目：</p>
<p>姐妹俩：不用看了，不满足至少有一个周二男孩的条件。<br>
兄妹俩：那哥哥一定是周二出生的了，妹妹出生的星期数有7种可能。<br>
姐弟俩：弟弟一定是周二出生，姐姐出生的星期数有7种可能。<br>
兄弟俩：兄弟二人出生的星期数总共有7 * 7 = 49种可能，但其中有6 * 6 = 36种都不满足至少有一个人是周二出生的条件，因此实际上有49 - 36 = 13种可能。<br>
因此，满足条件的情况（这里的情况是指综合考虑孩子的性别和出生星期数）总数为7 + 7 + 13 = 27。而其中有13中可能对应于两个孩子都是男孩。因此题目所求概率是13 / 27。</p>
<p>没错，13 / 27就是这道题的答案，出现这样的数字是因为已知条件所提供的信息使得样本空间发生了变化（变小了一点儿）。这就是条件概率带来的影响。</p>
<p>#【11.】下列说法正确的有：（）<br>
<img src="https://cutezhangq.github.io/post-images/1596852716871.png" alt="" loading="lazy"><br>
visiblity:看不见，摸的着. display:看不见，摸不着. display是dom级别的，可以渲染和重绘。 visiblity不是dom级别的，不能重绘，只能渲染</p>
<p>#【12.】TCP断开连接的四次挥手中，第四次挥手发送的包会包含的标记，最正确的描述是？（）<br>
<img src="https://cutezhangq.github.io/post-images/1596852798899.png" alt="" loading="lazy"><br>
我们假设由client提出关闭，则：<br>
第一次：FIN（client发给server）<br>
第二次：ACK（server发给client）<br>
第三次：FIN（server发给client ）<br>
第四次：ACK（client发给server）<br>
<img src="https://cutezhangq.github.io/post-images/1596853188402.png" alt="" loading="lazy"></p>
<ul>
<li>
<p>FIN=1,seq=u</p>
</li>
<li>
<p>ACK=1,seq=v,ack=u+1</p>
</li>
<li>
<p>FIN=1,ACK=1,seq=w,ack=u+1</p>
</li>
<li>
<p>ACK=1,seq=u+1,ack=w+1<br>
<strong>TCP连接建立(“三次握手”)</strong><br>
分为三步：</p>
</li>
<li>
<p>（1）客户机的TCP向服务器的TCP发送一个连接请求报文段，其中不含应用层数据，首部中的SYN标志位被置为1。客户机会随机选择一个起始序号seq=x(连接请求报文不携带数据，但要消耗一个序号)。(SYN = 1, seq = x)</p>
</li>
<li>
<p>（2）服务器的TCP收到连接请求报文段后，如同意建立连接，就向客户机发回确认，并为该TCP连接分配TCP缓存和变量。确认报文段中SYN和ACK位都被置为1，确认号字段的值为x+1，并且服务器随机产生起始序号seq = y(确认报文不携带数据，但也要消耗掉一个序号)。确认报文段同样不包含应用层数据。(SYN = 1, ACK = 1, seq = y, ack = x+1)</p>
</li>
<li>
<p>(3）当客户机收到确认报文段后，还要向服务器给出确认，并且也要分配缓存和变量。报文段的ACK标志位被置1，序号字段为x+1，确认号字段为ack = y+1。该报文段可以携带数据，如果不携带数据则不消耗序号。(ACK = 1, seq = x+1, ack = y+1)</p>
<p>在成功完成以上三步之后，TCP连接就建立了，接下来就可以传送应用层数据了。TCP提供的是<strong>全双工通信</strong>，因此通信双方的应用进程在任何时候都能发送数据。<br>
另外，服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的。这使得服务器易于受到SYN洪泛攻击</p>
</li>
</ul>
<p><strong>TCP连接的释放(“四次挥手”)</strong><br>
分为四步：</p>
<ul>
<li>（1）客户机打算关闭连接，就向其TCP发送一个连接释放报文段，并停止再发送数据，主动关闭TCP连接，该报文段的FIN标志位被置1，seq = u，它等于前面已传送过的数据的最后一个字节的序号加1(FIN报文段即使不携带数据，也要消耗掉一个序号)。TCP是全双工的，可以想象成是一条TCP连接上有两条数据通路。当发送FIN报文时，发送FIN的一端就不能再发送数据，也就是关闭了其中一条数据通路，但对方还可以发送数据。(FIN = 1, seq = u)</li>
<li>（2）服务器收到连接释放报文段后即发出确认，确认号是ack = u+1，而这个报文段自己的序号是v，等于它前面已传送过的数据的最后一个字节的序号加1。此时，从客户机到服务器方向的连接就释放了，TCP连接处于半关闭状态。但服务器若发送数据，客户机任要接收，即从服务器到客户机方向的连接没有关闭。(ACK = 1, seq = v, ack = u+1)</li>
<li>（3）若服务器已经没有要向客户机发送的数据，就通知TCP释放连接，此时其发出FIN = 1的连接释放报文段。(FIN = 1, ACK = 1, seq = w, ack = u+1)</li>
<li>（4）客户机收到连接释放报文段后，必须发出确认。在确认报文段中，ACK字段被置为1，确认号ack = w+1，序号seq = u+1。此时TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，客户机才进入到连接关闭状态。(ACK = 1, seq = u+1, ack = w+1)<br>
因此，服务器端结束TCP连接的时间要比客户端早一些。<br>
<img src="https://cutezhangq.github.io/post-images/1596854115032.png" alt="" loading="lazy"><br>
客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).<br>
服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。<br>
为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。<br>
<img src="https://cutezhangq.github.io/post-images/1596854144489.png" alt="" loading="lazy"></li>
</ul>
<ol>
<li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 2. 服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。 3. 服务端发起自己的FIN段，ACK=K+1, Seq=L 4. 客户端确认。ACK=L+1</li>
</ol>
<p><strong>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</strong><br>
这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p>
<p>#【13.】页面有一个按钮button id为button1，通过原生的js如何禁用？（）</p>
<h2 id="答案-2">答案:</h2>
<p>document.getElementById(“button1”).setAttribute(“disabled”,”true”);<br>
或者<br>
document.getElementById(“button1”).disabled=true;</p>
<h1 id="14关于下列css选择器id选择器-类选择器-伪类选择器-标签名称选择器排序正确的是">【14.】关于下列CSS选择器：ID选择器、类选择器、伪类选择器、标签名称选择器，排序正确的是：（）</h1>
<h2 id="答案-3">答案:</h2>
<p><code>ID选择器&gt;Class选择器=伪类&gt;标签名称选择器</code><br>
一般来说，选择器的优先级（从上往下依次降低）是：<br>
在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。<br>
作为style属性写在元素内的样式<br>
id选择器<br>
类选择器(伪类选择器和类选择器的优先级是一样的，谁在后面谁起作用，因为我们知道后面的样式会覆盖前面的样式)<br>
标签选择器<br>
通配符选择器<br>
浏览器自定义的样式 ​<br>
<img src="https://cutezhangq.github.io/post-images/1596854884377.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1597415706178.png" alt="" loading="lazy"></p>
<!-- more -->
<h1 id="15假设-a-是一个由线程-1-和线程-2-共享的初始值为-0-的全局变量则线程-1-和线程-2-同时执行下面的代码最终-a-的结果不可能是">【15.】假设 a 是一个由线程 1 和线程 2 共享的初始值为 0 的全局变量，则线程 1 和线程 2 同时执行下面的代码，最终 a 的结果不可能是（）</h1>
<p>boolean isOdd = false;</p>
<p>for(int i=1;i&lt;=2;++i)<br>
{<br>
if（i%2==1）isOdd = true；<br>
else isOdd = false；<br>
a+=i*(isOdd?1:-1)；<br>
}</p>
<h1 id="正确答案-1">正确答案: 1</h1>
<p>每个线程对a 均做了两次读写操作，分别是 “ +1 ” 和 “ -2 ”<br>
而题目问了是最终a 的结果，所以 a 的结果取决于各自线程对 a 的先后读写的顺序<br>
结论：a的可能取值为-1、0、-2<br>
<img src="https://cutezhangq.github.io/post-images/1596856039742.png" alt="" loading="lazy"><br>
假设两线程为A、B，设有3种情况：<br>
1.AB不并发：此时相当于两个方法顺序执行。A执行完后a=-1，B使用-1作为a的初值，B执行完后a=-2<br>
2.AB完全并发：此时读写冲突，相当于只有一个线程对a的读写最终生效。相同于方法只执行了一次。此时a=-1<br>
3.AB部分并发：假设A先进行第一次读写，得到a=1;之后A的读写被B覆盖了。B使用用1作为a的初值，B执行完后a=0</p>
<h1 id="16使用htmlcss实现如图布局border-width5px格子大小是50px50pxhover时边框变成红色需要考虑语义化">【16.】使用HTML+CSS实现如图布局，border-width:5px，格子大小是50px*50px，hover时边框变成红色，需要考虑语义化。</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596858038715.png" alt="" loading="lazy"></figure>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;title&gt;Document&lt;/title&gt;
  &lt;style type=&quot;text/css&quot;&gt;
    table {
      /* border-collapse:separate;*/
      border: none;
      border-spacing: 0;
    }

    td {
      position: relative;
      width: 50px;
      height: 50px;
      border: 5px solid blue;
      background: #fff;
      color: green;
      text-align: center;
      line-height: 50px;
      display: inline-block;
    }

    tr:not(:first-child) td {
      margin-top: -5px;
    }

    tr td:not(:last-child) {
      margin-right: -5px;
    }

    td:hover {
      border-color: red;
      cursor: pointer;      /*悬浮于连接上时，通常为手*/
      z-index: 2;
    }
  &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
  &lt;table&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<p>要设置td的display属性为inline-block<br>
效果：<br>
<img src="https://cutezhangq.github.io/post-images/1596858118441.png" alt="" loading="lazy"></p>
<!-- more -->
<h1 id="17给出一个上传文件时不用刷新页面的方案要求写出关键部分的js代码">【17.】给出一个上传文件时不用刷新页面的方案，要求写出关键部分的js代码。</h1>
<h2 id="答案-4">答案:</h2>
<pre><code class="language-html">&lt;input id=&quot;upload&quot; type=&quot;file&quot; /&gt;
&lt;button id=&quot;upload-btn&quot;&gt; upload &lt;/button&gt;
</code></pre>
<pre><code class="language-js">document.getElementById('upload-btn').onclick = function(){
    var input = document.getElementById('upload');
    var file = input.files[0];
    var formData = new FormData();
    formData.append('file',file);
    fetch({
        url:'/upload',
        mothod:'POST',
        body:formData
    }).then((d)=&gt;{
        console.log('result is',d);
        alert('上传完毕');
    })
}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1596858583685.png" alt="" loading="lazy"></figure>
<h1 id="18设计一个todo-list页面结构如下图所示要求">【18.】设计一个TODO List，页面结构如下图所示，要求：</h1>
<p>使用HTML与CSS完成界面开发</p>
<p>实现添加功能：输入框中可输入任意字符，按回车后将输入字符串添加到下方列表的最后，并清空输入框</p>
<p>实现删除功能：点击列表项后面的“X”号，可以删除该项</p>
<p>实现模糊匹配：在输入框中输入字符后，将当前输入字符串与已添加的列表项进行模糊匹配，将匹配到的结果显示在输入框下方。如匹配不到任何列表项，列表显示空</p>
<p>注：以上代码实现需要能在浏览器中正常显示与执行。<br>
<img src="https://cutezhangq.github.io/post-images/1596956262981.png" alt="" loading="lazy"></p>
<h2 id="答案-5">答案：</h2>
<pre><code class="language-css">    body{
            margin: 0;
            background-color: #f5f5f5;
        }
        h1{
            margin: 30px 0 0 0;
            color: #ff5550;
            text-align: center;
            font-size: 60px;
        }
        #back{
            width: 300px;
            margin: 0 auto;
            border: 1px solid #333;
            box-shadow: 0px 0px 3px #999;
            background-color: #fff;
        }
        #back input{
            width: 100%;
            box-sizing: border-box;
            line-height: 30px;
            border: none;
            border-bottom: 1px solid #000;
            padding: 5px 15px;
            font-size: 18px;
        }
        #list_back .single{
            position: relative;
            border-bottom: 1px solid #000;
        }
        #list_back .single p{
            width: 100%;
            height: 30px;
            margin: 0;
            line-height: 30px;
            padding: 5px 15px;
        }
        #list_back .single span{
            position: absolute;
            right: 0;
            top: 0;
            width: 30px;
            text-align: center;
            line-height: 40px;
            font-size: 18px;
            color: #000;
            cursor: pointer;
        }
</code></pre>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;TODOList&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;todos&lt;/h1&gt;
&lt;div id=&quot;back&quot;&gt;
    &lt;input id=&quot;addInput&quot; type=&quot;text&quot; name=&quot;&quot;&gt;
    &lt;div id=&quot;list_back&quot;&gt;

    &lt;/div&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<pre><code class="language-js">  var oAddInput = document.getElementById('addInput');
    var oList_back = document.getElementById('list_back');
    var all = document.getElementsByClassName('single');
    oAddInput.onkeyup = function(){
        // alert(event.keyCode);//13
        // alert(event.code);//Enter
        if(event.keyCode == '13'){
            // alert('add');
            var oDiv = document.createElement('div');
            var oSpan = document.createElement('span');
            var oP = document.createElement('p');
            oDiv.appendChild(oP);
            oDiv.appendChild(oSpan);
            oP.innerHTML = oAddInput.value;
            oSpan.innerHTML = '&amp;times;';
            oDiv.className = 'single';
            oList_back.appendChild(oDiv);
            oAddInput.value = '';//清空输入框
            oSpan.onclick= function(){
                oList_back.removeChild(this.parentNode);//绑定删除方法
            };
        }
    };
    //模糊查询
    function select(){
        oAddInput.addEventListener('keyup', function(e){//监听键盘抬起事件（所有键盘按钮）
            // console.log(e.target.value);
            var str = e.target.value;
            var reg = new RegExp('(' + str + ')', 'g');//匹配到的文字变红色，准备工作
            for( var i = 0; i&lt;all.length; i++ ){
                var one = all[i].getElementsByTagName('p')[0];
                var newStr = one.innerText.replace(reg, '&lt;font color=red&gt;$1&lt;/font&gt;');//换--&gt;红色，用innerText防止用innerHTML将标签也读取出来出错。
                if( one.innerText.indexOf(str) == -1 ){//也选用innerHTML
                    all[i].style.display = 'none';//匹配不到的掩藏
                }else{
                    one.innerHTML = newStr;//匹配到的变红
                }
            }
            if(str == ''){
                for( var i = 0; i&lt;all.length; i++ ){
                    all[i].style.display = 'block';//输入框空时全部显示
                }
            }
        });
    }
    select();  //函数解析完就运行
</code></pre>
]]></content>
    </entry>
</feed>