<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-08-17T08:36:38.894Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[JWT认证原理（JSON Web Token）]]></title>
        <id>https://cutezhangq.github.io/post/jwt-ren-zheng-yuan-li/</id>
        <link href="https://cutezhangq.github.io/post/jwt-ren-zheng-yuan-li/">
        </link>
        <updated>2020-08-17T06:27:29.000Z</updated>
        <summary type="html"><![CDATA[<p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于👉分布式站点的<code>单点登录（SSO）</code>场景👈。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。👀</p>
<p>JWT认证原理（JSON Web Token）</p>
<p>互联网服务离不开用户认证。一般流程是下面这样。🙌</p>
]]></summary>
        <content type="html"><![CDATA[<p><code>Json web token (JWT)</code>, 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于👉分布式站点的<code>单点登录（SSO）</code>场景👈。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。👀</p>
<p>JWT认证原理（JSON Web Token）</p>
<p>互联网服务离不开用户认证。一般流程是下面这样。🙌</p>
<!-- more -->
<h1 id="一-传统的session认证">一、传统的Session认证</h1>
<h2 id="流程session">流程session</h2>
<p>认证的流程一般如下：</p>
<ul>
<li>1.用户向服务器发送用户名和密码。</li>
<li>2.服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。</li>
<li>3.服务器向用户返回一个 session_id，写入用户的 Cookie。</li>
<li>4.用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。</li>
<li>5.服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。</li>
</ul>
<h2 id="缺点">缺点</h2>
<ul>
<li>session保存在服务器，当注册用户很多，会增加服务器的开销。</li>
<li>用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，限制了负载均衡的能力。这也意味着限制了应用的扩展能力。</li>
<li>session是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到<code>跨站请求伪造（CSRF）</code>的攻击。</li>
</ul>
<p>这种模式的问题在于，扩展性（scaling）不好。单机当然没有问题，如果是服务器集群，或者是跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。</p>
<p>举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？</p>
<p>一种解决方案是 <code>session 数据持久化</code>，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。</p>
<p>另一种方案是服务器索性不保存 session 数据了，所有数据都<code>保存在客户端</code>，每次请求都发回服务器。<code>JWT</code>就是这种方案的一个代表。</p>
<h1 id="二-jwt-认证">二、JWT 认证</h1>
<h2 id="token">token</h2>
<p><code>JWT</code>是基于<code>token</code>的鉴权机制类似于<code>http协议</code>也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。<br>
这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p>
<h2 id="流程">流程</h2>
<ul>
<li>1.用户使用用户名密码来请求服务器。</li>
<li>2.服务器进行验证用户的信息</li>
<li>3.服务器通过验证发送给用户一个token</li>
<li>4.客户端存储token，并在每次请求时附送上这个token值</li>
<li>5.服务端验证token值，并返回数据</li>
</ul>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持<code>CORS(跨来源资源共享)策略</code>，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p>
<h2 id="jwt-的原理">JWT 的原理</h2>
<p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。</p>
<pre><code class="language-json">{
  &quot;姓名&quot;: &quot;张三&quot;,
  &quot;角色&quot;: &quot;管理员&quot;,
  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;
}
</code></pre>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>
服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<h1 id="三-jwt-的数据结构">三、JWT 的数据结构</h1>
<pre><code class="language-js">    const accessToken =    &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1597647417511.png" alt="" loading="lazy"></figure>
<p>JWT 的三个部分依次如下:</p>
<pre><code class="language-cmd">Header（头部）
Payload（负载）
Signature（签名）
</code></pre>
<p>写成一行，就是下面的样子。<br>
Header.Payload.Signature<br>
下面依次介绍这三个部分。</p>
<h2 id="header">Header</h2>
<p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p>
<pre><code class="language-json">{
  &quot;alg&quot;: &quot;HS256&quot;,
  &quot;typ&quot;: &quot;JWT&quot;
}
</code></pre>
<p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>
最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p>
<h2 id="payload">Payload</h2>
<p>载荷就是存放有效信息的地方。这些有效信息包含三个部分:<br>
标准中注册的声明<br>
公共的声明<br>
私有的声明<br>
Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p>
<pre><code class="language-cmd">iss (issuer)：签发人
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：生效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号
</code></pre>
<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。</p>
<pre><code class="language-json">{
  &quot;sub&quot;: &quot;1234567890&quot;,
  &quot;name&quot;: &quot;John Doe&quot;,
  &quot;admin&quot;: true
}
</code></pre>
<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>
这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p>
<h2 id="signature">Signature</h2>
<p>JWT的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<ul>
<li>header (base64加密)</li>
<li>payload (base64加密)</li>
<li>secret 密钥<br>
Signature 部分是对前两部分的签名，防止数据篡改。<br>
首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</li>
</ul>
<pre><code class="language-cmd">HMACSHA256(
  base64UrlEncode(header) + &quot;.&quot; +
  base64UrlEncode(payload),
  secret)
</code></pre>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（.）分隔，就可以返回给用户。</p>
<p><strong>注意</strong>：<code>secret</code>是保存在服务器端的，<code>jwt</code>的签发生成也是在服务器端的，<code>secret</code>就是用来进行<code>jwt</code>的签发和<code>jwt</code>的验证，所以，它就是你服务端的<code>私钥</code>，在任何场景都不应该流露出去。一旦客户端得知这个<code>secret</code>, 那就意味着客户端是可以<code>自我签发jwt</code>了。如果觉得密钥泄露了，请及时修改。</p>
<h2 id="base64url">Base64URL</h2>
<p>前面提到，Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。<br>
JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符<code>+、/和=</code>，在 URL 里面有特殊含义，所以要被替换掉：<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p>
<h1 id="五-jwt-的几个特点">五、JWT 的几个特点</h1>
<p>（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。<br>
（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。<br>
（3）JWT 不仅可以<code>用于认证</code>，也可以用于<code>交换信息</code>。有效使用 JWT，可以<code>降低服务器查询数据库的次数</code>。<br>
（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。<br>
（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。<br>
（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</p>
<p>案例：request.js</p>
<pre><code class="language-js">import axios from 'axios'
import global from '../../api/global'
import router from '../../router/router'
// 拿到token
function getAccessToken() {
    // 从localStorage中获取token
    //let accessToken = localStorage.getItem('accessToken')
    const accessToken = &quot;eyJhbGciOiJIUzI1NiJ9.eyJvcGVuSWQiOiJvVjc2QndpYVVYcGcxYUo2S1RDb3hQbWppRHg0IiwiaXNzIjoib3JhbmdlMiIsImRldmljZUlkIjoiZ2hfOGY0ODdhNjEyZmM5XzkzNzdjYjk4YWU0MDU3NzgiLCJpYXQiOjE1OTQ4MDYzMTJ9.6kS29myZlCUxQqvZOEGmhJhQ66NCwk_raB5HGRGhr7M&quot;
    if (accessToken != null&amp;&amp; refreshToken !== undefined) {
        return &quot;Bearer &quot; + accessToken
    }
}

// 创建一个axios实例
const axiosJWT = axios.create({
    baseURL: global.API,
    timeout: 300000,
    headers: {
        'Authorization': getAccessToken(),
        &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot;,
    }
})

async function refreshToken() {    //之前的逻辑是去发送请求拿到刷新的token(refreshToken)
    // instance是当前request.js中已创建的axios实例
    // return await axiosBASIC.get('/auth/reissueToken', {
    //   params: {
    //     refreshToken: getRefreshToken()
    //   }
    // })
    return await axiosBASIC.get('/auth/issueToken', {
    params: {
      openId: &quot;oV76BwiaUXpg1aJ6KTCoxPmjiDx4&quot;
    }
  })
}


// 给实例添加一个setToken方法，用于登录后将最新token动态添加到header，同时将token保存在localStorage中
axiosJWT.setToken = (accessToken) =&gt; {
    localStorage.setItem('accessToken', accessToken)
    axiosJWT.defaults.headers['Authorization'] = &quot;Bearer &quot;+accessToken
}

// 是否正在刷新的标记
let isRefreshing = false
// 重试队列，每一项将是一个待执行的函数形式
let requests = []


// 响应拦截
axiosJWT.interceptors.response.use(response =&gt; {
        const {code} = response.data
        // 接下来会在这里进行token过期重发逻辑处理
        switch(code){
            case 604:
                //非法token！
                break
            case 603:
                //缺少token！
            case 605:
                //accessToken已过期！
                //获取当前失败的请求
                const config = response.config
                if (!isRefreshing) {
                    isRefreshing = true
                   return refreshToken()
                        .then(res =&gt; {
                            const {code} = res.data
                            switch(code){
                                case 200:
                                    //refreshToken有效，刷新Token成功
                                    //将最新的token更新到header中，同时保存在localStorage中
                                    const {accessToken} = res.data.data
                                    console.log('access_token====='+accessToken)
                                    axiosJWT.setToken(accessToken)
                                    // 刷新下之前的请求配置
                                    config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
                                    config.baseURL = ''
                                    //已经刷新了token，将所有队列中的请求进行重试
                                    requests.forEach(cb =&gt; cb(accessToken))
                                    //清空队列
                                    requests = []
                                    // 重试之前的请求并返回promise
                                    return axiosJWT(config)
                                case 500:
                                case 606:
                                    //refreshToken过期
                                   router.push(&quot;/auth&quot;)
                            }
                        })
                        .finally(() =&gt; {
                            //刷新成功，恢复标志位
                            isRefreshing = false
                        })
                } else {
                    // 正在刷新token，返回一个未执行resolve的promise
                    return new Promise((resolve) =&gt; {
                        // 将resolve放进队列，用一个函数形式来保存，等token刷新后直接执行
                        requests.push((accessToken) =&gt; {
                            config.baseURL = ''
                            config.headers['Authorization'] = &quot;Bearer &quot;+accessToken
                            resolve(axiosJWT(config))
                        })
                    })
                }
            case 701:
                //JWT认证失败!
                break
            default: 
            return response.data
        }
    },error =&gt; {
        return Promise.reject(error)
    })

export  {
    axiosJWT,
    axiosBASIC
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[跨域问题]]></title>
        <id>https://cutezhangq.github.io/post/kua-yu-wen-ti/</id>
        <link href="https://cutezhangq.github.io/post/kua-yu-wen-ti/">
        </link>
        <updated>2020-08-15T03:07:52.000Z</updated>
        <summary type="html"><![CDATA[<p>什么是同源<br>
👉为了保证使用者信息的安全，防止恶意网站篡改用户数据，一些常见的Web技术都默认采用了同源策略（如Silverlight, Flash, XMLHttpRequest, Dom等）。</p>
<p>那如何判断同源呢？</p>
<ul>
<li>1、相同的协议</li>
<li>2、相同的域名</li>
<li>3、相同的的端口号</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>什么是同源<br>
👉为了保证使用者信息的安全，防止恶意网站篡改用户数据，一些常见的Web技术都默认采用了同源策略（如Silverlight, Flash, XMLHttpRequest, Dom等）。</p>
<p>那如何判断同源呢？</p>
<ul>
<li>1、相同的协议</li>
<li>2、相同的域名</li>
<li>3、相同的的端口号</li>
</ul>
<!-- more -->
<p><img src="https://cutezhangq.github.io/post-images/1597462361320.png" alt="" loading="lazy"><br>
<img src="https://cutezhangq.github.io/post-images/1597462366080.png" alt="" loading="lazy"></p>
<p>同源政策：一是针对接口的请求，二是针对Dom的查询</p>
<h1 id="跨域解决方案">跨域解决方案</h1>
<ul>
<li>1、 通过jsonp跨域</li>
<li>2、 document.domain + iframe跨域</li>
<li>3、 location.hash + iframe</li>
<li>4、 window.name + iframe跨域</li>
<li>5、 postMessage跨域</li>
<li>6、 跨域资源共享（CORS）</li>
<li>7、 nginx代理跨域</li>
<li>8、 nodejs中间件代理跨域</li>
<li>9、 WebSocket协议跨域</li>
</ul>
<h1 id="iframe标签跨域">Iframe标签跨域</h1>
<pre><code class="language-html">&lt;body&gt;
    &lt;iframe src=&quot;http://www.baidu.com&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;
&lt;/body&gt;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1597462564913.png" alt="" loading="lazy"></figure>
<h1 id="跨域资源共享cors">跨域资源共享（CORS）</h1>
<p>1、 前端设置：<br>
1.）原生ajax</p>
<pre><code class="language-js">var xhr = new XMLHttpRequest();
//前端设置是否带cookie
xhr.withCredentials = true;
xhr.open('get','data.json');    //open(method,url,async)
xhr.send('user=admin');
xhr.onreadystatechange = function(){
    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){
        console.log(xhr.responseText);
    }
}
</code></pre>
<p>0: 请求未初始化<br>
1: 服务器连接已建立<br>
2: 请求已接收<br>
3: 请求处理中<br>
4: 请求已完成，且响应已就绪              readyState=4的时候才去做后续逻辑</p>
<p><strong>xhr.readyState == 4  是表示后台处理完成了。</strong><br>
<strong>xhr.status == 200 是表示处理的结果是OK的。</strong><br>
<img src="https://cutezhangq.github.io/post-images/1597463024441.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔试-题目整理2-2020bilibili ]]></title>
        <id>https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/</id>
        <link href="https://cutezhangq.github.io/post/bi-shi-ti-mu-zheng-li-2/">
        </link>
        <updated>2020-08-14T07:18:46.000Z</updated>
        <summary type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里收录了部分bilibili 2020的笔试题，一起来看看叭，查漏补缺鸭😘<br>
涉及的众多的基础知识点....</p>
<!-- more -->
<h1 id="1关于domcontentloaded和load事件说法正确的是">【1.】关于DOMContentLoaded和load事件说法正确的是？</h1>
<p>A DOMContentLoaded事件比load事件更早执行<br>
B load事件比DOMContentLoaded事件更早执行<br>
C 按监听代码从上到下先后执行<br>
D dom文档完全加载完后执行load事件</p>
<h2 id="答案a-domcontentloaded事件比load事件更早执行">答案：A DOMContentLoaded事件比load事件更早执行</h2>
<p><strong>DOMContentLoaded</strong>：DOM解析完成之后。<br>
当纯HTML被完全加载以及解析时，DOMContentLoaded事件会被触发，而不必等待样式表，图片或者子框架完成加载。</p>
<pre><code class="language-cmd">MDN
当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。
注意：DOMContentLoaded 事件必须等待其所属script之前的样式表加载解析完成才会触发。
</code></pre>
<p><strong>load</strong>：页面HTML、CSS、JS..及图片等外链资源加载完成之后，才会执行load。<br>
当一个资源及其依赖资源已完成加载时，将触发load事件。</p>
<h1 id="2如何在-div-容器里展示-divdiv-这几个字符">【2.】如何在 div 容器里展示 <div></div> 这几个字符？</h1>
<h2 id="答案documentqueryselectordivinnertext-divdiv">答案：document.querySelector('div').innerText = &quot;<div></div>&quot;</h2>
<pre><code class="language-html">  &lt;!--  innerHTML：设置或获取标签所包含的HTML与文本信息。（不含标签本身）
        innerText：设置或获取标签所包含的文本信息。（不含标签本身）
        outerHTML：设置或获取标签本身以及所包含的HTML与文本信息。（包含标签本身）
        outerText：设置或获取标签本身以及所包含的文本信息。（包含标签本身） --&gt;

&lt;div id=&quot;div1&quot;&gt;
        &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
&lt;/div&gt;
    &lt;script&gt;
        var div=document.getElementsByTagName(&quot;div&quot;);
        console.log(div[0].innerHTML);      //  &lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;
        console.log(div[0].innerText);         //  this is text
        console.log(div[0].outerHTML);     // &lt;div id=&quot;div1&quot;&gt;&lt;p id=&quot;p1&quot;&gt;this is text&lt;/p&gt;&lt;/div&gt;
        console.log(div[0].outerText);        //  this is text
    &lt;/script&gt;
</code></pre>
<h1 id="3以下不是box-sizing的属性是">【3.】以下不是box-sizing的属性是？</h1>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>content-box</td>
<td>这是由 CSS2.1 规定的宽度高度行为。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。</td>
</tr>
<tr>
<td>border-box</td>
<td>为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应从父元素继承 box-sizing 属性的值。</td>
</tr>
</tbody>
</table>
<h2 id="box-sizing">box-sizing</h2>
<p>box-sizing 最主要的用法是规定容器元素的<strong>最终尺寸计算方式。</strong></p>
<p>如果你创造了一个 <code>&lt;div&gt;</code> 没有设置 <code>box-sizing</code>属性为<code>border-box</code>(不设置的话默认值为 <code>content-box</code>)，同时你设置 <code>width:100px; border:10px solid red; padding:10px;</code>那么最终 div 容器的实际宽度为：</p>
<pre><code class="language-js">100px(width)+2*10px*(padding)+2*10px(border)=140px
</code></pre>
<p>所以你会得到一个比你预期（100px）还要更大的容器，结果就是会破坏网页布局。<br>
注意：容易 margin 的尺寸不会被计算入最终容器宽度，因为对他的定义为对这个容器的留白，但不属于容器本身。</p>
<p>如果当我们定义一个容器的 <code>box-sizing</code>属性为<code>border-box</code>时<br>
（表达式：<code>br{box-sizing:border-box}</code>），那么我们创建一个和上段中相同设置的<code>&lt;div&gt;</code>容器时，那么他的最终宽度即为 100px, 那么它的内容部分（content）的有效宽度变成了</p>
<pre><code class="language-js">100px-2*10px-2*10px =60px; 
</code></pre>
<p>所以你会得到一个你预期大小的盒子容器，但是只是被压缩了内容部分尺寸而已，但是对于整体布局而言益处颇多。</p>
<p>所以要合理利用好这个属性，这个属性十分重要。</p>
<!-- more -->
<h1 id="4-1-32-的值为">【4.】‘-1 &gt;&gt;&gt; 32 的值为(  )’</h1>
<p>emm...知识盲区😳😳😳</p>
<h2 id="答案232-1">答案：2^32-1</h2>
<pre><code class="language-cmd">&gt;&gt;这个是带符号右移
&gt;&gt;&gt; 这个是无符号右移
无符号右移运算符（&gt;&gt;&gt;）
</code></pre>
<p><code>按二进制形式把所有的数字向右移动对应位数，低位移出(舍弃)，高位的空位补零。对于正数来说和带符号右移（&gt;&gt;） 相同，但是对于负数来说不同。</code><br>
<strong>正数</strong><br>
例：20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为0001 0100<br>
2、<code>将二进制数向右移两位，高位补符号位（0）</code>，得到0000 0101<br>
3、最后<code>将二进制数转化成十进制数</code>，0000 0101转化为十进制为5<br>
所以，20 &gt;&gt; 2 = 5</p>
<p><strong>负数</strong><br>
例：-20 &gt;&gt; 2<br>
1、<code>首先转化为二进制</code>，20的二进制为1110 1100   //<code>取反加1</code>  20的二进制为0001 0100 取反得到1110 1011 加1后得到1110 1100<br>
2、将<code>二进制数向右移两位，高位补符号位（1）</code>，得到1111 1011<br>
3、最后<code>将二进制数转化成十进制数</code>，1111 1011转化为十进制为-5  //取反 0000 0100 加1   0000 0101 因为是负数，也就是1000 0101也就是2的2次方加2的零次方 等于-5<br>
所以，-20 &gt;&gt; 2 = -5</p>
<p><code>1</code>的二进制 00000000 00000000 00000000 00000001<br>
<code>-1</code>的二进制 10000000 00000000 00000000 00000001 取反加1得到补码 11111111 11111111 11111111 11111111  //首位不变，其余为取反<br>
右移32位（高位补符号位1） 也就是11111111 11111111 11111111 11111111  //32位<br>
假设该数值加上一也就是变成<br>
1 00000000 00000000 00000000 00000000  //1后面有32个0<br>
那就把刚才加上的1减掉<br>
也就是结果<br>
2^32-1<br>
<img src="https://cutezhangq.github.io/post-images/1597476991984.png" alt="" loading="lazy"></p>
<h1 id="51-2-3mapparseint">【5.】['1', '2', '3'].map(parseInt) ( )</h1>
<h2 id="答案1-nan-nan">答案：[1, NaN, NaN]</h2>
<pre><code class="language-js">['1', '2', '3'].map((item, index) =&gt; {
    return parseInt(item, index)
})
parseInt('1', 0) // 1  默认十进制的1
parseInt('2', 1) // NaN 1进制没有2
parseInt('3', 2) // NaN,2进制逢2进1
</code></pre>
<p>ps 啥是parseInt<br>
parseInt('11',2) //二进制的11 转换成十进制应该是 3</p>
<p>['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4]<br>
意思是0(默认0是十进制)进制的十转换成十进制是多少 1进制的十转换成十进制是多少 二进制的10转换成十进制是多少...</p>
<pre><code class="language-js">['1','2','3'].map((a,b,arr)=&gt;{  //a:循环得到的那一项的值；b:循环时的索引; arr整个数组的值
    parseInt(a,b);  //a代表那一项； b代表进制
})
// parseInt(string, radix)   
// 将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。
parseInt('1', 0) // radix 为 0，默认以十进制解析字符串，返回 1 

parseInt('2', 1) // radix 为 1，不在 2 ~ 36 之间，返回 NaN 

parseInt('3', 2) // radix 为 2， 字符串却为 3，超出二进制的表示范围，因此要解析的字符串和基数矛盾，返回 NaN
//2 进制只有0和1，，，3超出范围了
</code></pre>
<h1 id="6计算结果">【6.】计算结果</h1>
<pre><code class="language-js">console.log(1);
setTimeout(() =&gt; {console.log(2)}, 0);
console.log(3);
Promise.resolve(4).then(b =&gt; {
console.log(b);
});
console.log(5);
</code></pre>
<h2 id="答案1-3-5-4-2">答案：1 3 5 4 2</h2>
<p><code>console.log()</code> -&gt; <code>同步</code><br>
<code>promise</code>-&gt; <code>异步，微任务</code><br>
<code>setTimeout</code> -&gt; <code>异步，宏任务</code><br>
执行顺序:<code>同步</code> &gt;<code>异步,微任务</code> &gt; <code>异步，宏任务</code></p>
<h1 id="7mathabs-6666-的结果是多少">【7.】Math.abs(-6.666) 的结果是多少?</h1>
<h2 id="答案6666">答案：6.666</h2>
<p><code>Math.abs()</code>转为为绝对值</p>
<p><code>parseInt(7/2)</code>丢弃小数部分,保留整数部分</p>
<p><code>Math.ceil(7/2)</code>向上取整,有小数就整数部分加1</p>
<p><code>Math.round(7/2)</code>四舍五入</p>
<p><code>Math.floor(7/2)</code>向下取整</p>
<h1 id="812345-的数组的基础上-删除第一个-和-最后一位">【8.】[1,2,3,4,5] 的数组的基础上 删除第一个 和 最后一位</h1>
<p>[1,2,3,4,5].replace(1, -1)<br>
[1,2,3,4,5].reverse(1，-1)<br>
[1,2,3,4,5].toString(-1，1)<br>
[1,2,3,4,5].slice(1, -1)</p>
<h2 id="答案12345slice1-1">答案：[1,2,3,4,5].slice(1, -1)</h2>
<p><code>slice(1,-1)</code>  slice不会操作原数组，会返回一个新数组 。 表示从索引为0开始截取，-1表示截取到倒数第二个，并将这个新数组返回。</p>
<p><code>replace</code>方法返回一个由替换值（replacement）替换部分或所有的模式（pattern）匹配项后的新字符串。原字符串不会改变。</p>
<p><code>reverse</code>方法将数组中元素的位置颠倒，并返回该数组。数组的第一个元素会变成最后一个，数组的最后一个元素变成第一个。该方法会改变原数组。</p>
<h1 id="9计算结果">【9.】计算结果</h1>
<pre><code class="language-js">function setname(name){
 this.name = name
}
setname.prototype.printName = function(){ console.log(this.name) }
let a = new setname(&quot;cc&quot;)
a.name = &quot;dd&quot;
a.__proto__.name = &quot;ee&quot;

a.__proto__.printName()  // ?
a.printName() // ?
</code></pre>
<h2 id="答案ee-dd">答案：ee dd</h2>
<p>首先定义了一个函数 setname（）接下来定义了一个方法printname<br>
调用new 方法生成对象传参 “cc” 此时a对象上面的name属性为cc<br>
<img src="https://cutezhangq.github.io/post-images/1597559456328.png" alt="" loading="lazy"><br>
接下来通过a.name修改属性 此时a对象的name属性为 dd<br>
<img src="https://cutezhangq.github.io/post-images/1597559495746.png" alt="" loading="lazy"><br>
最后修改通过a修改构造函数中的属性 --proto--<br>
<img src="https://cutezhangq.github.io/post-images/1597559529281.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[谈谈深拷贝、浅拷贝]]></title>
        <id>https://cutezhangq.github.io/post/tan-tan-shen-kao-bei-qian-kao-bei/</id>
        <link href="https://cutezhangq.github.io/post/tan-tan-shen-kao-bei-qian-kao-bei/">
        </link>
        <updated>2020-08-12T01:21:13.000Z</updated>
        <summary type="html"><![CDATA[<p>js对象不像变量那样，简单的赋值就能进行克隆的，对象进行赋值时，只是创建了一个新的指针指向相同的存储空间。👀如果不想改变原数据，那么就要对对象进行深克隆了</p>
]]></summary>
        <content type="html"><![CDATA[<p>js对象不像变量那样，简单的赋值就能进行克隆的，对象进行赋值时，只是创建了一个新的指针指向相同的存储空间。👀如果不想改变原数据，那么就要对对象进行深克隆了</p>
<!-- more -->
<pre><code class="language-js">var a={a:1}
var b=a;
b.a=2
</code></pre>
<p>这时输出a你会发现，a的值同样发生了改变。<br>
这一点在你进行数据操作时，又想保留原来数据时，你就需要深度克隆了。</p>
<h1 id="怎么深拷贝一个对象深拷贝一个对象的时候应该怎么做">怎么深拷贝一个对象？（深拷贝一个对象的时候应该怎么做？）</h1>
<p>深度克隆的方法:</p>
<h1 id="1-js序列化">1、js序列化</h1>
<p>将js转换成字符串，然后再将字符串转换成js对象。<br>
js字符串的克隆就比对象的克隆简单多了。简单的赋值操作就能完成。<br>
深拷贝,但拷贝的数据里不能有函数，不然处理不了</p>
<pre><code class="language-js">var obj = {a:1};
var str = JSON.stringify(obj); //序列化对象         JSON.stringify() 方法将一个JavaScript 对象或值转换为JSON 字符串
var newobj = JSON.parse(str); //还原
var b = newobj;
b.a = 2;
console.log(obj.a); // 1
console.log(b.a);   // 2 
</code></pre>
<h1 id="2-进行对象的遍历复制">2、进行对象的遍历复制</h1>
<p>进行对象的遍历复制，对对象的每一条属性进行复制，这样就能进行对象的深度克隆<br>
如何实现深拷贝?<br>
浅拷贝里的数据不能有对象/数组，即使有对象/数组可以继续遍历对象/数组，拿到里面的每一项值，<br>
一直到拿到的是基本数据类型，然后再复制，这时就是深拷贝</p>
<pre><code class="language-js">
function newobj(obj) {
  var str, newobj = obj.constructor === Array ? [] : {};//constructor 属性返回对创建此对象的数组函数的引用。创建相同类型的空数据
  if (typeof obj !== 'object') {
    return;
  } else {
    for (var i in obj) {
      if (typeof obj[i] === 'object'){//判断对象的这条属性是否为对象
        newobj[i] = newObj(obj[i]);//若是对象进行嵌套调用
      }else{
        newobj[i] = obj[i];
      }
    }
  }
  return newobj;//返回深度克隆后的对象
};
</code></pre>
<pre><code class="language-js">    var obj = {a:1};
    function newobj(obj) {
      var str, newobj = obj.constructor === Array ? [] : {}; //constructor 属性返回对创建此对象的数组函数的引用。创建相同类型的空数据
      if (typeof obj !== 'object') {
        return;
      } else {
        for (var i in obj) {
          if (typeof obj[i] === 'object') { //判断对象的这条属性是否为对象
            newobj[i] = newObj(obj[i]); //若是对象进行嵌套调用
          } else {
            newobj[i] = obj[i];
          }
        }
      }
      return newobj; //返回深度克隆后的对象
    };

    var b = newobj(obj);
    b.a = 2;
    console.log(obj.a); // 1
    console.log(b.a);   // 2 
</code></pre>
<h1 id="3-应用es6的语法对象展开运算符进行对象的展开赋值">3、应用es6的语法对象展开运算符——进行对象的展开赋值</h1>
<p>应用es6的语法对象展开运算符：进行对象的展开赋值</p>
<pre><code class="language-js">var obj = {a:0}
var b = {...obj}
</code></pre>
<pre><code class="language-js">var obj = {a:0}
var b = {...obj}
b.a = 2;
console.log(obj.a); // 0
console.log(b.a);   // 2 
</code></pre>
<p>基本数据类型：存放的就是 实际的数据，可直接复制<br>
克隆数据：对象/数组</p>
<h1 id="如何深拷贝一个数组">如何深拷贝一个数组？</h1>
<h1 id="concat">concat</h1>
<p>concat() 方法用于合并两个或多个<strong>数组</strong>。此方法不会更改现有数组，而是返回一个新数组。</p>
<pre><code class="language-js">//concat()    深复制
  let arr_0 = [1,3,{name:'hhh'}];
  let arr_1 = arr_0.concat();
  arr_1[1] = 6
  console.log(arr_0)  // [1, 3, {name: &quot;hhh&quot;}]
  console.log(arr_1)  // [1, 6, {name: &quot;hhh&quot;}]
</code></pre>
<h1 id="浅拷贝深拷贝-区别">浅拷贝/深拷贝 区别：</h1>
<ul>
<li>拷贝 产生了新的数据     ：深拷贝</li>
<li>拷贝 数据的引用    ：浅拷贝</li>
</ul>
<h1 id="浅拷贝对象数组特点">浅拷贝（对象/数组）：特点：</h1>
<ul>
<li>拷贝的引用，<br>
= 修改拷贝后的数据会影响原数据</li>
</ul>
<h1 id="深拷贝特点">深拷贝：特点：</h1>
<ul>
<li>生成新数据，</li>
<li>不影响原数据</li>
</ul>
<h1 id="常用的拷贝技术">常用的拷贝技术</h1>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue-router中传参的方式都有哪些]]></title>
        <id>https://cutezhangq.github.io/post/vue-router-zhong-chuan-can-de-fang-shi-du-you-na-xie/</id>
        <link href="https://cutezhangq.github.io/post/vue-router-zhong-chuan-can-de-fang-shi-du-you-na-xie/">
        </link>
        <updated>2020-08-11T13:11:46.000Z</updated>
        <summary type="html"><![CDATA[<p>没事就需要翻翻vue官网，好长时间不看了。<a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">Vue路由组件传参</a>🏃‍♀🏃<br>
主要从this.$router.push的name和params、path和qurey；router-link :to传参来回答</p>
]]></summary>
        <content type="html"><![CDATA[<p>没事就需要翻翻vue官网，好长时间不看了。<a href="https://router.vuejs.org/zh/guide/essentials/passing-props.html#%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%BC%8F">Vue路由组件传参</a>🏃‍♀🏃<br>
主要从this.$router.push的name和params、path和qurey；router-link :to传参来回答</p>
<!-- more -->
<h1 id="常用的传递方式">常用的传递方式</h1>
<h1 id="一-编程式的导航-routerpush">一、编程式的导航 router.push</h1>
<h2 id="直接传拼接">直接传（拼接）</h2>
<pre><code class="language-js">//组件调用
this.$router.push({path: `/describe/${id}`})
//路由配置
{
    path: '/describe/:id',
    name: 'Describe',
    component: Describe
}
//Describe组件获取
this.$route.query.id
</code></pre>
<h2 id="query传参get请求">query传参——get请求</h2>
<p>传递的参数会拼接在url上</p>
<pre><code class="language-js"> //组件调用
this.$router.push({
 path: '/describe',
 query: {
            id: id
        }
})
//路由配置
{
    path: '/describe',
    name: 'Describe',
    component: Describe
}
//Describe组件获取
this.$route.query.id
</code></pre>
<p>（注：以上两种方式都会把参数放置在 this.$route.query 中）</p>
<h2 id="params传参post请求">params传参——post请求</h2>
<p>params传参<br>
（注：这里的路由匹配方式：通过路由属性中的name来确定匹配的路由。如果提供了 path，params 会被忽略）</p>
<p>params传参不会拼接在url上，但存在一个问题-------如果强制刷新页面会丢失参数</p>
<pre><code class="language-js">//组件调用
this.$router.push({
    name: 'Describe',
    params: {
                id: id
            }
})
//路由配置
{
     path: '/describe',
     name: 'Describe',
     component: Describe
}
//Describe组件获用
this.$route.params.id
</code></pre>
<h1 id="新发现">新发现</h1>
<p>现在的路由传参的方式没有改变，上述内容依然有效。组件内获取的方式增加了props方式接收，可以把参数传到props里了，功能更强大了。</p>
<p>如果在组件内要用props接收路由上的参数可以分为三种方式</p>
<h2 id="布尔模式">布尔模式</h2>
<p>如果<code>props</code> 被设置为<code>true</code>，<code>route.params</code>将会被设置为组件属性。</p>
<pre><code class="language-js">//组件调用
//路由传递方式只能使用params传递参数
this.$router.push(
    name: 'Describe',
    params: {
                id: id
            }
})
//路由配置
{
     path: '/describe',
     name: 'Describe',
     component: Describe,
     props: ture
}
//组件获取
const Describe= {
  props: ['id'],
  template: '&lt;div&gt;User {{ id }}&lt;/div&gt;'
}
</code></pre>
<h2 id="对象模式">对象模式</h2>
<p>如果<code>props</code>是一个对象，它会被按原样设置为组件属性。当<code>props</code>是静态的时候有用。</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    { 
        path: '/promotion/from-newsletter', 
        component: Promotion, 
        props: { 
            newsletterPopup: false
             } 
        }
  ]
})
</code></pre>
<p>案例：</p>
<pre><code class="language-js">// 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
//组件配置
{
  path: '/describe/:id',
  components: { default: Describe, sidebar: Sidebar },
  props: { default: true, sidebar: false }
}
//单文件组件在props中获取
const Describe= {
    props: ['id'],
    template: '&lt;div&gt;describe{{ id }}&lt;/div&gt;'
}
 //方式二 (这里需要注意如果在props中声明了id，这里方式获取会报undefined。)
this.$attrs['id']
</code></pre>
<h2 id="函数模式">函数模式</h2>
<p>你可以创建一个函数返回<code>props</code>。这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等。</p>
<pre><code class="language-js">const router = new VueRouter({
  routes: [
    { 
        path: '/search', 
        component: SearchUser, 
        props: (route) =&gt; ({ 
            query: route.query.q 
            }) 
        }
  ]
})
</code></pre>
<p><code>URL /search?q=vue</code>会将<code>{query: 'vue'}</code> 作为属性传递给<code>SearchUser</code>组件。</p>
<p>请尽可能保持 <code>props</code> 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 <code>props</code>，请使用包装组件，这样 Vue 才可以对状态变化做出反应。</p>
<pre><code class="language-js">//组件调用（这里只能把参数放置在query中）
 this.$router.push({
     path: '/describe',
     query: {
                id: id
            }
})
  //路由设置
 { 
    path: '/describe', 
    component: describe, 
    props: (route) =&gt; ({ name: route.query.name}) 
 }
 //组价获取
 //方式一
 props:{
     name:''
 }
 this.name
 //方式二 (这里需要注意如果在props中声明了name，这里方式获取会报undefined。)
this.$attrs['name']
</code></pre>
<h1 id="总结">总结</h1>
<p>布尔模式需要用命名路由访问并把参数放置在<code>params</code>中，否则接收不到。<br>
对象路由需要使用path拼接或者放置在<code>query</code>中，否则接收不到。<br>
对象路由静态参数无所谓。<br>
对象模式和函数模式返回的都是一个对象，如果在<code>props</code>中接收则直接<code>this.key</code>访问。若没有在<code>props</code>中接收则通过<code>this.$attrs.key</code>访问</p>
<h1 id="二-声明式的导航">二、声明式的导航</h1>
<p>声明式的导航和编程式的一样，这里就不在过多介绍，给几个例子大家对照编程式理解，例子如下：</p>
<h3 id="字符串">字符串</h3>
<pre><code class="language-html">&lt;router-link to=“news”&gt;click to news page&lt;/router-link&gt;
</code></pre>
<h3 id="命名路由">命名路由</h3>
<pre><code class="language-html">&lt;router-link :to=&quot;{ name: ‘news’, params: { userId: 1111}}&quot;&gt;click to news page&lt;/router-link&gt;
</code></pre>
<h3 id="查询参数">查询参数</h3>
<pre><code class="language-html">&lt;router-link :to=&quot;{ path: ‘/news’, query: { userId: 1111}}&quot;&gt;click to news page&lt;/router-link&gt;
</code></pre>
<h1 id="总结-2">总结</h1>
<p>1.命名路由搭配params，刷新页面参数会丢失<br>
2.查询参数搭配query，刷新页面数据不会丢失<br>
3.接受参数使用this.$router后面就是搭配路由的名称就能获取到参数的值</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇淫巧技]]></title>
        <id>https://cutezhangq.github.io/post/qi-yin-qiao-ji/</id>
        <link href="https://cutezhangq.github.io/post/qi-yin-qiao-ji/">
        </link>
        <updated>2020-08-11T01:49:25.000Z</updated>
        <summary type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
]]></summary>
        <content type="html"><![CDATA[<p>🙈🙉🙊本文收录一些计算的技巧，让功能的实现不止一种！<br>
还在持续更新中...✨<br>
👉对数据进行奇偶判断<br>
👉判断类型 封装（可判断所有类型）<br>
👉判断是否存在<br>
👉检测 某个对象 是不是 另一个对象 的 实例<br>
👉判断一个 实例 是否属于它的 父类型</p>
<!-- more -->
<h1 id="对数据进行奇偶判断">对数据进行奇偶判断</h1>
<p>普通选手：</p>
<pre><code class="language-js">const n = 11;
if(n%2 == 1){
   console.log('奇数')
}else{
    console.log('偶数')
}
</code></pre>
<p>种子选手：&amp; 位运算符的妙用，相“与”</p>
<pre><code class="language-js">const n = 11;
  if(n &amp; 1){    // 取代 n % 2 == 1 的判断，因为其还要转成二进制的判断
    console.log('奇数')
  }else{
    console.log('偶数')
  }
</code></pre>
<h1 id="判断类型-封装可判断所有类型">判断类型 封装（可判断所有类型）</h1>
<p>普通选手：</p>
<pre><code class="language-js">  function isObjArr(value) {
    if (Object.prototype.toString.call(value) === &quot;[object Array]&quot;) {
      console.log('value是数组');
    } else if (Object.prototype.toString.call(value) === '[object Object]') { //这个方法兼容性好一点
      console.log('value是对象');
    } else {
      console.log('value不是数组也不是对象')
    }
  }
</code></pre>
<p>种子选手：<br>
判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。<br>
因此要真正完美判断时，我们需要区分对待:<br>
* 基本类型( null ): 使用String( )，如：String(null)<br>
* 基本类型(string / number / boolean / undefined) + function + symbol: 直接使用 typeof 即可<br>
* 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断，本质上还是调用 valueof 进行判断。</p>
<pre><code class="language-js"> let class2type = {}
  'Array Date RegExp Object Error'.split(' ').forEach(e =&gt; class2type['[object ' + e + ']'] = e.toLowerCase())

  function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[Object.prototype.toString.call(obj)] || 'object' : typeof obj
  }
</code></pre>
<p>这里的.call是绑定this对象指向当前的Object对象<br>
**RegExp：**是正则表达式（regular expression）的简写。</p>
<h1 id="判断是否存在">判断是否存在</h1>
<pre><code class="language-js">  if(typeof a!=&quot;undefined&quot;){     //不要去使用 if(a) 因为如果 a 不存在（未声明）则会出错
      xxx
    }
</code></pre>
<h1 id="检测-某个对象-是不是-另一个对象-的-实例">检测 某个对象 是不是 另一个对象 的 实例</h1>
<p>（测试一个对象在其原型链中是否存在一个构造函数的prototype属性）</p>
<pre><code class="language-js">  function test(){};
  var b = new test();
  var c = new test();
  console.log(b instanceof test); //true   可用来判断一个变量是否是某个对象的实例
  console.log(c == b);  //false
</code></pre>
<h1 id="判断一个-实例-是否属于它的-父类型">判断一个 实例 是否属于它的 父类型</h1>
<p>instanceof 可以在 继承关系 中用来判断一个 实例 是否属于它的 父类型。</p>
<pre><code class="language-js"> var a = new Array();  
 console.log(a instanceof Array);  //true
 console.log(a instanceof Object); //true  因为 Array 是 Object的 子类
</code></pre>
<h1 id="判断-对象是否为空-的三种方法">判断 对象是否为空 的三种方法：</h1>
<pre><code class="language-js">  //方法1：JSON.stringify(xxx)=='{}'    转成字符串，看值是不是空对象
  c = {};
  if(JSON.stringify(c)=='{}'){
    console.log('空对象');  //空对象
  }


  //方法2：for in  有没有数据在它的里面
  obj = {};
  function abc(obj){
    for(var a in obj){
      console.log('不是空对象');
    }
    console.log('空对象');  
  }
  abc();  //空对象


  //方法3：Object.keys(xxx).length == 0    对象转成数组，再看数组的长度
    //方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。
  t = {};
  if(Object.keys(t).length == 0){
    console.log('空对象');    //空对象
  }else{
    console.log('不是空对象');
  }
</code></pre>
<h1 id="apply的使用">.apply（）的使用</h1>
<h2 id="1找出数组最大元素">（1）找出数组最大元素</h2>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>
<pre><code class="language-js">var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
</code></pre>
<h2 id="2将数组的空元素变为undefined">（2）将数组的空元素变为undefined</h2>
<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>
<pre><code class="language-js">Array.apply(null, ['a', ,'b'])
// [ 'a', undefined, 'b' ]
</code></pre>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。<br>
因此，遍历内部元素的时候，会得到不同的结果。</p>
<pre><code class="language-js">var a = ['a', , 'b'];

function print(i) {
console.log(i);
}

a.forEach(print)
// a
// b

Array.apply(null, a).forEach(print)
// a
// undefined
// b
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[this、apply、call、bind]]></title>
        <id>https://cutezhangq.github.io/post/thisapplycallbind/</id>
        <link href="https://cutezhangq.github.io/post/thisapplycallbind/">
        </link>
        <updated>2020-08-09T07:12:03.000Z</updated>
        <summary type="html"><![CDATA[<p>👉面试题：this的指向一般是由什么决定的，一般怎么改变它的指向？<br>
🙋答：this就是<code>属性或方法</code><strong>当前</strong>所在的<code>对象</code>；可以通过将函数赋值给变量的方式改变this的指向，也可以通过<code>.call()、.apply()、.bind()</code>的方式改变this的指向...🏃‍♀</p>
]]></summary>
        <content type="html"><![CDATA[<p>👉面试题：this的指向一般是由什么决定的，一般怎么改变它的指向？<br>
🙋答：this就是<code>属性或方法</code><strong>当前</strong>所在的<code>对象</code>；可以通过将函数赋值给变量的方式改变this的指向，也可以通过<code>.call()、.apply()、.bind()</code>的方式改变this的指向...🏃‍♀</p>
<!-- more -->
<h1 id="面试题-区别bind与call和apply">面试题: 区别bind()与call()和apply()?</h1>
<ul>
<li>都能指定函数中的this</li>
<li>call()/apply()是 立即调用函数</li>
<li>bind()是 将函数返回</li>
</ul>
<pre><code class="language-js">//在不传参的形式下： .call同.apply  可以强制this的指向
  var obj0 = {username:'gaga'};
  function foo(){
    console.log(this);
  }
  foo.call(obj0)        //{username:'gaga'}
  foo.apply(obj0)       //{username:'gaga'}

//传参时： call直接传   apply放到数组中传
  function foo1(data){
      console.log(this,data);
  }
  foo1.call(obj0,33)      //{username:'gaga'} 33    直接从第二个参数开始，依次传入
  foo1.apply(obj0,[33])   //{username:'gaga'} 33  第二个参数必须是数组，传入的数据放在数组里
  foo.bind(obj0)   //没有输出
</code></pre>
<p><strong>bind的特点：</strong><br>
绑定完this不会立即调用当前的函数，而是将函数返回</p>
<pre><code class="language-js">//bind的特点：
    //绑定完this不会立即调用当前的函数，而是将函数返回
      //写法1.
    var bar = foo.bind(obj0)
    console.log('bar',bar)      //foo(){  console.log(this);  }
    bar();                     //{username:'gaga'}
      //写法2.
    foo.bind(obj0)();         //{username:'gaga'}

//bind的用法：用来指定回调函数的this      vue中常用
    setTimeout(function(){
      console.log('---',this)   //不绑定bind,this是window；bind后this指向为obj0     --- {username: &quot;gaga&quot;}
    }.bind(obj0),1000)

//bind传参的方式：
    function fun(age) {
        this.name = 'kobe';
        this.age = age;
        console.log('dd');
    }
    var obj = {};
    fun.bind(obj, 12)();
    console.log(obj.name, obj.age);      //kobe 12
</code></pre>
<h1 id="this">this</h1>
<ul>
<li>this可以用在构造函数之中，表示实例对象。<br>
除此之外，this还可以用在别的场合。但不管是什么场合，this都有一个共同点：它总是返回一个对象。<br>
简单说，<code>this就是属性或方法“当前”所在的 对象。</code><br>
下面是一个实际的例子。</li>
</ul>
<pre><code class="language-js">var person = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

person.describe()       // &quot;姓名：张三&quot;
</code></pre>
<p>上面代码中，this.name表示name属性所在的那个对象。由于this.name是在describe方法中调用，而describe方法所在的当前对象是person，因此this指向person，this.name就是person.name。<br>
由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，<br>
<strong>即this的指向是可变的。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var B = {
    name: '李四'
};

B.describe = A.describe;
B.describe()    // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe属性被赋给B，于是B.describe就表示describe方法所在的当前对象是B，所以this.name就指向B.name。<br>
稍稍重构这个例子，this的动态指向就能看得更清楚。</p>
<pre><code class="language-js">function f() {
    return '姓名：'+ this.name;
}

var A = {
    name: '张三',
    describe: f
};

var B = {
    name: '李四',
    describe: f
};

A.describe() // &quot;姓名：张三&quot;
B.describe() // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，函数f内部使用了this关键字，随着f所在的对象不同，this的指向也不同。<br>
<strong>只要函数被赋给另一个变量，this的指向就会变。</strong></p>
<pre><code class="language-js">var A = {
    name: '张三',
    describe: function () {
        return '姓名：'+ this.name;
    }
};

var name = '李四';
var f = A.describe;
f()     // &quot;姓名：李四&quot;
</code></pre>
<p>上面代码中，A.describe被赋值给变量f，内部的this就会指向f运行时所在的对象（本例是顶层对象）。</p>
<h1 id="2-this-的使用场景">2. this 的使用场景</h1>
<h2 id="1全局环境">（1）全局环境</h2>
<pre><code class="language-js">this === window // true

function f() {
    console.log(this === window);
}
f() // true
</code></pre>
<h2 id="2构造函数">（2）构造函数</h2>
<p>构造函数中的this，指的是实例对象。</p>
<pre><code class="language-js">var Obj = function (p) {
    this.p = p;
};
</code></pre>
<h2 id="3对象的方法">（3）对象的方法</h2>
<p>如果对象的方法里面包含this，this的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变this的指向。<br>
但是，这条规则很不容易把握。请看下面的代码。</p>
<pre><code class="language-js">var obj ={
    foo: function () {
        console.log(this);
    }
};

obj.foo() // obj
</code></pre>
<p>上面代码中，obj.foo方法执行时，它内部的this指向obj。<br>
但是，下面这几种用法，都会改变this的指向。</p>
<pre><code class="language-js">// 情况一
(obj.foo = obj.foo)() // window
// 情况二
(false || obj.foo)() // window
// 情况三
(1, obj.foo)() // window

</code></pre>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，this依然会指向全局对象。</p>
<pre><code class="language-js">var a = {
    b: {
        m: function() {
            console.log(this.p);
        },
        p: 'Hello'
    }
};

var hello = a.b.m;
hello() // undefined
</code></pre>
<p><strong>即：当有赋值情况时，先将值替换，然后再看this的指向</strong></p>
<h1 id="使用注意点">使用注意点</h1>
<h2 id="countersection-避免多层-this">counter(section) &quot;　&quot;避免多层 this</h2>
<p>由于this的指向是不确定的，所以切勿在函数中包含多层的this。</p>
<pre><code class="language-js">var o = {
    f1: function () {
        console.log(this);
        var f2 = function () {
            console.log(this);
        }();
    }
}

o.f1()
// Object
</code></pre>
<p>上面代码包含两层this，结果运行后，第一层指向对象o，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<pre><code class="language-js">var temp = function () {
    console.log(this);
};

var o = {
    f1: function () {
        console.log(this);
        var f2 = temp();
    }
}
</code></pre>
<p>一个解决方法是在第二层改用一个指向外层this的变量。</p>
<pre><code class="language-js">var o = {
    f1: function() {
        console.log(this);
        var that = this;
        var f2 = function() {
            console.log(that);    //然后在内层使用that，就不会发生this指向的改变
        }();
    }
}

o.f1()
// Object
// Object
</code></pre>
<p><strong>上面代码定义了变量that，固定指向外层的this，然后在内层使用that，就不会发生this指向的改变。</strong><br>
事实上，使用一个变量固定this的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。<br>
JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的this指向顶层对象，就会报错。</p>
<h2 id="2-countersection-避免数组处理方法中的-this">2 &quot;.&quot; counter(section) &quot;　&quot;避免数组处理方法中的 this</h2>
<p>数组的<code>map</code>和<code>forEach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用this。<br>
——<strong>使用中间变量固定this。</strong><br>
或者<strong>是将this当作forEach方法的第二个参数，固定它的运行环境。</strong></p>
<h3 id="一种方法就是前面提到的使用中间变量固定this">一种方法，就是前面提到的，使用中间变量固定this。</h3>
<p>应用：</p>
<pre><code class="language-js"> //下单
      async orderDown() {
        var _this = this;
        //获取选择的商品数组信息
        this.listData.forEach(function(item,index){
          goodsIdArr.forEach(function(item2,index2){
            if(item.productId == item2){
              _this.chooseProductList.push(_this.listData[index]);
            }
          })
        });
      },
</code></pre>
<h3 id="另一种方法是将this当作foreach方法的第二个参数固定它的运行环境">另一种方法是将this当作foreach方法的第二个参数，固定它的运行环境。</h3>
<pre><code class="language-js">var o = {
    v: 'hello',
    p: [ 'a1', 'a2' ],
    f: function f() {
        this.p.forEach(function (item) {
            console.log(this.v + ' ' + item);
        }, this);
    }
}

o.f()
// hello a1
// hello a2
</code></pre>
<h2 id="3-countersection-避免回调函数中的-this">3 &quot;.&quot; counter(section) &quot;　&quot;避免回调函数中的 this</h2>
<p><strong>回调函数中的this往往会改变指向，最好避免使用。</strong></p>
<h2 id="4-绑定-this-的方法">4 &quot;. &quot;绑定 this 的方法</h2>
<p>this的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把this固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call、apply、bind</code>这三个方法，来切换/固定this的指向。</p>
<h1 id="call">.call()</h1>
<p>函数实例的call方法，<strong>可以指定函数内部this的指向（即函数执行时所在的作用域）</strong>，然后在所指定的作用域中，调用该函数。</p>
<pre><code class="language-js">var obj = {};

var f = function () {
    return  this;
};

f() === window // true
f.call(obj) === obj // true
</code></pre>
<p>上面代码中，全局环境运行函数f时，this指向全局环境（浏览器为window对象）；<br>
call方法可以改变this的指向，指定this指向对象obj，然后在对象obj的作用域中运行函数f。<br>
call方法的参数，应该是一个对象。如果参数为空、null和undefined，则默认传入全局对象。</p>
<pre><code class="language-js">var n = 123;
var obj = { n: 456 };

function a() {
    console.log(this.n);
}

a.call() // 123
a.call(null) // 123
a.call(undefined) // 123
a.call(window) // 123
a.call(obj) // 456
</code></pre>
<p>如果call方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入call方法。</p>
<pre><code class="language-js">var f = function () {
    return  this;
};

f.call(5)    // Number {[[PrimitiveValue]]: 5}
</code></pre>
<p>上面代码中，call的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定f内部的this。<br>
call方法还可以接受多个参数。</p>
<p>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<pre><code class="language-js">function add(a, b) {
    return a + b;
}

add.call(this, 1, 2) // 3
</code></pre>
<p>上面代码中，call方法指定函数add内部的this绑定当前环境（对象），并且参数为1和2，因此函数add运行后得到3。<br>
call方法的一个应用是调用对象的原生方法。</p>
<pre><code class="language-js">var obj = {};
obj.hasOwnProperty('toString') // false

// 覆盖掉继承的 hasOwnProperty 方法
obj.hasOwnProperty = function () {
    return true;
};
obj.hasOwnProperty('toString') // true

Object.prototype.hasOwnProperty.call(obj, 'toString') // false
</code></pre>
<p>上面代码中，hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个问题，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。</p>
<!-- more -->
<h1 id="2-apply">2 .apply()</h1>
<p>apply方法的作用与call方法类似，也是改变this指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。<br>
apply方法的第一个参数也是this所要指向的那个对象，如果设为null或undefined，则等同于指定全局对象。<br>
第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在call方法中必须一个个添加，但是在apply方法中，<strong>必须以数组形式添加</strong>。</p>
<pre><code class="language-js">function f(x, y){
    console.log(x + y);
}

f.call(null, 1, 1) // 2
f.apply(null, [1, 1]) // 2
</code></pre>
<p>上面代码中，f函数本来接受两个参数，使用apply方法以后，就变成可以接受一个数组作为参数。<br>
利用这一点，可以做一些有趣的应用。</p>
<h2 id="1找出数组最大元素">（1）找出数组最大元素</h2>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用apply方法和Math.max方法，就可以返回数组的最大元素。</p>
<pre><code class="language-js">var a = [10, 2, 4, 15, 9];
Math.max.apply(null, a) // 15
</code></pre>
<h2 id="2将数组的空元素变为undefined">（2）将数组的空元素变为undefined</h2>
<p>通过apply方法，利用Array构造函数将数组的空元素变成undefined。</p>
<pre><code class="language-js">Array.apply(null, ['a', ,'b'])
// [ 'a', undefined, 'b' ]
</code></pre>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。<br>
因此，遍历内部元素的时候，会得到不同的结果。</p>
<pre><code class="language-js">var a = ['a', , 'b'];

function print(i) {
console.log(i);
}

a.forEach(print)
// a
// b

Array.apply(null, a).forEach(print)
// a
// undefined
// b
</code></pre>
<h2 id="3转换类似数组的对象">（3）转换类似数组的对象</h2>
<p>另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。</p>
<pre><code class="language-js">Array.prototype.slice.apply({0: 1, length: 1}) // [1]
Array.prototype.slice.apply({0: 1}) // []
Array.prototype.slice.apply({0: 1, length: 2}) // [1, undefined]
Array.prototype.slice.apply({length: 1}) // [undefined]
</code></pre>
<p>上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。</p>
<h2 id="4绑定回调函数的对象">（4）绑定回调函数的对象</h2>
<pre><code class="language-js">var o = new  Object();

o.f = function () {
    console.log(this === o);
}

var f = function (){
    o.f.apply(o);
    // 或者 o.f.call(o);
};

// jQuery 的写法
$('#button').on('click', f);
</code></pre>
<p>上面代码中，点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的bind方法。</p>
<h1 id="3-bind">3 .bind()</h1>
<p>bind方法用于将函数体内的this绑定到某个对象，然后返回一个新函数。</p>
<pre><code class="language-js">var d = new Date();
d.getTime() // 1481869925657

var print = d.getTime;
print() // Uncaught TypeError: this is not a Date object.
</code></pre>
<p>上面代码中，我们将d.getTime方法赋给变量print，然后调用print就报错了。这是因为getTime方法内部的this，绑定Date对象的实例，赋给变量print以后，内部的this已经不指向Date对象的实例了。<br>
bind方法可以解决这个问题。</p>
<pre><code class="language-js">var print = d.getTime.bind(d);
print() // 1481869925657
</code></pre>
<p>上面代码中，bind方法将getTime方法内部的this绑定到d对象，这时就可以安全地将这个方法赋值给其他变量了。<br>
bind方法的参数就是所要绑定this的对象，下面是一个更清晰的例子。</p>
<pre><code class="language-js">var counter = {
    count: 0,
    inc: function () {
        this.count++;
    }
};

var func = counter.inc.bind(counter);
func();
counter.count // 1
</code></pre>
<p>上面代码中，counter.inc方法被赋值给变量func。这时必须用bind方法将inc内部的this，绑定到counter，否则就会出错。<br>
this绑定到其他对象也是可以的。</p>
<pre><code class="language-js">var counter = {
    count: 0,
    inc: function () {
        this.count++;
    }
};

var obj = {
    count: 100
};
var func = counter.inc.bind(obj);
func();
obj.count // 101
</code></pre>
<p>上面代码中，bind方法将inc方法内部的this，绑定到obj对象。结果调用func函数以后，递增的就是obj内部的count属性。<br>
bind还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<pre><code class="language-js">var add = function (x, y) {
    return  x * this.m + y * this.n;
}

var obj = {
    m: 2,
    n: 2
};

var newAdd = add.bind(obj, 5);
newAdd(5) // 20
</code></pre>
<h2 id="1每一次返回一个新函数">（1）每一次返回一个新函数</h2>
<p>bind方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<pre><code class="language-js">element.addEventListener('click', o.m.bind(o));
</code></pre>
<p>上面代码中，click事件绑定bind方法生成的一个匿名函数。这样会导致无法取消绑定，所以，下面的代码是无效的。</p>
<pre><code class="language-js">element.removeEventListener('click', o.m.bind(o));
</code></pre>
<p>正确的方法是写成下面这样：</p>
<pre><code class="language-js">var listener = o.m.bind(o);
element.addEventListener('click', listener);
// ...
element.removeEventListener('click', listener);
</code></pre>
<h2 id="回调函数是-javascript-最常用的模式之一但是一个常见的错误是将包含this的方法直接当作回调函数">回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含this的方法直接当作回调函数。</h2>
<p>解决方法就是使用bind方法，将counter.inc绑定counter。</p>
<pre><code class="language-js">var counter = {
    count: 0,
    inc: function () {
        'use strict';
        this.count++;
    }
};

function callIt(callback) {
    callback();
}

callIt(counter.inc.bind(counter));
counter.count // 1
</code></pre>
<p>上面代码中，callIt方法会调用回调函数。<br>
这时如果直接把counter.inc传入，调用时counter.inc内部的this就会指向全局对象。<br>
使用bind方法将counter.inc绑定counter以后，就不会有这个问题，this总是指向counter。<br>
还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的this指向，很可能也会出错。</p>
<pre><code class="language-js">var obj = {
    name: '张三',
    times: [1, 2, 3],
    print: function () {
        this.times.forEach(function (n) {
            console.log(this.name);
        });
    }
};

obj.print()    // 没有任何输出
</code></pre>
<p>上面代码中，obj.print内部this.times的this是指向obj的，这个没有问题。但是，forEach方法的回调函数内部的this.name却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<pre><code class="language-js">obj.print = function () {
    this.times.forEach(function (n) {
        console.log(this === window);
    });
};

obj.print()
// true
// true
// true
</code></pre>
<p>解决这个问题，也是通过bind方法绑定this。</p>
<pre><code class="language-js">obj.print = function () {
    this.times.forEach(function (n) {
        console.log(this.name);
    }.bind(this));
};

obj.print()
// 张三
// 张三
// 张三
</code></pre>
<h2 id="3结合call方法使用">（3）结合call方法使用</h2>
<p>利用bind方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的slice方法为例。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[slot插槽]]></title>
        <id>https://cutezhangq.github.io/post/slot-cha-cao/</id>
        <link href="https://cutezhangq.github.io/post/slot-cha-cao/">
        </link>
        <updated>2020-08-07T03:04:18.000Z</updated>
        <summary type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
]]></summary>
        <content type="html"><![CDATA[<p>👉插槽，也就是slot，👈是组件的一块HTML模板，这块模板显示不显示、以及怎样显示由父组件来决定。<br>
实际上，一个slot最核心的两个问题在这里就点出来了，是<strong>显示不显示</strong>和<strong>怎样显示</strong>。😘</p>
<!-- more -->
<p>由于插槽是一块模板，所以，对于任何一个组件，从模板种类的角度来分，其实都可以分为<strong>非插槽模板</strong>和<strong>插槽模板</strong>两大类。<br>
非插槽模板指的是html模板，比如‘div、span、ul、table’这些，非插槽模板的显示与隐藏以及怎样显示由组件自身控制；<br>
插槽模板是slot，它是一个空壳子，因为它的显示与隐藏以及最后用什么样的html模板显示由父组件控制。但是插槽显示的位置却由子组件自身决定，slot写在组件template的什么位置，父组件传过来的模板将来就显示在什么位置。</p>
<h1 id="单个插槽-默认插槽-匿名插槽">单个插槽 | 默认插槽 | 匿名插槽</h1>
<p>首先是单个插槽，单个插槽是vue的官方叫法，但是其实也可以叫它默认插槽，或者与具名插槽相对，我们可以叫它匿名插槽。因为它不用设置name属性。<br>
单个插槽可以放置在组件的任意位置，但是就像它的名字一样，一个组件中只能有一个该类插槽。相对应的，具名插槽就可以有很多个，只要名字（name属性）不同就可以了。<br>
下面通过一个例子来展示。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;father&quot;&gt;
        &lt;h3&gt;这里是父组件&lt;/h3&gt;
        &lt;child&gt;
            &lt;div class=&quot;tmpl&quot;&gt;
              &lt;span&gt;菜单1&lt;/span&gt;
              &lt;span&gt;菜单2&lt;/span&gt;
              &lt;span&gt;菜单3&lt;/span&gt;
              &lt;span&gt;菜单4&lt;/span&gt;
              &lt;span&gt;菜单5&lt;/span&gt;
              &lt;span&gt;菜单6&lt;/span&gt;
            &lt;/div&gt;
        &lt;/child&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
    &lt;div class=&quot;child&quot;&gt;
        &lt;h3&gt;这里是子组件&lt;/h3&gt;
        &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>在这个例子里，因为父组件在里面写了html模板，那么子组件的匿名插槽这块模板就是下面这样。也就是说，子组件的匿名插槽被使用了，是被下面这块模板使用了。</p>
<pre><code class="language-html">&lt;div class=&quot;tmpl&quot;&gt;
  &lt;span&gt;菜单1&lt;/span&gt;
  &lt;span&gt;菜单2&lt;/span&gt;
  &lt;span&gt;菜单3&lt;/span&gt;
  &lt;span&gt;菜单4&lt;/span&gt;
  &lt;span&gt;菜单5&lt;/span&gt;
  &lt;span&gt;菜单6&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>最终的渲染结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892088251.png" alt="" loading="lazy"></p>
<h1 id="具名插槽">具名插槽</h1>
<p>匿名插槽没有name属性，所以是匿名插槽，那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置。下面的例子，就是一个有两个<strong>具名插槽</strong>和<strong>单个插槽</strong>的组件，这三个插槽被父组件用同一套css样式显示了出来，不同的是内容上略有区别。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;child&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;up&quot;&gt;
        &lt;span&gt;菜单1&lt;/span&gt;
        &lt;span&gt;菜单2&lt;/span&gt;
        &lt;span&gt;菜单3&lt;/span&gt;
        &lt;span&gt;菜单4&lt;/span&gt;
        &lt;span&gt;菜单5&lt;/span&gt;
        &lt;span&gt;菜单6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot; slot=&quot;down&quot;&gt;
        &lt;span&gt;菜单-1&lt;/span&gt;
        &lt;span&gt;菜单-2&lt;/span&gt;
        &lt;span&gt;菜单-3&lt;/span&gt;
        &lt;span&gt;菜单-4&lt;/span&gt;
        &lt;span&gt;菜单-5&lt;/span&gt;
        &lt;span&gt;菜单-6&lt;/span&gt;
      &lt;/div&gt;
      &lt;div class=&quot;tmpl&quot;&gt;
        &lt;span&gt;菜单-&gt;1&lt;/span&gt;
        &lt;span&gt;菜单-&gt;2&lt;/span&gt;
        &lt;span&gt;菜单-&gt;3&lt;/span&gt;
        &lt;span&gt;菜单-&gt;4&lt;/span&gt;
        &lt;span&gt;菜单-&gt;5&lt;/span&gt;
        &lt;span&gt;菜单-&gt;6&lt;/span&gt;
      &lt;/div&gt;
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;
    // 具名插槽
    &lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 具名插槽
    &lt;slot name=&quot;down&quot;&gt;&lt;/slot&gt;
    // 匿名插槽
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p><img src="https://cutezhangq.github.io/post-images/1596892200490.png" alt="" loading="lazy"><br>
可以看到，父组件通过html模板上的slot属性关联具名插槽。没有slot属性的html模板默认关联匿名插槽。</p>
<h1 id="作用域插槽-带数据的插槽">作用域插槽 | 带数据的插槽</h1>
<p>最后，就是我们的作用域插槽。这个稍微难理解一点。官方叫它作用域插槽，实际上，对比前面两种插槽，我们可以叫它带数据的插槽。什么意思呢，就是前面两种，都是在组件的template里面写</p>
<pre><code class="language-cmd">匿名插槽
&lt;slot&gt;&lt;/slot&gt;
具名插槽
&lt;slot name=&quot;up&quot;&gt;&lt;/slot&gt;
</code></pre>
<p>但是作用域插槽要求，在slot上面绑定数据。也就是你得写成大概下面这个样子。</p>
<pre><code class="language-html">&lt;slot name=&quot;up&quot; :data=&quot;data&quot;&gt;&lt;/slot&gt;
 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    },
}
</code></pre>
<p>我们前面说了，插槽最后显示不显示是看父组件有没有在child下面写模板，像下面那样。</p>
<pre><code class="language-cmd">&lt;child&gt;
   html模板
&lt;/child&gt;
</code></pre>
<p>可以说是子组件暴露的一个让父组件传入自定义内容的接口。<br>
写了，插槽就总得在浏览器上显示点东西，东西就是html该有的模样，没写，插槽就是空壳子，啥都没有。<br>
OK，我们说有html模板的情况，就是父组件会往子组件插模板的情况，那到底插一套什么样的样式呢，这由父组件的html+css共同决定，但是这套样式里面的内容呢？<br>
<code>正因为作用域插槽绑定了一套数据，父组件可以拿来用。</code>于是，情况就变成了这样：<code>样式父组件说了算，但内容可以显示子组件插槽绑定的。</code><br>
我们再来对比，作用域插槽跟单个插槽和具名插槽的区别，因为单个插槽和具名插槽不绑定数据，所以父组件提供的模板一般要既包括样式又包括内容，上面的例子中，你看到的文字，“菜单1”，“菜单2”都是父组件自己提供的内容；而作用域插槽，父组件只需要提供一套样式（在确实用作用域插槽绑定的数据的前提下）。<br>
下面的例子，你就能看到，父组件提供了三种样式(分别是flex、ul、直接显示)，都没有提供数据，数据使用的都是子组件插槽自己绑定的那个数组（一堆人名的那个数组）。<br>
父组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;father&quot;&gt;
    &lt;h3&gt;这里是父组件&lt;/h3&gt;
    &lt;!--第一次使用：用flex展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;div class=&quot;tmpl&quot;&gt;
          &lt;span v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第二次使用：用列表展示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;          &lt;!--通过slot-scope获取子组件的信息--&gt;
        &lt;ul&gt;
          &lt;li v-for=&quot;item in user.data&quot;&gt;{{item}}&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第三次使用：直接显示数据--&gt;
    &lt;child&gt;
      &lt;template slot-scope=&quot;user&quot;&gt;              &lt;!--通过slot-scope获取子组件的信息--&gt;
       {{user.data}}
      &lt;/template&gt;

    &lt;/child&gt;

    &lt;!--第四次使用：不使用其提供的数据, 作用域插槽退变成匿名插槽--&gt;
    &lt;child&gt;
      我就是模板
    &lt;/child&gt;
  &lt;/div&gt;
&lt;/template&gt;

</code></pre>
<p>子组件：</p>
<pre><code class="language-html">&lt;template&gt;
  &lt;div class=&quot;child&quot;&gt;

    &lt;h3&gt;这里是子组件&lt;/h3&gt;
    // 作用域插槽
    &lt;slot  :data=&quot;data&quot;&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

 export default {
    data: function(){
      return {
        data: ['zhangsan','lisi','wanwu','zhaoliu','tianqi','xiaoba']
      }
    }
}
</code></pre>
<p>结果如图所示：<br>
<img src="https://cutezhangq.github.io/post-images/1596892616696.png" alt="" loading="lazy"></p>
<h1 id="slot-scope">slot-scope</h1>
<p><strong>父组件中在使用时：</strong></p>
<ul>
<li>默认插槽的话直接在子组件的标签内写入内容即可</li>
<li>具名插槽是在默认插槽的基础上加上slot属性，值为子组件插槽name属性值</li>
<li>作用域插槽则是通过<code>slot-scope获取子组件的信息</code>，在内容中使用。这里可以用解构语法去直接获取想要的属性</li>
</ul>
<h1 id="v-slot">v-slot</h1>
<pre><code class="language-cmd">在vue2.6中，上述的API被软废弃（3.0正式废弃），取而代之的是内置指令v-slot，可以缩写为【#】
</code></pre>
<p>**子组件用法保持不变，**父组件中</p>
<ul>
<li>slot属性弃用，具名插槽通过指令参数<code>v-slot:插槽名</code>的形式传入，可以简化为 <code>#插槽名。</code></li>
<li><code>slot-scope</code>属性弃用，作用域插槽通过<code>v-slot:xxx=&quot;slotProps&quot;</code>的slotProps来获取子组件传出的属性</li>
<li>v-slot属性只能在 <code>&lt;template&gt;</code>上使用，但在**【只有默认插槽时】**可以在组件标签上使用</li>
</ul>
<pre><code class="language-html">//Parent
&lt;template&gt;
  &lt;child&gt;
   &lt;!--默认插槽--&gt;
   &lt;template v-slot&gt;
     &lt;div&gt;默认插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--具名插槽--&gt;
   &lt;template #header&gt;
     &lt;div&gt;具名插槽&lt;/div&gt;
   &lt;/template&gt;
   &lt;!--作用域插槽--&gt;
   &lt;template #footer=&quot;slotProps&quot;&gt;
     &lt;div&gt;
      {{slotProps.testProps}}
     &lt;/div&gt;
   &lt;/template&gt;
  &lt;child&gt;
&lt;/template&gt;
</code></pre>
<h1 id="拓展用法">拓展用法：</h1>
<ol>
<li>同样可以通过解构获取v-slot={user},<br>
还可以重命名v-slot=&quot;{user: newName}&quot;和定义默认值v-slot=&quot;{user = '默认值'}&quot;</li>
<li>插槽名可以是动态变化的 v-slot:[slotName]</li>
</ol>
<p><strong>注意：</strong></p>
<ol>
<li>默认插槽名为<code>default</code>，可以省略default直接写<code>v-slot</code>，<br>
缩写为#时不能不写参数，写成<code>#default</code>（这点所有指令都一样，v-bind、v-on）</li>
<li>多个插槽混用时，v-slot不能省略default</li>
</ol>
<h1 id="作用域插槽的原理">作用域插槽的原理</h1>
<p>slot本质上是返回VNode的函数，一般情况下，Vue中的组件要渲染到页面上需要经过<br>
<code>template &gt;&gt; render function &gt;&gt; VNode &gt;&gt; DOM</code>过程。 组件挂载的本质就是执行渲染函数得到VNode，至于data/props/computed这些属性都是给VNode提供数据来源。<br>
在2.5之前，如果是普通插槽就<strong>直接是VNode</strong>的形式了，而如果是作用域插槽，由于子组件需要在父组件访问子组件的数据，所以父组件下是一个<strong>未执行的函数</strong><code>(slotScope) =&gt; return h('div', slotScope.msg)</code>，接受子组件的slotProps参数，在子组件渲染实例时会调用该函数传入数据。<br>
在2.6之后，两者合并，普通插槽也变成一个函数，只是不接受参数了。</p>
<h1 id="总结">总结</h1>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596938553804.png" alt="" loading="lazy"></figure>
<h1 id="slot的使用场景">slot的使用场景</h1>
<ul>
<li>布局组件、</li>
<li>表格列、</li>
<li>下拉选项</li>
</ul>
<h1 id="slot-scope的使用场景">slot-scope的使用场景</h1>
<p>想象一个场景：<br>
<strong>当你要给同事封装一个列表组件，你就需要使用作用域插槽（注意是列表或者类似列表的组件）</strong><br>
你开发的这个列表组件要如何使用呢？<br>
一般来说作为列表组件的调用者，你的同事先做ajax请求，拿到一个这样的数组</p>
<pre><code class="language-json">   todos: [
        {
          id: 0,
          text: 'ziwei0',
          isComplete: false
        },
        {
          text: 'ziwei1',
          id: 1,
          isComplete: true
        },
        {
          text: 'ziwei2',
          id: 2,
          isComplete: false
        },
        {
          text: 'ziwei3',
          id: 3,
          isComplete: false
        }
      ]
</code></pre>
<p>之后会把todso传递给列表组件吧，那么列表组件内部做什么事情呢？<br>
列表内部肯定会v-for去帮你的同事渲染这个数组嘛。 就类似element-ui里的table组件一样<br>
问题的关键就在这里<br>
<strong>列表组件的循环，是发生在组件内部的，所以通过 v-for=&quot;todo in todos&quot; ,列表组件很容易拿到一项todo，但列表拿到数据没用呀，列表只是一个瓜皮，它又不懂业务逻辑这个数据是你同事的业务数据，</strong><br>
<strong>所以这个数据必须得交给组件的调用者，也就是把数据交给你的同事才对。</strong></p>
<p>那么你怎样才能把每一项的todo数据给传递出去呢？<br>
你会发现没有办法！</p>
<p>无论是用$emit、vuex还是localStorage，可以考虑一下，会发现没有合适的时机，能让你把todo传递出去</p>
<p>所以为了应对这个场景下，发明了<code>作用域插槽</code>，列表组件可以通过<code>&lt;slot :todo=&quot;todo&quot;&gt;&lt;/slot&gt;</code>传递todo出去<br>
你的同事可以通过 slot-scope=&quot;slotsProps&quot;<code>拿到todo</code>。<br>
回答几个疑问，其实如果你看懂上面的问题，应该可以回答下面的问题。这也是我曾经的疑问</p>
<ul>
<li>疑问1：一般不是我们传参数来调用组件吗？为什么组件还把数据传递回来？</li>
</ul>
<pre><code class="language-cmd">的确，调用ui组件时一般是我们传递配置参数给他们。

但是就像elemnt-ui的table组件，你把数组传递给table后，是不是有时候需要拿到某一行的row对象

并根据row对象里的字段，来判断一些内容的显示隐藏？

因为循环的过程发生在table组件内部，所以table组件可以方便的获取到每一项数据，但是这些数据最终不是给组件的，而是我们自己要用的业务数据。所以也需要一个方式，让调用者能拿到自己想要的数据
</code></pre>
<ul>
<li>疑问2： 既然子组件最终还要把我给他的数据，再返还给我，那我当初还干嘛给它，能不能就自己在父组件里玩？</li>
</ul>
<pre><code class="language-cmd">如果你不把数据给子组件当然可以。但是就等于抛弃掉了子组件的封装，只能你直接在父组件自己写一个列表

毕竟你不把数据给子组件，子组件还渲染个锤子？没有父子关系的话，也就不用什么插槽了。

但是咱不是为了封装后，可以复用嘛，总不能永远不用组件嘛
</code></pre>
<ul>
<li>疑问3： 父组件需要子组件的数据？那不会有$emit和vuex嘛，为什么要有slot-scope？</li>
</ul>
<pre><code class="language-cmd">$emit和vuex是数据传递的一种方法，但是你可以尝试用$emit和vuex把todo传递给父组件。

你会发现的确没有合适的钩子、时机来$emit数据
</code></pre>
<h1 id="26新增用法">2.6新增用法</h1>
<h2 id="动态插槽名260新增">动态插槽名(2.6.0新增)</h2>
<p>动态指令参数(需要自己了解)也可以用在v-slot上，来定义动态的插槽名：</p>
<pre><code class="language-html">&lt;base-layout&gt;
  &lt;template v-slot:[dynamicSlotName]&gt;
    ...
  &lt;/template&gt;
&lt;/base-layout&gt;
</code></pre>
<h2 id="具名插槽的缩写260新增">具名插槽的缩写(2.6.0新增)</h2>
<p>跟 v-on 和 v-bind 一样，v-slot 也有缩写，即把参数之前的所有内容 (v-slot:) 替换为字符 #。例如 v-slot:header 可以被重写为 #header：<br>
原来是这样写的：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template v-slot:header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template v-slot:footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;  
</code></pre>
<p>现在可以这样写：</p>
<pre><code class="language-html">&lt;div&gt;
   &lt;template #header&gt;
    &lt;h1&gt;Here might be a page title&lt;/h1&gt;
   &lt;/template&gt;

  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;
  &lt;p&gt;And another one.&lt;/p&gt;

  &lt;template #footer&gt;
    &lt;p&gt;Here some contact info&lt;/p&gt;
  &lt;/template&gt;
&lt;/div&gt;
</code></pre>
<p>如果希望使用缩写的话，必须始终以明确插槽名取而代之：</p>
<pre><code class="language-html">&lt;test #default=&quot;{ usertext }&quot;&gt;
  {{ usertext.firstName }}
&lt;/test&gt;
</code></pre>
<h1 id="其他示例">其他示例</h1>
<p>插槽 prop 允许我们将插槽转换为<code>可复用</code>的模板，这些模板可以基于输入的 <code>prop</code>渲染出不同的内容。 这在设计封装数据逻辑同时允许父级组件自定义部分布局的可复用组件时是最有用的。<br>
例如，我们要实现一个 <code>&lt;todo-list&gt;</code>组件，它是一个列表且包含布局和过滤逻辑：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    {{ todo.text }}
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>我们可以将每个<code>todo</code>作为父级组件的插槽，以此通过父级组件对其进行控制，然后将<code>todo</code> 作为一个插槽<code>prop</code>进行绑定：</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li
    v-for=&quot;todo in filteredTodos&quot;
    v-bind:key=&quot;todo.id&quot;
  &gt;
    &lt;!--
    我们为每个 todo 准备了一个插槽，
    将 `todo` 对象作为一个插槽的 prop 传入。
    --&gt;
    &lt;slot name=&quot;todo&quot; v-bind:todo=&quot;todo&quot;&gt;
      &lt;!-- 后备内容 --&gt;
      {{ todo.text }}
    &lt;/slot&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>现在当我们使用 <code>&lt;todo-list&gt;</code>组件的时候，我们可以选择为 todo 定义一个不一样的 <code>&lt;template&gt;</code>作为替代方案，并且可以从子组件获取数据：</p>
<pre><code class="language-html">&lt;todo-list v-bind:todos=&quot;todos&quot;&gt;
  &lt;template v-slot:todo=&quot;{ todo }&quot;&gt;
    &lt;span v-if=&quot;todo.isComplete&quot;&gt;✓&lt;/span&gt;
    {{ todo.text }}
  &lt;/template&gt;
&lt;/todo-list&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ 消息订阅与发布]]></title>
        <id>https://cutezhangq.github.io/post/xiao-xi-ding-yue-yu-fa-bu/</id>
        <link href="https://cutezhangq.github.io/post/xiao-xi-ding-yue-yu-fa-bu/">
        </link>
        <updated>2020-08-07T03:04:04.000Z</updated>
        <summary type="html"><![CDATA[<p>结合 Vue 源码谈谈发布-订阅模式🤞，并涉及几个核心对象如 Observer 等。看看他们在vue实例中的应用~👀</p>
]]></summary>
        <content type="html"><![CDATA[<p>结合 Vue 源码谈谈发布-订阅模式🤞，并涉及几个核心对象如 Observer 等。看看他们在vue实例中的应用~👀</p>
<!-- more -->
<h1 id="发布订阅模式主要包含哪些内容呢">发布订阅模式主要包含哪些内容呢?</h1>
<ul>
<li>发布函数，发布的时候执行相应的回调</li>
<li>订阅函数，添加订阅者,传入发布时要执行的函数,可能会携额外参数</li>
<li>一个缓存订阅者以及订阅者的回调函数的列表</li>
<li>取消订阅(需要分情况讨论)</li>
</ul>
<p>这么看下来,其实就像 JavaScript 中的事件模型,我们在DOM节点上绑定事件函数,触发的时候执行就是应用了发布-订阅模式.</p>
<h1 id="我们先按照上面的内容自己实现一个-observer-对象如下">我们先按照上面的内容自己实现一个 Observer 对象如下:</h1>
<pre><code class="language-js">//用于存储订阅的事件名称以及回调函数列表的键值对
function Observer() {
    this.cache = {}  
}

//key:订阅消息的类型的标识（名称），fn收到消息之后执行的回调函数
Observer.prototype.on = function (key,fn) {
    if(!this.cache[key]){
        this.cache[key]=[]
    }
    this.cache[key].push(fn)
}


//arguments 是发布消息时候携带的参数数组
Observer.prototype.emit = function (key) {
    if(this.cache[key]&amp;&amp;this.cache[key].length&gt;0){
        var fns = this.cache[key]
    }
    for(let i=0;i&lt;fns.length;i++){
        Array.prototype.shift.call(arguments)
        fns[i].apply(this,arguments)
    }
}
// remove 的时候需要注意，如果你直接传入一个匿名函数fn，那么你在remove的时候是无法找到这个函数并且把它移除的，变通方式是传入一个
//指向该函数的指针，而 订阅的时候存入的也是这个指针
Observer.prototype.remove = function (key,fn) {
    let fns = this.cache[key]
    if(!fns||fns.length===0){
        return
    }
    //如果没有传入fn，那么就是取消所有该事件的订阅
    if(!fn){
        fns=[]
    }else {
        fns.forEach((item,index)=&gt;{
            if(item===fn){
                fns.splice(index,1)
            }
        })
    }
}


//example


var obj = new Observer()
obj.on('hello',function (a,b) {
    console.log(a,b)
})
obj.emit('hello',1,2)
//取消订阅事件的回调必须是具名函数
obj.on('test',fn1 =function () {
    console.log('fn1')
})
obj.on('test',fn2 = function () {
    console.log('fn2')
})
obj.remove('test',fn1)
obj.emit('test')
</code></pre>
<p>为什么会使用发布订阅模式呢? 它的优点在于:</p>
<ul>
<li>实现<strong>时间上的解耦</strong>(组件,模块之间的异步通讯)</li>
<li><strong>对象之间的解耦</strong>,交由发布订阅的对象管理对象之间的耦合关系.</li>
</ul>
<h1 id="发布-订阅模式在-vue中的应用">发布-订阅模式在 Vue中的应用</h1>
<p>发布-订阅模式又叫<code>观察者模式</code>,它定义对象间的一种<code>一对多</code>的依赖关系,当一个对象的状态发生改变时,所有依赖于它的对象都将得到通知。JavaScript开发中我们一般用事件模型来代替传统的发布-订阅模式</p>
<h1 id="案例介绍1">案例介绍1</h1>
<p>卖烧饼的店主可以把小明、小龙的电话记录下来,等店里有烧饼了在通知小龙小明来拿这就是所谓的发布-订阅模式，代码如下：</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:[],//缓存列表
    addlisten:function(fn){//增加订阅者
        this.clienlist.push(fn);
    },
    trigger:function(){//发布消息
        for(var i=0,fn;fn=this.clienlist[i++];){
            fn.apply(this,arguments);
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(10,&quot;椒盐&quot;);
</code></pre>
<p>从代码中可以看出，只有小明，小龙预定了烧饼，烧饼店就可以发布消息告诉小龙与小明。但是有个问题不知道大家发现了没有。小明只喜欢椒盐味道的。而小龙只喜欢焦糖味道的。上面的代码就满足不了客户的需求，给客户一种感觉就是，不管我喜欢不喜欢，你都会发给我。如果发布比较多，客户就会感到厌烦，甚至会想删除订阅。下边是对代码进行改良大家可以看看。</p>
<pre><code class="language-js">/*烧饼店*/        
var Sesamecakeshop={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    },
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove:function(key,fn){
        var fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    }
}

/*小明发布订阅*/
Sesamecakeshop.addlisten(&quot;焦糖&quot;,fn1=function(price,taste){
    console.log(&quot;小明发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten(&quot;椒盐&quot;,function(price,taste){
    console.log(&quot;小龙发布的&quot;+price+&quot;元，&quot;+taste+&quot;味道的&quot;);
});        

Sesamecakeshop.trigger(&quot;椒盐&quot;,10,&quot;椒盐&quot;);

Sesamecakeshop.remove(&quot;焦糖&quot;,fn1);//注意这里是按照地址引用的。如果传入匿名函数则删除不了        

Sesamecakeshop.trigger(&quot;焦糖&quot;,40,&quot;焦糖&quot;);

</code></pre>
<p>删除的时候需要注意的是，如果订阅的时候传递的是匿名函数，删除的时候如果传入的也是匿名函数。则删除不了。因为删除时候是按照地址引用删除的。传进去的两个匿名函数，对应的地址引用是不同的。</p>
<h1 id="案例介绍2">案例介绍2</h1>
<p>比如咱们常见的用户身份分别有不同的功能，超级管理员拥有最高权限，可以删除修改任意用户。而普通用户则只能修改自己的账户信息。首先是用户身份验证，验证通过之后对应功能才可以显示。</p>
<pre><code class="language-js">//登录发布-订阅模式
login={
    clienlist:{},/*缓存列表*/
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten:function(key,fn){
        if(!this.clienlist[key]){
            this.clienlist[key]=[];
        }
        this.clienlist[key].push(fn);
    },
    /**
     * 发布消息
     * */
    trigger:function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=this.clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    }
}
//超级管理员修改所有用户
var editall=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editall.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;超级管理员修改所有用户&quot;);
        }
    }
})();

//仅仅修改自己
var editOwn=(function(){
    login.addlisten(&quot;loginsucc&quot;,function(data){
        editOwn.setview(data);
    });
    return{
        setview:function(data){
            console.log(data);
            console.log(&quot;仅仅修改自己&quot;);
        }
    }
})();
</code></pre>
<p>发布-订阅模式简单封装</p>
<pre><code class="language-js">var _Event=(function(){
    var clienlist={},
    addlisten,trigger,remove;
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten=function(key,fn){
        if(!clienlist[key]){
            clienlist[key]=[];
        }
        clienlist[key].push(fn);
    };
    /**
     * 发布消息
     * */
    trigger=function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    };
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove=function(key,fn){
        var fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns &amp;&amp; (fns.length=0);
        }else{
            for(var l=fns.length-1;l&gt;=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    };
    return{
        addlisten:addlisten,
        trigger:trigger,
        remove:remove
    }
})();


_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
});
_Event.addlisten(&quot;jianbing&quot;,function(d,all){
    console.log(&quot;发布的消息来自：&quot;+d+&quot;，具体信息：&quot;+all);
})
_Event.trigger(&quot;yyyy&quot;,&quot;xxx&quot;,&quot;前端工程师&quot;)
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1596872061540.png" alt="" loading="lazy"></figure>
<h1 id="总结">总结</h1>
<p>发布-订阅模式就是常说的观察者模式，在实际开发中非常有用。它的优点是为时间是解耦，为对象之间解构，它的应用非常广泛，既可以在异步编程中也可以帮助我们完成更松的解耦。发布-订阅模式还可以帮助我们实现设计模式，从架构上来看，无论MVC还是MVVC都少不了发布-订阅模式的参与。然而发布-订阅模式也存在一些缺点，创建订阅本身会消耗一定的时间与内存，也许当你订阅一个消息之后，之后可能就不会发生。发布-订阅模式虽然它弱化了对象与对象之间的关系，但是如果过度使用，对象与对象的必要联系就会被深埋，会导致程序难以跟踪与维护。</p>
<!-- more -->
<h1 id="订阅发布模式和观察者模式的区别">订阅发布模式和观察者模式的区别</h1>
<p><strong>发布订阅模式属于广义上的观察者模式</strong><br>
发布订阅模式是最常用的一种观察者模式的实现，并且从解耦和重用角度来看，更优于典型的观察者模式</p>
<p><strong>发布订阅模式多了个事件通道</strong><br>
在观察者模式中，观察者需要直接订阅目标事件；在目标发出内容改变的事件后，直接接收事件并作出响应<br>
<img src="https://cutezhangq.github.io/post-images/1596877097254.png" alt="" loading="lazy"></p>
<p>在发布订阅模式中，发布者和订阅者之间多了一个发布通道；一方面从发布者接收事件，另一方面向订阅者发布事件；订阅者需要从事件通道订阅事件<br>
以此避免发布者和订阅者之间产生依赖关系<br>
<img src="https://cutezhangq.github.io/post-images/1596877130031.png" alt="" loading="lazy"></p>
<p>总结起来就是，一个是紧密耦合，一个是松散耦合。优缺点也很明显，紧密耦合的方式简单直接，扩展性差，而且要求两端同时存在。松散耦合不直接产生依赖，更容易扩展，懒加载的时候会有优势，但稍显复杂。</p>
<h2 id="从代码看区别">从代码看区别</h2>
<p>需求：数据打包下载功能</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[双向数据绑定、单向数据流]]></title>
        <id>https://cutezhangq.github.io/post/shuang-xiang-shu-ju-bang-ding-dan-xiang-shu-ju-liu/</id>
        <link href="https://cutezhangq.github.io/post/shuang-xiang-shu-ju-bang-ding-dan-xiang-shu-ju-liu/">
        </link>
        <updated>2020-08-07T01:30:09.000Z</updated>
        <summary type="html"><![CDATA[<p>单向数据流和双向数据绑定各有优缺点，一起来看看吧~🙆</p>
]]></summary>
        <content type="html"><![CDATA[<p>单向数据流和双向数据绑定各有优缺点，一起来看看吧~🙆</p>
<!-- more -->
<h1 id="单向数据流和双向数据绑定有什么优缺点单向数据流优缺点">单向数据流和双向数据绑定有什么优缺点？单向数据流优缺点</h1>
<p><strong>优点：</strong><br>
所有状态的改变可记录、可跟踪，源头易追溯;<br>
所有数据只有一份，组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性;<br>
一旦数据变化，就去更新页面(data-页面)，但是没有(页面-data);<br>
如果用户在页面上做了变动，那么就手动收集起来(双向是自动)，合并到原有的数据中。</p>
<p><strong>缺点：</strong><br>
HTML 代码渲染完成，无法改变，有新数据，就须把旧 HTML 代码去掉，整合新数据和模板重新渲染;<br>
代码量上升，数据流转过程变长，出现很多类似的样板代码;<br>
同时由于对应用状态独立管理的严格要求(单一的全局 store)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用)，会显得啰嗦及繁琐。</p>
<h1 id="双向数据绑定的优缺点">双向数据绑定的优缺点：</h1>
<p><strong>优点：</strong><br>
用户在视图上的修改会自动同步到数据模型中去，数据模型中值的变化也会立刻同步到视图中去；<br>
无需进行和单向数据绑定的那些相关操作；<br>
在表单交互较多的场景下，会简化大量业务无关的代码。<br>
<strong>缺点：</strong><br>
无法追踪局部状态的变化；<br>
“暗箱操作”，增加了出错时 debug 的难度；<br>
由于组件数据变化来源入口变得可能不止一个，数据流转方向易紊乱，若再缺乏“管制”手段，崩溃。</p>
<p>这样来看，单向绑定跟双向绑定在功能上基本上是互补的，所以我们可以在合适的场景下使用合适的手段。比如在 UI 控件 中(通常是类表单操作)，我会使用双向的方式绑定数据；而其他场景则统一采用 单向 + inline event ( &lt;component :msg=“msg” @update=“updateMsg(msg)”&gt; ) 的方式构建应用。<br>
<img src="https://cutezhangq.github.io/post-images/1596891716608.png" alt="" loading="lazy"></p>
<h1 id="单向数据流">单向数据流：</h1>
<p>如：<strong>props</strong><br>
数据从父级组件传递给子组件，只能单向绑定。<br>
子组件内部不能直接修改从父级传递过来的数据。<br>
其中，props的用法：<br>
props 是<strong>单向绑定</strong>的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改父组件的状态。<br>
所以<code>不应该在子组件中修改 props 中的值，Vue 会报出警告</code>。</p>
<h2 id="修改-props-数据">修改 props 数据</h2>
<p>通常有两种原因：</p>
<ul>
<li>prop 作为初始值传入后，子组件想把它当做局部数据来用</li>
<li>prop 作为初始值传入后，由子组件处理成其他数据输出</li>
</ul>
<h2 id="应对办法是">应对办法是</h2>
<ul>
<li>定义一个<code>局部变量</code>，并用 prop 的值初始化它<br>
但是由于定义的 ownChildMsg 只能接受 forChildMsg <code>的初始值</code>，当父组件要传递的值变化发生时，ownChildMsg <code>无法收到更新</code>。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return { ownChildMsg: this.forChildMsg };
  }
};
</code></pre>
<p>这里我们加了一个<p>用于查看 ownChildMsg 数据是否变化，结果发现只有默认值传递给了 ownChildMsg，父组件改变只会变化到 forChildMsg，不会修改 ownChildMsg。</p>
<ul>
<li>定义一个<code>计算属性</code>，处理 prop 的值并返回<br>
由于是计算属性，所以只能显示值，不能设置值。我们这里设置的是一旦从父组件修改了 forChildMsg 数据，我们就把 forChildMsg 加上一个字符串&quot;---ownChildMsg&quot;，然后显示在屏幕上。这时是可以每当父组件修改了新数据，<code>都会更新</code> ownChildMsg 数据的。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  computed: {
    ownChildMsg() {
      return this.forChildMsg + &quot;---ownChildMsg&quot;;
    }
  }
};
</code></pre>
<ul>
<li>更加妥帖的方式是<code>使用变量存储</code> prop 的初始值，并用<code>watch</code>来观察 prop 值得<code>变化</code>。发生变化时，更新变量的值。</li>
</ul>
<pre><code class="language-js">let childNode = {
  template: `
          &lt;div class=&quot;child&quot;&gt;
            &lt;div&gt;
              &lt;span&gt;子组件数据&lt;/span&gt;
              &lt;input v-model=&quot;forChildMsg&quot;/&gt;
            &lt;/div&gt;
            &lt;p&gt;{{forChildMsg}}&lt;/p&gt;
            &lt;p&gt;ownChildMsg : {{ownChildMsg}}&lt;/p&gt;
          &lt;/div&gt;`,
  props: {
    &quot;for-child-msg&quot;: String
  },
  data() {
    return {
      ownChildMsg: this.forChildMsg
    };
  },
  watch: {
    forChildMsg() {
      this.ownChildMsg = this.forChildMsg;
    }
  }
};
</code></pre>
]]></content>
    </entry>
</feed>