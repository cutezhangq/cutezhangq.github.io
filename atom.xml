<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cutezhangq.github.io</id>
    <title>cutezhangq</title>
    <updated>2020-06-16T07:20:24.673Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cutezhangq.github.io"/>
    <link rel="self" href="https://cutezhangq.github.io/atom.xml"/>
    <subtitle>温故知新</subtitle>
    <logo>https://cutezhangq.github.io/images/avatar.png</logo>
    <icon>https://cutezhangq.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, cutezhangq</rights>
    <entry>
        <title type="html"><![CDATA[vue知识点理解]]></title>
        <id>https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/</id>
        <link href="https://cutezhangq.github.io/post/vue-zhi-shi-dian-li-jie/">
        </link>
        <updated>2020-05-13T08:07:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="模板字符串的前世今生">模板字符串的前世今生</h1>
<h2 id="js">JS</h2>
<p>js中，输出模板是这样写的。通过<code>字符串</code>拼接</p>
<pre><code class="language-js">$('#result').append(
 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' +
 'items in your basket, ' +
 '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'
);
</code></pre>
<h2 id="es6">es6</h2>
<p>es6中，输出模板是这样写的。通过<code>${ }嵌入变量</code></p>
<pre><code class="language-js">$('#result').append(`
    There are &lt;b&gt;${basket.count}&lt;/b&gt; items
    in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
    are on sale!
`);
</code></pre>
<h2 id="vue">Vue</h2>
<p>Vue中，输出模板是这样写的。</p>
<pre><code class="language-js">new Vue({
     el:'#replace',
    template:'&lt;p&gt;字符串模板&lt;/p&gt;'
})
</code></pre>
<h2 id="vue20模板的三种写法">Vue2.0模板的三种写法</h2>
<h3 id="第一种利用模板字符串">第一种：利用模板字符串</h3>
<pre><code class="language-js">&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
        el:&quot;#app&quot;,
        data:{ },
        template:`&lt;h1 style=&quot;color:red&quot;&gt;第一种写法&lt;/h1&gt;`
    })
&lt;/script&gt;
</code></pre>
<h3 id="第二种利用template标签实现内容填充通过-id-或者其他的选择器挂载到template上">第二种：利用template标签实现内容填充,通过 id 或者其他的选择器挂载到template上</h3>
<p>通过 id,挂载到template上</p>
<pre><code class="language-js">&lt;template id=&quot;template&quot;&gt;
    &lt;h1&gt;11&lt;/h1&gt;
&lt;/template&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var app=new Vue({
    ...
    template:&quot;#template&quot;
})
&lt;/script&gt;
</code></pre>
<h3 id="改变script中的type变为typex-template给它id最终挂载到template中">改变script中的type.变为type=&quot;x-template&quot;,给它id,最终挂载到template中</h3>
<p>使用于内容比较多或有公共的模板,可以使用,引入就可以<br>
type=&quot;x-template&quot;，给它id</p>
<pre><code class="language-js">&lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;x-template&quot; id=&quot;template&quot;&gt;
    &lt;h2&gt;11&lt;/h2&gt;
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
var app=new Vue({
     ...
    template:&quot;#template&quot;
})
</code></pre>
<h2 id="vue30模板的写法">Vue3.0模板的写法</h2>
<pre><code class="language-js">import Vue from 'vue'
import App from './App.vue'
new Vue({
   ...
    render: h =&gt; h(App)
}).$mount('#app')
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vue]]></title>
        <id>https://cutezhangq.github.io/post/vue/</id>
        <link href="https://cutezhangq.github.io/post/vue/">
        </link>
        <updated>2020-05-13T07:55:37.000Z</updated>
        <content type="html"><![CDATA[<h1 id="注意点">注意点</h1>
<h2 id="路由动画">路由动画</h2>
<p>💥出现问题：动画滑动时，最上面的header元素没有置顶，导致最后动画完成时突然向上移动。<br>
✔️解决：</p>
<pre><code class="language-html">&lt;transition :name=&quot;transitionName&quot;&gt;
    &lt;router-view :Event_Play=&quot;Event_Play&quot; class=&quot;transitionBody&quot;&gt;&lt;router-view&gt;
&lt;/transition&gt;
&lt;style lang=&quot;less&quot;&gt;
.transitionBody {
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
 }
 &lt;/style&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面试100问]]></title>
        <id>https://cutezhangq.github.io/post/interview-question/</id>
        <link href="https://cutezhangq.github.io/post/interview-question/">
        </link>
        <updated>2020-04-01T01:22:20.000Z</updated>
        <content type="html"><![CDATA[<h1 id="第-1-题滴滴-饿了么写-react-vue-项目时为什么要在列表组件中写-key其作用是什么">第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h1>
<p>😅emm..对这个问题有过疑问，但是一直没有探寻原因，现在梳理一下</p>
<h2 id="答案"><strong>答案</strong></h2>
<p>首先在vue循环遍历生成节点中会使用到key，那么到底要不要使用key，参考官网上的描述：<br>
📃VUE文档:</p>
<ul>
<li>建议尽可能在使用 v-for 时提供 key attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。</li>
</ul>
<p>得出结论，多数情况最好使用key!</p>
<pre><code class="language-html">&lt;div id=&quot;app&quot;&gt;
    &lt;div v-for=&quot;i in dataList&quot; :key=&quot;i&quot;&gt;{{ i }}&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>key是用来<code>绑定</code>虚拟节点的，给每一个vnode<code>唯一</code>id。<br>
当不使用key的时候，也可以通过v-for实现以下的dom节点数组<br>
🌰 案例：</p>
<pre><code class="language-js">var vm = new Vue({
  el: '#app',
  data: {
    dataList: [1, 2, 3, 4, 5]
  }
})
</code></pre>
<p>为了方便，标记上id加以说明节点。当数组为[1, 2, 3, 4, 5]时，加key与不加key都如下：</p>
<pre><code class="language-html"> [
    '&lt;div&gt;1&lt;/div&gt;',     // id:  A
    '&lt;div&gt;2&lt;/div&gt;',     // id:  B
    '&lt;div&gt;3&lt;/div&gt;',     // id:  C
    '&lt;div&gt;4&lt;/div&gt;',     // id:  D
    '&lt;div&gt;5&lt;/div&gt;'      // id:  E
  ]
</code></pre>
<p>但是，当数组有变化时，两者就有区别了。<br>
改变dataList数据，进行数据位置替换，对比改变后的数据如下：</p>
<pre><code class="language-js"> vm.dataList = [4, 1, 3, 5, 2] // 数据位置替换
 // 没有key的情况， 节点位置不变，但是节点innerText内容更新了
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： A
    '&lt;div&gt;1&lt;/div&gt;', // id:  B
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  D
    '&lt;div&gt;2&lt;/div&gt;'  // id:  E
  ]

  // 有key的情况，dom节点位置进行了交换，但是内容没有更新
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;4&lt;/div&gt;', // id： D
    '&lt;div&gt;1&lt;/div&gt;', // id:  A
    '&lt;div&gt;3&lt;/div&gt;', // id:  C
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;2&lt;/div&gt;'  // id:  B
  ]
</code></pre>
<p>原因：<code>没有绑定key的情况下，节点会进行复用</code>，即呈现出id没变，内容变化了（<code>就地更新</code>），这样<code>有利于diff速度</code>，但是这种模式会带来一些隐藏的副作用。可能不会产生过渡的效果，某些节点绑定数据（表单）状态时，会出现状态错位。没办法追踪到每个节点。<br>
使用key可以：</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<pre><code class="language-html">&lt;transition&gt;
  &lt;span :key=&quot;text&quot;&gt;{{ text }}&lt;/span&gt;
&lt;/transition&gt;
</code></pre>
<p>当 text 发生改变时，span总是会被替换而不是被修改，因此会触发过渡。</p>
<p>📃VUE文档也说明了</p>
<ul>
<li>不加key时，<a href="https://cn.vuejs.org/v2/guide/list.html#%E7%BB%B4%E6%8A%A4%E7%8A%B6%E6%80%81">这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</a></li>
</ul>
<p>增删dataList列表项，对比改变后的数据如下：</p>
<pre><code class="language-html">vm.dataList = [3, 4, 5, 6, 7] // 数据进行增删
  // 1. 没有key的情况， 节点位置不变，内容也更新了
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： A
    '&lt;div&gt;4&lt;/div&gt;', // id:  B
    '&lt;div&gt;5&lt;/div&gt;', // id:  C
    '&lt;div&gt;6&lt;/div&gt;', // id:  D
    '&lt;div&gt;7&lt;/div&gt;'  // id:  E
  ]

  // 2. 有key的情况， 节点删除了 A, B 节点，新增了 F, G 节点
  // &lt;div v-for=&quot;i in dataList&quot; :key='i'&gt;{{ i }}&lt;/div&gt;
  [
    '&lt;div&gt;3&lt;/div&gt;', // id： C
    '&lt;div&gt;4&lt;/div&gt;', // id:  D
    '&lt;div&gt;5&lt;/div&gt;', // id:  E
    '&lt;div&gt;6&lt;/div&gt;', // id:  F
    '&lt;div&gt;7&lt;/div&gt;'  // id:  G
  ]
</code></pre>
<p>key是给每一个vnode的唯一id,可以依靠key,<code>更准确</code>, <code>更快</code>的拿到oldVnode中对应的vnode节点。<br>
更快 体现在：利用key的唯一性生成map对象来获取对应节点，比遍历方式更快。(这个观点，就是我最初的那个观点。从这个角度看，map会比遍历更快。</p>
<h2 id="扩展"><strong>扩展</strong>：</h2>
<h3 id="diff算法">diff算法</h3>
<h3 id="vue源码">vue源码</h3>
<h1 id="第-2-题1-2-3mapparseint-what-why">第 2 题：['1', '2', '3'].map(parseInt) what &amp; why ?</h1>
<p>emm..map是es6中涉及到的方法，是指不重复的Key-value形式的数据，parseInt是....返回整数的，然并卵...orz🤒</p>
<h2 id="答案-2"><strong>答案</strong></h2>
<p>真正的答案是[1, NaN, NaN]<br>
这题的主要考察，还是arr.map（）方法，和parseInt，对它们一定要深入理解。下面附上MDN官方解释：<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">Array.prototype.map()</a></li>
</ul>
<pre><code class="language-js">    var new_array = arr.map(function callback(currentValue[, index[, array]]) {     }[, thisArg])
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585987454821.png" alt="" width="400" height="300" loading="lazy"></figure>
<h3 id="map方法定义">map方法定义</h3>
<p>将数组中的值按顺序调用callback函数，然后由callback返回的数按顺序组成新数组；没有赋值或删除掉的索引不会调用。</p>
<h3 id="map方法使用">map方法使用</h3>
<p>map方法针对<code>新数组</code>的，<code>不会修改原数组</code>，若是对原数组进行操作则使用for-of或forEach。<br>
callback 函数会被自动传入三个参数：<code>数组元素</code>，<code>元素索引</code>，<code>原数组本身</code>。</p>
<p>🙄其实这里主要难度是parseInt，下面一起来研究下叭~<br>
📃MDN：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">parseInt</a></li>
</ul>
<pre><code class="language-js">parseInt(string, radix);
</code></pre>
<p>将一个字符串 string 转换为 radix 进制的整数， radix 为介于2-36之间的数。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git]]></title>
        <id>https://cutezhangq.github.io/post/git/</id>
        <link href="https://cutezhangq.github.io/post/git/">
        </link>
        <updated>2020-03-22T06:51:14.000Z</updated>
        <content type="html"><![CDATA[<h1 id="定义">定义</h1>
<p>是一个分布式版本控制工具（系统）。</p>
<h1 id="git特点">Git特点</h1>
<p>1.尽可能添加数据而不是删除或修改数据，存储能力强，容易备份</p>
<p>2.完整性保证（对于每次提交做Hash的操作）</p>
<p>3.与linux命令全面兼容</p>
<p>4.良好性能，支持离线（在本地完成）</p>
<p>5.制定工作流</p>
<p>6.分布式仓库</p>
<h1 id="git官网">Git官网</h1>
<p><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<h1 id="git三种状态三个逻辑区域">Git三种状态,三个逻辑区域</h1>
<h2 id="三种状态">三种状态</h2>
<ul>
<li>
<p>modified(已修改)</p>
</li>
<li>
<p>staged(已暂存)</p>
</li>
<li>
<p>committed(已提交)</p>
</li>
</ul>
<h2 id="三种分区">三种分区</h2>
<p>git分为：<code>工作区</code>，<code>暂存区</code>，<code>本地库</code>，<code>远程区</code>  四块大区域</p>
<h2 id="对应关系">对应关系</h2>
<figure data-type="image" tabindex="1"><img src="https://cutezhangq.github.io/post-images/1585704345724.jpg" alt="" loading="lazy"></figure>
<h1 id="git文件内容结构">.Git文件内容结构</h1>
<figure data-type="image" tabindex="2"><img src="https://cutezhangq.github.io/post-images/1585704336057.png" alt="" loading="lazy"></figure>
<h1 id="git命令">Git命令</h1>
<h2 id="搭建git仓库">搭建Git仓库</h2>
<h3 id="两种场景">两种场景：</h3>
<p>使用<code>init</code>初始化，将本地的目录变成git<code>本地仓库</code></p>
<ul>
<li>1.已有项目，将项目纳入Git管理</li>
</ul>
<pre><code class="language-cmd">cd 项目所在文件夹
git init
</code></pre>
<ul>
<li>2.没有项目，新建用Git管理的项目</li>
</ul>
<pre><code class="language-cmd">cd 项目所在文件夹
git init your_project   #会在当前路径下创建和项目名称同名的文件夹
</code></pre>
<h3 id="查看本地目录的状态">查看本地目录的状态</h3>
<pre><code class="language-cmd">git status
</code></pre>
<h3 id="本地仓库与远程仓库关联">本地仓库与远程仓库关联</h3>
<p>与<code>远程仓库</code>关联，（此前已在码云等上注册远程仓库）</p>
<pre><code class="language-cmd">git add origin 远程仓库地址
</code></pre>
<hr>
<h2 id="更新项目">更新项目</h2>
<p>准备上传你的项目之前，最好更新一下项目，确保没有和远程仓库的代码有<code>冲突</code></p>
<pre><code class="language-cmd">git pull --rebase origin master
</code></pre>
<hr>
<h2 id="提交项目">提交项目</h2>
<pre><code class="language-cmd">git add .           #添加目录下所有发生改变的文件
git commit -m           #'注释信息'
git push -u origin master       #本地仓库代码提交至远程仓库(有时候会提交失败，可以尝试git push -u origin master -f 强制提交,只建议在第一次提交中使用)
</code></pre>
<hr>
<h2 id="克隆项目">克隆项目</h2>
<pre><code class="language-cmd">git clone 远程仓库地址
</code></pre>
<hr>
<h2 id="分支相关命令">分支相关命令</h2>
<ul>
<li>查看所有分支</li>
</ul>
<pre><code class="language-cmd">git branch  -a
</code></pre>
<ul>
<li>创建分支</li>
</ul>
<pre><code class="language-cmd">git branch 分支名
</code></pre>
<ul>
<li>切换到某一分支</li>
</ul>
<pre><code class="language-cmd">git checkout  分支名
</code></pre>
<ul>
<li><code>合并分支</code></li>
</ul>
<pre><code class="language-cmd">git merge 分支名
</code></pre>
<ul>
<li><code>创建远程的分支,并且把本地分支推送到远程分支上</code></li>
</ul>
<pre><code class="language-cmd">git push origin 分支名
</code></pre>
<ul>
<li>删除本地分支</li>
</ul>
<pre><code class="language-cmd">git branch -d 分支名
</code></pre>
<ul>
<li>查看本地分支状态</li>
</ul>
<pre><code class="language-cmd">git branch
</code></pre>
<ul>
<li>删除远程分支</li>
</ul>
<pre><code class="language-cmd">git push origin --delete [branch_name]
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello]]></title>
        <id>https://cutezhangq.github.io/post/hello-gridea/</id>
        <link href="https://cutezhangq.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎来到我的博客 ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎来到我的博客 ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>